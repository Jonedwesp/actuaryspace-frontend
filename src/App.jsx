// src/App.jsx
// --- Top of App.jsx ---

import React, { useEffect, useMemo, useRef, useState } from "react";
import "./App.css";

// 1. Add the prefix to your string here:
export const GMAIL_SOUND_DATA = "data:audio/mpeg;base64,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qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpMQU1FMy4xMDCqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+5JkQI/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqTEFNRTMuMTAwqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uSZECP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7kmRAj/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=";
export const GCHAT_SOUND_DATA = "data:audio/mpeg;base64,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DOIxLsKLSBiyFGAG4QACXAjJEwgNIGLARqJewAGLwcxWty02bMmhGTMj05eXWPnxGS3z5r5m6WGfz06SSFu66qDUkRFIomPWHfr+bW2KlgD//////1sioqLCR////rFVBADHFTnPlW4PK/YA0eFmESZAtaB9Lj6gfhI+jwjIyOZy2hlHR4VvMyP5nqZPJmS/5l+vL1LKX/+cobE4/DuyrfTV+0zPv+wAi0oNJSIZBAsaFCT0SRYCBQDEgZIgsRCRpjowkPJBVPHsGJaB//tSZN0I8fsRw7sjEMISaKgQAGLwSBSHDuyYYkhJI9/AAYvBWOujyT1EgoSf48iEyIytDHIChICs9KVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+1Jk4QDh+yvCiykYxhSAB2AAAlwIfN0MxeRgCEMAEYgACTRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7UmTjDPI2NsMTBhliAAANIAAAAQeAGv5kmMJAAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
export const TRELLO_SOUND_DATA = "data:audio/mpeg;base64,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3v//1f2///xgABQAPfQAAB6f+nOWIr/6//tCZBwB0UQ42XgMENQVQBotACIABNDjWaA8Q1A/gGlMAIgCym///txYCyoTDW0DMHGYT7U5+it0q4lwMIpvnQ6/Wx9f7f/9HR///////oDlgH//mjrxUEn1Oq/V///0VQLshdvtQAQBm8J6zK7MIwCu0BCXVPoyI7J1QyTVp9rf/0p///////HewAAA//+/W9N/1VKG///4jAv0H4+4BEAE/G68uZIQaKpKyXGdn+1X5tWqTb////tAZCsAwUI412gPEMQQgBoDACIABODjY6Awo1BHC2mMAAy6/pRv//////jQAugALALcgCcuFHUSz/////LepQJaxcNtQAgB9tbkyuBBmTsDHAEBdvrPZtK1dkc//b/9Gdv//////oCygBgAdAdq/BQl/+v9HdX/oAkjEw2tA+IygurB3ERtkj0eXpn2VmpRHeYv9ttG/+rFW//////+gbAAFAA/q/waB7Pf///8Sgy7+VUDb47/+0JkOwExQzjWaC8ptBBiujMAQ6CE+ONVoLzo0EgAapAAiAbgbYIEAfRUIRZFoEEfglGpcxFT/1rnTqKd+m3/9SwvLf///gwIAIAAKkAAP/PJmZ//85SD///9IEjQlAtof2RSRRSJoEOFLLqV2//S0kK6lNTq6Dof/zpLjSas7///+GYAQHb////pqVhQ7/////7r5wJQAtzGw+2ShAH/121GFRW3TQkf/3HMX4XzVE//46Hjr1//+0JkSwHBPjjY6UAXjBKkejoEAlyFCONRpoC+EE0cpsgDlqD5ld2v///yg/bQAAAZxRRzFQWBQGyv+09///3AS1jYDAAfCAc6kNjGx49iH7Fs9v//0/fRW5n/xwZYv/+ac7a///+oatqcAA3ibbaInt//yjixqbc3ZV/6agJbRcNtQmAB9UVHHofj0Ox0sef/o7d7KbAyiBHj7O/P/+UDQ4Ms//rX////USGAAAAAtsABAH/9pM3/+0JkWYTBQzjX6WE73BMCihMAAy6FDONDoODogFIR6IwACSqAHw2lz/////8sAHCIBbaCCAPWz6sISAJ7QGHf+TR90JKlsSbIVrFN/8YyD///////oBZaCAAKTG82FC08dxT+93//+ioCWwajbYqoAfdq2Ym0wg7lrnNK8Z2/VX7NdyhiHIZ32RDV/+gsChf/+7r9qX//6BuWoAgD//zsUGpFRd4ZYV6B5lf///WBbYNh9sBCAP//+0JkZoDBcjlV6UM9HBWgGi0AAgCFHONJoDyk0EYJ6AwACHru6t0jwFRzHYmgB/qRs4LAbWwNHQTOQf/qWFX/51rI2Yi9v/8ThEsABDAEjv/////X/////9G6nhMtALSFcu+AYAH1LVYvkQAJWApYK40CfNEP19i5+SoYVFhBaQLV1vn/6w/lg/DZ/9JTXU////2DK21CiAH1f+dDBXKo/9X7//8SABuDQf/gVAD9akUTYWSGRwf/+0JkcIDBgDjT6A841BUgGfMAAgCF+OVVpYTvcEscqAwAnoL0rDZPnlf85S03gmAnJIDhrQQSKRP/8DSZcMv/7qnVX///1CwA6AByUAAAJBnf+5WojCyP////oQESDtgCAA+zJMiTQm0BOkBkSRImVL/5OfFfWmpRjHNDVC/Lf1JoLE9FcMI6N/dbIqfaq///9jMEaLC0AAAf/////2BHysrraY1P/+DkgAHxmcoV6kXRFKzDQNb/+0JkdgBBuTlM6oNssBEAGkMAAgCG2OU3qYzywEeDZ+gAiQLtJaTNbdfV1dCeYroqUhUpO9nprV+kaJBfgKOFtSI6buzuio2UkpfdT79e/rbmwtICoGqXETCv//Kqq+RK//r/JhsGkgrb/9////6ieOJOeQAiQcYCAA+ucoZWBM4ZPlkvsZr//ZJCuZIJpItdT2Qd6m/d9gYCEHUhqf6FqVmW27V///WPgSFCSNgACYtXMr6qxev/+0BkdwDRzTjK0oNsshLHGjMIBdWITOUeQXJIiHAdI8QAtTj/rW8NOWbm00X///cAh4AA+utSR4ewMUpCt8bBXNDc/z/y7AMYjM6WiAf1UXdALbEIImKkgz10VvbrX///XXdAmgezZXb////zdhcRj8OmMzt////9WvOQKA4uygUSwBEAflSw0DIh/KKkzf/5iMs88jqZZ2d20Uobv9aiCDhKCasZ63ur99///zUD0HqgxAD/wf/7QmRqgNG+OUpQOmogF2RpswBPpocE5SLKBi9IXJzjgAUWoKH+f/0muhoiDJaWf/////9YFngAD7EEQqVmQpHA5yhkyX//3dVNNB2ZenQU6NrV/qmInsTESATJBzN1s9V/qt///3LgKpokkOP+3/p/3cyHUIE0//////eopbwAD79RmRgD+QXMF9BND//lCPQEkXPnOqbRP91LBpKIYBbLpX9f////1RqCRpK/q+rCgOd0///////7QmRkgNGMOMo4GVGiFocZEgQHXAaw5yBA7ghASJxkiBAVcK1aYFdnxSNV5AYW0JfH7nM8P/7/RTa1J11rd6v/SVDBpLhKJ56XrX+j99f//j7C043RJ/qn+7orhYKev/////XMjwbrvAAP6rOXQ3oKgCXQF//lEBBRlE2dAITMX/UyRMjDDRhoMu7+v////3qI0MKHnrAAP/wART9/7dKp/+eVELX///dHNh+1kTIgICX4DW0mjf/7QmRmDdFyOUiSg20gDsco8ADl0gXA5x4g6giQSByjxAKfEn//2nJFPUArIMaH/UqkLARYwwMiqqtul////syx2BPZAL//MN/zqqXAiRVl21/////5FSQAD9zT1kPkMM3KXLP+/1v6K0FutavQsv/z1Qa4ehLQ7KTpK1V7////q3YvAzLaEoaAB/9Q4np//+jhZ////Ef0BrhbBm8ORxBSndv6v61/b6f9fqZalAfiUAWxam04+v/7QmRxDdFuOcgSgYNgFGRZEggHZgWk4x5KBa9ISRxlCCAdsN2Xb////SXF0HQanND//Dr/uYQYBAYI1V//9YdV+yC6jxFwEMQVDjwMAxlLL1+61X6ra3Uk08MsMiGtIObKqSqq32/9m//QOkwBcmrnMR/9kAgCUZnV////6e9XUQi+wioaAAkWWfeyVAngbQB14qkuE5ZffVkX3X//xNxICWi3Zezfb////41A7zZvR/+AH9+3v//7QmR5jdGBOcaQGoGyD8RZIggFagWY5RgA6ahIPpGkRBAVsv/5tnjYMPXTX///19PQRV2VDudtCFuAhFKEr0ye//+tndT1I+pS/9mbrTWBZHiOAV01Kdf3Vb/7/9XxZgFEW5/8hH/9zscQX/v/////FP9XSOjWBDOC+xnRA9n/O+n+b/of9woS0OwnSbN6/Qv1fX/W/1pEiAnDQf9irv/oEB//61G//////+oL62TAAASCBSzmfP/7QmSEgfGNOcWCgYtgEccowAAq0AWI5RtqBa2AYZxiwBAeEOICHIaMp7trd/z7ftdPrr3TX0QLkFY6Jzf/+lfVunf9QoADTrPur//Cd/1405SN7//vT//34gGUmYs1WpSU0AegHwPoW9/RbbP3z/z/6qQ1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VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+0Jktg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+0Jktg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+0Jktg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+0Jktg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+0Bkto/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7QmS2D/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7QmS2D/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7QmS2D/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7QmS2D/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7QmS2D/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==";
// import trelloIcon from "./assets/Trello Pic.png";
//  NEW: Pure SVG Data URI guarantees 0ms render time for notifications
const trelloIcon = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Crect width='24' height='24' rx='4' fill='%230079bf'/%3E%3Crect x='5' y='5' width='6' height='14' rx='1.5' fill='%23ffffff'/%3E%3Crect x='13' y='5' width='6' height='9' rx='1.5' fill='%23ffffff'/%3E%3C/svg%3E";
import gmailIcon from "./assets/Gmail pic.png";
import whatsappIcon from "./assets/WhatsApp.png";
import gchatIcon from "./assets/Google Chat.png";

const PERSONA = import.meta.env.VITE_PERSONA || "UNKNOWN";

const PERSONA_TRELLO_LISTS =
  PERSONA.toUpperCase() === "SIYA"
    ? [
        "Siya - Review", 
        "Siya",
        "Bonisa",        
        "Songeziwe",     
        "Enock"          
      ]
    : PERSONA.toUpperCase() === "YOLANDIE"
    ? [
        "Yolandie to Data Capture",
        "Yolandie to Analyst",
        "Yolandie to Data Analyst",
        "Yolandie to Reviewer",
        "Yolandie to Send",
      ]
    : [];

/* ---------- Password Gate ---------- */
const APP_PASSWORD = import.meta.env.VITE_APP_PASSWORD || "";
console.log("[PW GATE] enabled?", !!APP_PASSWORD, "len=", APP_PASSWORD.length);

function PasswordGate({ children }) {
  const [pw, setPw] = React.useState("");
  const [err, setErr] = React.useState("");

  // If no password set in Netlify env, don't gate (avoids locking yourself out by accident)
  const enabled = !!APP_PASSWORD;

  const unlocked =
    !enabled || localStorage.getItem("APP_UNLOCKED") === "1";

  const tryUnlock = () => {
    if (!enabled) return;
    if (pw === APP_PASSWORD) {
      localStorage.setItem("APP_UNLOCKED", "1");
      setErr("");
      window.location.reload(); // simplest: reload into unlocked state
    } else {
      setErr("Wrong password.");
    }
  };

  if (unlocked) return children;

  return (
    <div
      style={{
        minHeight: "100vh",
        display: "grid",
        placeItems: "center",
        padding: 24,
        background: "#0b0f17",
        color: "white",
        fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, Arial",
      }}
    >
      <div
        style={{
          width: "min(420px, 92vw)",
          background: "rgba(255,255,255,0.06)",
          border: "1px solid rgba(255,255,255,0.12)",
          borderRadius: 16,
          padding: 20,
          boxShadow: "0 20px 60px rgba(0,0,0,0.45)",
        }}
      >
        <div style={{ fontSize: 18, fontWeight: 700, marginBottom: 8 }}>
          ActuarySpace  {PERSONA.toUpperCase() === "YOLANDIE" ? "Yolandie" : PERSONA.toUpperCase() === "SIYA" ? "Siya" : "Unknown"}
        </div>
        <div style={{ opacity: 0.85, marginBottom: 14 }}>
          Enter password to continue.
        </div>

        <input
          type="password"
          value={pw}
          onChange={(e) => setPw(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") tryUnlock();
          }}
          placeholder="Password"
          style={{
            width: "100%",
            padding: "12px 12px",
            borderRadius: 12,
            border: "1px solid rgba(255,255,255,0.18)",
            outline: "none",
            background: "rgba(255,255,255,0.08)",
            color: "white",
            fontSize: 14,
          }}
        />

        {err && (
          <div style={{ marginTop: 10, color: "#ff9aa2", fontSize: 13 }}>
            {err}
          </div>
        )}

        <button
          onClick={tryUnlock}
          style={{
            marginTop: 12,
            width: "100%",
            padding: "12px 12px",
            borderRadius: 12,
            border: "none",
            background: "white",
            color: "#0b0f17",
            fontWeight: 700,
            cursor: "pointer",
          }}
        >
          Unlock
        </button>

        <div style={{ marginTop: 10, fontSize: 12, opacity: 0.7 }}>
          Tip: If you change the password in Netlify later, clear site data / localStorage.
        </div>
      </div>
    </div>
  );
}

/* ---------- helpers ---------- */
function formatUKTime(date) {
  // Chats (WhatsApp/Slack): HH:MM
  return date.toLocaleTimeString("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  });
}
function formatUKTimeWithSeconds(date) {
  // Notifications only: HH:MM:SS
  return date.toLocaleTimeString("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });
}

function formatGchatTime(isoString) {
  if (!isoString) return "";

  const now = new Date();
  const msgTime = new Date(isoString);

  const diffMs = now - msgTime;
  const diffMin = Math.max(0, Math.floor(diffMs / 60000));
  const diffHr = diffMin / 60;

  const sameDay =
    now.getFullYear() === msgTime.getFullYear() &&
    now.getMonth() === msgTime.getMonth() &&
    now.getDate() === msgTime.getDate();

  const yesterday = new Date(now);
  yesterday.setDate(now.getDate() - 1);

  const isYesterday =
    msgTime.getFullYear() === yesterday.getFullYear() &&
    msgTime.getMonth() === yesterday.getMonth() &&
    msgTime.getDate() === yesterday.getDate();

  // 1. within last hour  "32min"
  if (diffMin < 60) {
    return `${diffMin}min`;
  }

  // 2. today but >1 hour  "10:34 AM"
  if (sameDay) {
    return msgTime.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
    });
  }

  // 3. yesterday  "Yesterday, 10:34 AM"
  if (isYesterday) {
    return `Yesterday, ${msgTime.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
    })}`;
  }

  // calendar days difference (more reliable than diffHr/24)
  const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const startOfMsgDay = new Date(msgTime.getFullYear(), msgTime.getMonth(), msgTime.getDate());
  const daysAgo = Math.floor((startOfToday - startOfMsgDay) / 86400000);

  // 4. 26 days ago
  if (daysAgo >= 2 && daysAgo <= 6) {
    return msgTime.toLocaleString("en-US", {
      weekday: "short",
      hour: "numeric",
      minute: "2-digit",
    });
  }

  // 5.  7 days ago  "Jan 23, 09:15 PM"
  return `${msgTime.toLocaleString("en-US", { month: "short" })} ${msgTime.getDate()}, ${msgTime.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
  })}`;
}

function formatDividerDate(isoString) {
  if (!isoString) return "";
  const d = new Date(isoString);
  return d.toLocaleDateString("en-US", { weekday: 'long', month: 'short', day: 'numeric' });
}

function formatLongDate(isoString) {
  if (!isoString) return "";
  const d = new Date(isoString);
  return d.toLocaleDateString("en-US", { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
}

function getGchatTimezone() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString("en-US", { hour: 'numeric', minute: '2-digit' });
  const offset = -now.getTimezoneOffset() / 60;
  const tzDisplay = offset >= 0 ? `GMT+${offset}` : `GMT${offset}`;
  return `${timeStr} ${tzDisplay}`;
}

function normalizeGChatMessage(m) {
  return m?.message || m;
}

function getMsgTs(m) {
  const msg = normalizeGChatMessage(m);
  return new Date(msg?.createTime || msg?.updateTime || 0).getTime();
}

function msgKey(m) {
  const msg = normalizeGChatMessage(m);
  return msg?.name || msg?.id || "";
}

function dedupeMergeMessages(prev, incoming) {
  const seen = new Set((prev || []).map((m) => msgKey(m)).filter(Boolean));
  const merged = [...(prev || [])];

  for (const m of incoming || []) {
    const msg = normalizeGChatMessage(m);
    const k = msgKey(msg);
    if (!k) continue;
    if (seen.has(k)) continue;
    seen.add(k);
    merged.push(msg);
  }

  // This puts the largest (newest) timestamp at the top
merged.sort((a, b) => getMsgTs(a) - getMsgTs(b));
  return merged;
}

/* ----- Trello date helpers ----- */
function pad2(n) { return String(n).padStart(2, "0"); }
function isWeekend(d) { const w = d.getDay(); return w === 0 || w === 6; } // Sun/Sat

// Returns the next business day from `from`, at HH:MM
function nextBusinessDay({ from = new Date(), minDaysAhead = 1, time = "10:00" } = {}) {
  const d = new Date(from);
  d.setDate(d.getDate() + minDaysAhead);
  while (isWeekend(d)) d.setDate(d.getDate() + 1);
  const [HH, MM] = time.split(":").map(Number);
  d.setHours(HH, MM, 0, 0);
  return d;
}

function nextTrialDate({ from = new Date(), daysAhead = 7 } = {}) {
  let d = new Date(from);
  d.setDate(d.getDate() + daysAhead);
  while (d.getDay() === 0 || d.getDay() === 6) {
    d.setDate(d.getDate() + 1);
  }
  const day = d.getDate();
  const month = d.toLocaleString("en-GB", { month: "short" }); // e.g. Oct
  return `Trial date ${day} ${month}`;
}

function formatDueLine(d) {
  // e.g. "Due 27 Sept 10:00"
  const day = d.getDate();
  const month = d.toLocaleString("en-GB", { month: "short" }); // Sept, Oct, 
  return `Due ${day} ${month} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
}

// Vite-only: this is compile-time transformed (works in prod)
const _AVATAR_MODULES = import.meta.glob(
  "./slack-profiles/*.{png,PNG,jpg,JPG,jpeg,JPEG,webp,WEBP,gif,GIF}",
  { eager: true, import: "default" }
);

console.log("avatar modules", _AVATAR_MODULES);

const AVATARS = (() => {
  const map = {};
  for (const fullPath in _AVATAR_MODULES) {
    const fileBase = fullPath.split("/").pop().replace(/\.[^.]+$/, ""); // e.g. "Albert"
    const keyFull  = fileBase.toLowerCase().trim();                     // "albert"
    const tokens   = keyFull.split(/\s+/);
    const url      = _AVATAR_MODULES[fullPath];

    // full filename ("albert", "alicio o")
    if (!map[keyFull]) map[keyFull] = url;

    // first word
    if (tokens[0] && !map[tokens[0]]) map[tokens[0]] = url;

    // initials (e.g. "ao" from "Alicio O")
    if (tokens.length >= 2) {
      const initials = (tokens[0][0] + tokens[1][0]).toLowerCase();
      if (!map[initials]) map[initials] = url;
    }
  }

  console.log("AVATAR keys", Object.keys(map));  //  should now have lots of names
  return map;
})();


// Normalise aliases (two-letter codes etc.)
const AVATAR_ALIASES = {
  namir: "Namir", nw: "Namir",
  joel: "Joel", jj: "Joel",
  dionee: "Dionee", dd: "Dionee",
  "simon": "Simon", sm: "Simon",
  ryan: "Ryan", ry: "Ryan",
  conah: "Conah", co: "Conah",
  thami: "Thami", th: "Thami",
  melissa: "Melissa", me: "Melissa",
  waldo: "Waldo", wa: "Waldo",
  melvin: "Melvin", mv: "Melvin",
  tiffany: "Tiffany", ti: "Tiffany",
  albert: "Albert", al: "Albert",
  "alicia k": "Alicia K", ak: "Alicia K",
  "alicia o": "Alicia O", ao: "Alicia O",
  ethan: "Ethan", et: "Ethan",
  martin: "Martin", ma: "Martin",
  leonah: "Leonah", le: "Leonah",
  matthew: "Matthew", mt: "Matthew",
  siyabonga: "Siya", siya: "Siya", sd: "Siya",  
  enock: "Enock", en: "Enock",
  treasure: "Treasure", tr: "Treasure",
  melokuhle: "Melokuhle", mk: "Melokuhle",
  eugene: "Eugene", eu: "Eugene",
  bianca: "Bianca", bi: "Bianca",
 jonathan: "Jonathan", jw: "Jonathan",
 bonolo: "Bonolo", bo: "Bonolo", users_109833975621386956073: "Bonolo",
  willem: "Willem", wi: "Willem",
  shamiso: "Shamiso", sh: "Shamiso",
  "min": "Min", mn: "Min",
  songeziwe: "Songeziwe", so: "Songeziwe",
  michelle: "Michelle", mw: "Michelle",
  kwakhanya: "Kwakhanya", kw: "Kwakhanya",
  jennifer: "Jennifer", je: "Jennifer",
  munyaradzi: "Munyaradzi", mu: "Munyaradzi",
  leroy: "Leroy", lr: "Leroy",
  cameron: "Cameron", ca: "Cameron",
  jenny: "Jenny", jn: "Jenny",
  yolandie: "Yolandie", ys: "Yolandie",
  vanessa: "Vanessa", va: "Vanessa",
  yael: "Yael", ya: "Yael",
  cynthia: "Cynthia", cy: "Cynthia",
};

function remapBotName(name) {
  if (!name) return name;
  const trimmed = String(name).trim();
  // Any variant of "ActuarySpaceBot" becomes "Yolandie"
  if (/^actuaryspacebot$/i.test(trimmed)) return "Yolandie";
  return trimmed;
}

//  NEW: Global cache for live Trello avatars
let LIVE_TRELLO_AVATARS = {};

function avatarFor(name) {
  if (!name) return null;

  // strip things like " (web)", " (bot)", etc.
  let key = String(name).toLowerCase().trim();
  key = key.replace(/\([^)]*\)/g, "").trim(); 
  key = key.replace(/\s+/g, " ");             

  // 1. Check Live Trello Avatars FIRST
  if (LIVE_TRELLO_AVATARS[key]) return LIVE_TRELLO_AVATARS[key];
  
  const parts = key.split(/\s+/);
  const firstWord = parts[0];
  if (LIVE_TRELLO_AVATARS[firstWord]) return LIVE_TRELLO_AVATARS[firstWord];

  // 2.  THE FIX: Check aliases for the full name OR just the first name
  const alias = AVATAR_ALIASES[key] || AVATAR_ALIASES[firstWord];
  if (alias) {
    const ak = alias.toLowerCase();
    const aliasParts = ak.split(/\s+/);
    const inits = aliasParts.map((p) => p[0]).join("");
    return (
      AVATARS[ak] || 
      AVATARS[aliasParts[0]] || 
      AVATARS[inits] || 
      null
    );
  }

  // 3. Direct hits: full name / first token / initials
  const inits = parts.map((p) => p[0]).join("");

  return (
    AVATARS[key] ||        
    AVATARS[firstWord] ||  
    AVATARS[inits] ||      
    null
  );
}

/* Approved AC names */
const AC_CONTACTS = [
  "Namir","Joel","Dionee","Simon","Ryan","Conah","Thami","Melissa","Waldo",
  "Melvin","Tiffany","Albert","Alicia K","Alicia O","Ethan","Martin","Leonah",
  "Matthew","Siyabonga","Enock","Treasure","Melokuhle","Eugene","Bianca",
  "Jonathan","Bonolo","Willem","Shamiso","Min","Songeziwe","Michelle",
  "Kwakhanya","Jennifer","Munyaradzi","Leroy","Cameron","Jenny","Yolandie",
  "Vanessa","Yael","Cynthia"
];
const AC_EMAIL_MAP = {
  "Namir": "namir@actuaryconsulting.co.za",
  "Joel": "joel@actuaryconsulting.co.za",
  "Dionee": "dionee@actuaryconsulting.co.za",
  "Simon": "simone@actuaryconsulting.co.za",
  "Ryan": "ryan@actuaryconsulting.co.za",
  "Conah": "conah@actuaryconsulting.co.za",
  "Thami": "thami@actuaryconsulting.co.za",
  "Melissa": "melissa@actuaryconsulting.co.za",
  "Waldo": "waldo@actuaryconsulting.co.za",
  "Melvin": "melvin@actuaryconsulting.co.za",
  "Tiffany": "tiffany@actuaryconsulting.co.za",
  "Albert": "albert@actuaryconsulting.co.za",
  "Alicia K": "aliciak@actuaryconsulting.co.za",
  "Alicia O": "aliciao@actuaryconsulting.co.za",
  "Ethan": "ethan@actuaryconsulting.co.za",
  "Martin": "martin@actuaryconsulting.co.za",
  "Leonah": "leonah@actuaryconsulting.co.za",
  "Matthew": "matthew@actuaryconsulting.co.za",
  "Siyabonga": "siya@actuaryspace.co.za",
  "Enock": "enock@actuaryconsulting.co.za",
  "Treasure": "treasure@actuaryconsulting.co.za",
  "Melokuhle": "melokuhle@actuaryconsulting.co.za",
  "Eugene": "eugene@actuaryconsulting.co.za",
  "Bianca": "bianca@actuaryconsulting.co.za",
  "Jonathan": "jonathan@actuaryconsulting.co.za",
  "Bonolo": "bonolo@actuaryconsulting.co.za",
  "Willem": "willem@actuaryconsulting.co.za",
  "Shamiso": "shamiso@actuaryconsulting.co.za",
  "Min": "mine@actuaryconsulting.co.za",
  "Songeziwe": "songeziwe@actuaryconsulting.co.za",
  "Michelle": "michelle@actuaryconsulting.co.za",
  "Kwakhanya": "kwakhanya@actuaryconsulting.co.za",
  "Jennifer": "jennifer@actuaryconsulting.co.za",
  "Munyaradzi": "munyaradzi@actuaryconsulting.co.za",
  "Leroy": "leroy@actuaryconsulting.co.za",
  "Cameron": "cameron@actuaryconsulting.co.za",
  "Jenny": "jenny@actuaryconsulting.co.za",
  "Yolandie": "yolandie@actuaryspace.co.za",
  "Vanessa": "vanessa@actuaryconsulting.co.za",
  "Yael": "yael@actuaryconsulting.co.za",
  "Cynthia": "cynthia@actuaryconsulting.co.za"
};

/* ---------- WhatsApp ---------- */
const WA_AUTO_REPLIES = [
  "Got it  Ill update Trello now.",
  "Thanks, Ill review and circle back shortly.",
  "Perfect, Ill push this to the reviewer.",
  "Cool, taking this forward.",
  "Noted. Ill check the attachments too.",
  "Thanks, that helps. Will revert soon.",
];
function buildSeedChats() {
  const t = (minsAgo) => formatUKTime(new Date(Date.now() - minsAgo * 60 * 1000));
  return {
    Siyabonga: [
      { from: "them", text: "Morning Yolandie, did you see the new instruction from Cameron? It looks like LOS, death cert is attached.", time: t(210) },
      { from: "me",   text: "Morning Siya, yes I saw it. Ill create the AC REF and forward to you and the team.", time: t(209) },
      { from: "them", text: "Thanks. Please add it to urgent reviews as well so we dont miss it.", time: t(208) },
      { from: "me",   text: "Done. I also added a note on the trial date and linked the email thread.", time: t(206) },
      { from: "them", text: "Great. Im drafting the checklist now. If were missing bank statements Ill ping the client partner.", time: t(203) },
      { from: "me",   text: "Perfect. Shout if you need anything else from the inbox or Tracker.", time: t(201) },
      { from: "them", text: "Can you move GA Chabani to Analyst? I want to start with the data capture.", time: t(198) },
      { from: "me",   text: "Moved. Status set to Capturing Data and label RAF LOE kept.", time: t(197) },
      { from: "them", text: "Legend. Ill update once the checklists are through.", time: t(196) },
    ],
    Waldo: [
      { from: "them", text: "Ive added comments to the LOE draft. The earnings periods needed a small adjustment.", time: t(180) },
      { from: "me",   text: "Thanks, Ill acknowledge and let the reviewer know. Did you attach the revised schedule?", time: t(179) },
      { from: "them", text: "Yes, attached. Also flagged one assumption in a yellow note so its easy to spot.", time: t(177) },
      { from: "me",   text: "Perfect. Ill forward the pack to the reviewer bucket and tag you on Slack if anything is unclear.", time: t(175) },
      { from: "them", text: "Appreciated. If the client replies on the old thread, please loop me back in.", time: t(173) },
      { from: "me",   text: "Will do. Ill keep the AC REF thread tidy and up to date.", time: t(172) },
    ],
    Michelle: [
      { from: "them", text: "Client just sent the payslips. Uploading now. There are two missing months but they promised to send today.", time: t(160) },
      { from: "me",   text: "Thank you. Ill add what we have to the Trello card and note the missing months.", time: t(159) },
      { from: "them", text: "Please also add their instruction letter. I put it in the same folder.", time: t(157) },
      { from: "me",   text: "Added and linked. Ill draft the acknowledgement mail and include our AC REF.", time: t(155) },
      { from: "them", text: "Perfect, that keeps them calm. Let me know when you send it so I can track response times.", time: t(154) },
      { from: "me",   text: "Acknowledgement sent. Tracker updated with todays date.", time: t(152) },
    ],
    Leonah: [
      { from: "them", text: "Moving this to Ready to Send. I checked references and the annexures render correctly.", time: t(120) },
      { from: "me",   text: "Nice. Ill do a last scan for formatting and then send from the generic mailbox.", time: t(119) },
      { from: "them", text: "Please CC me and the client partner. Subject line has the AC REF already.", time: t(118) },
      { from: "me",   text: "Done  queued. Ill paste the delivery confirmation back into the card.", time: t(116) },
    ],
    Matthew: [
      { from: "them", text: "Can we add this to urgent reviews? Counsel is pushing for a quick turnaround.", time: t(95) },
      { from: "me",   text: "Added. Is there any missing info from the last round?", time: t(94) },
      { from: "them", text: "We still need the affidavit and one proof of income. Client promised by lunch.", time: t(93) },
      { from: "me",   text: "Got it. Ill hold the reviewer until those land, then release.", time: t(92) },
      { from: "them", text: "Thanks. If it slips, please post a short note in #urgent-reviews.", time: t(91) },
      { from: "me",   text: "Will do. Ill keep the label on HIGH URGENT for visibility.", time: t(90) },
    ],
  };
}

/* ---------- Email draft templates (Yolandie picks one, then edits) ---------- */
const DRAFT_TEMPLATES = [
  {
    id: "new_blank",
    label: "New Draft",
    body: "",            // completely empty
  },
  {
    id: "new_instr_ack",
    label: "New instructions  acknowledge & confirm trial / lodgement",
    body: [
      "Dear [Attorney Name],",
      "",
      "Thank you for your email and the new instructions in the above matter.",
      "",
      "We acknowledge receipt of the instruction letter and supporting documentation. ",
      "Kindly confirm the following so that we can proceed efficiently:",
      "1. Has this matter been lodged with the Road Accident Fund?",
      "2. Is there a trial date or any court deadline for this matter?",
      "",
      "Once we receive your confirmation (and any outstanding documents), we will proceed with our calculations and revert with an estimated turnaround time.",
      "",
      "Kind regards,",
      "Namir Waisberg",
      "Actuary Consulting",
    ].join("\n"),
  },
  {
    id: "awaiting_medicals",
    label: "Acknowledgement  awaiting medico-legal reports",
    body: [
      "Dear [Attorney Name],",
      "",
      "Thank you for your email and the documentation provided in respect of the above matter.",
      "",
      "We confirm safe receipt of the available documents. We note that certain medico-legal reports are still outstanding, and will commence our calculations once these have been received.",
      "",
      "Please feel free to let us know if there are any particular time constraints or court dates that we should be aware of.",
      "",
      "Kind regards,",
      "Namir Waisberg",
      "Actuary Consulting",
    ].join("\n"),
  },
  {
    id: "missing_income_docs",
    label: "Request  missing income / bank documents",
    body: [
      "Dear [Attorney Name],",
      "",
      "Thank you for your instructions in the above matter.",
      "",
      "We have reviewed the documents received and note that certain income-related records (e.g. payslips, bank statements and/or tax returns) are still outstanding.",
      "",
      "Kindly provide the missing income documents at your earliest convenience so that we can finalise the loss of earnings calculations.",
      "",
      "If there is any difficulty in obtaining these records, please let us know and we will advise on possible alternatives.",
      "",
      "Kind regards,",
      "Namir Waisberg",
      "Actuary Consulting",
    ].join("\n"),
  },
  {
    id: "progress_update",
    label: "Progress update  reassurance on timeline",
    body: [
      "Dear [Attorney Name],",
      "",
      "We refer to the above matter and confirm that we are in the process of finalising our actuarial calculations.",
      "",
      "All available documents have been captured and we are now working through the detailed projections. ",
      "Barring any unforeseen issues or further information requests, we anticipate reverting with a draft report by [date].",
      "",
      "Should any new information become available in the interim, please forward it to us so we can incorporate it before finalising.",
      "",
      "Kind regards,",
      "Namir Waisberg",
      "Actuary Consulting",
    ].join("\n"),
  },
  {
    id: "send_draft_report",
    label: "Cover email when sending draft report",
    body: [
      "Dear [Attorney Name],",
      "",
      "We attach herewith our draft actuarial report in respect of the above matter for your review.",
      "",
      "Kindly consider the contents and let us know if there are any factual corrections, additional information or points of clarification before we finalise the report.",
      "",
      "Once you are satisfied that the draft accords with your instructions and the available documentation, we will prepare and issue the signed final report.",
      "",
      "Kind regards,",
      "Namir Waisberg",
      "Actuary Consulting",
    ].join("\n"),
  },
];

/* ---------- Email (Gmail view with split PDF preview) ---------- */
const EMAIL_THREADS = [
  {
    id: "eml-001",
    subject: "FW: LR MDLET SHE vs RAF (OUR REF: 15/M412-0001)",
    fromName: "Namir Waisberg",
    fromEmail: "namir@actuaryconsulting.co.za",
    to: ["Yolandie <yolandie@actuaryspace.co.za>"],
    time: formatUKTime(new Date()),
    body:
`---------- Forwarded message ----------
From: Roshan Morar <litigation@dhllaw.co.za>
Date: Mon, Jul 28, 2025 at 9:03 AM
Subject: LR MDLETSHE vs RAF (OUR REF: 15/M412-0001)
To: Namir Waisberg <namir@actuaryconsulting.co.za>
Cc: Tinashe Jaya <tinashe@dhllaw.co.za>

PART 2

I refer to the above matter.

Attached herewith please find our instruction letter, together with attachments in 3 parts, for your attention.

Kind Regards

Roshan Morar
Du Toit Havemann & Lloyd
Tel: (031) 201 3555  Fax: (031) 201 3650
Email: litigation@dhllaw.co.za
Website: www.dhllaw.co.za`,
    attachments: [
      { name: "New Instruction.pdf", url: "/pdfs/New-Instruction.pdf", type: "pdf" },
    ],
    actions: [
      { key: "submit_trello",  label: "Submit to Trello" },
      { key: "update_tracker", label: "Update AC Tracker" },
    ],
  },
  {
    id: "eml-002",
    subject: "FW: LR MDLETSHE vs RAF (OUR REF: 15/M412-0001)  PART 3",
    fromName: "Namir Waisberg",
    fromEmail: "namir@actuaryconsulting.co.za",
    to: ["Yolandie <yolandie@actuaryspace.co.za>"],
    time: formatUKTime(new Date()),
    body:
`---------- Forwarded message ----------
From: Roshan Morar <litigation@dhllaw.co.za>
Date: Mon, Jul 28, 2025 at 9:06 AM
Subject: LR MDLETSHE vs RAF (OUR REF: 15/M412-0001)
To: Namir Waisberg <namir@actuaryconsulting.co.za>
Cc: Tinashe Jaya <tinashe@dhllaw.co.za>

PART 3

I refer to the above matter.

Attached herewith please find our instruction letter, together with attachments in 3 parts, for your attention.

Kind Regards
Roshan Morar`,
    attachments: [
      { name: "Payslips.pdf",        url: "/pdfs/Payslips.pdf",        type: "pdf" },
      { name: "Bank Statement.pdf",  url: "/pdfs/Bank-Statement.pdf",  type: "pdf" },
      { name: "ID/Birth/Death Certificate.pdf", url: "/pdfs/ID-Birth-Death-Certificate.pdf", type: "pdf" },
      { name: "New Instruction.pdf", url: "/pdfs/New-Instruction.pdf", type: "pdf" },
      { name: "Payslips (extra).pdf",url: "/pdfs/Payslips.pdf",        type: "pdf" },
    ],
    actions: [
      { key: "submit_trello",  label: "Submit to Trello" },
      { key: "update_tracker", label: "Update AC Tracker" },
    ],
  },
  {
    id: "eml-003",
    subject: "FW: MOHLAKOANE DONALD PULENG // RAF // ASSESSMENT",
    fromName: "Namir Waisberg",
    fromEmail: "namir@actuaryconsulting.co.za",
    to: ["Yolandie <yolandie@actuaryspace.co.za>"],
    time: formatUKTime(new Date()),
    body:
`---------- Forwarded message ----------
From: Ndisalelwani Mphadziseni <maleka2@knmattorneys.co.za>
Date: Mon, Jul 28, 2025 at 10:18 AM
Subject: MOHLAKOANE DONALD PULENG // ROAD ACCIDENT FUND // ASSESSMENT
To: Namir Waisberg <namir@actuaryconsulting.co.za>
Cc: multiple recipients

Good day

I hope this email finds you well.

Kindly find the attached documents for your valued attention.
Kindly also note that the Orthopaedic, Occupational Therapist reports and any additional information will be sent through as soon as we receive them.

Claimant contact details: 079 810 8834

Regards
N.P. Mphadziseni`,
    attachments: [
      { name: "Bank Statement.pdf",             url: "/pdfs/Bank-Statement.pdf",             type: "pdf" },
      { name: "ID/Birth/Death Certificate.pdf", url: "/pdfs/ID-Birth-Death-Certificate.pdf", type: "pdf" },
      { name: "Payslips.pdf",                   url: "/pdfs/Payslips.pdf",                   type: "pdf" },
      { name: "New Instruction.pdf",            url: "/pdfs/New-Instruction.pdf",            type: "pdf" },
      { name: "Payslips (extra).pdf",           url: "/pdfs/Payslips.pdf",                   type: "pdf" },
      { name: "Bank Statement (extra).pdf",     url: "/pdfs/Bank-Statement.pdf",             type: "pdf" },
    ],
    actions: [
      { key: "submit_trello",  label: "Submit to Trello" },
      { key: "update_tracker", label: "Update AC Tracker" },
    ],
  },
];

const DEMO_CASE_CARD_TEXT = `
Case Card Summary

Claimant: Siyanda Sidwell Kali
Matter: RAF LOE
AC REF: MANANSSKAL
Description: Fwd: NEW INSTRUCTIONS - SS KALI (AC REF: MANANSSKAL)
`.trim();

/* ---------- Trello card modal (helpers) ---------- */
function randomPick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function buildTrelloCardFromNotif(notifText = "") {
  // Try get a card title from the quoted bit in the notification
  const titleFromNotif =
    (notifText.match(/"([^"]+)"/)?.[1]) ||
    "C Makhubele (TC 25 September 14:00)";

  const actor = "yolandie123.yjvv";
  const possibleTargets = AC_CONTACTS.filter(n => !/yolandie/i.test(n));
  const target = randomPick(possibleTargets);

  return {
    id: "trello-card-1",
    boardList: "Yolandie to Send",
    title: titleFromNotif,
    dueDisplay: "Due 25 Sept 09:12",
    members: ["Waldo", "Michelle", "Enock", "Siyabonga", "Yolandie"],
    labels: ["RAF LOE"],
    description: deriveDescriptionFromTitle(titleFromNotif),
    timers: { time: "10h 19m" },
    activity: [
      { who: actor, text: `added this card to ${target}`, time: formatUKTime(new Date()) },
      {
        who: "Matthew Darch",
        text: [
          "*Excel:*",
          "1. HRT: Cell M39 has the incorrect start date (should be 2032).",
          '2. HRT: Cell AD18 should reference =L38+$M$39*5.',
          "3. Set career ceiling at age 45 (year 2055).",
          "4. Calc date needs updating.",
          "",
          "*Report:*",
          " Update report date, calc date, future loss period and summary tables after Excel changes."
        ].join("\n"),
        time: formatUKTime(new Date())
      }
    ]
  };
}

function parseCustomFieldsFromBadges(badges = []) {
  const out = {};
  badges.forEach(b => {
    const t = b.text || "";
    if (/^Priority/i.test(t)) out.priority = canonicalPriority(t.replace(/^Priority:\s*/i, ""));
    if (/^Status/i.test(t))   out.status   = t.replace(/^Status:\s*/i, "");
    if (/^Active/i.test(t))   out.active   = t.replace(/^Active:\s*/i, "");
  });
  return out;
}

function deriveDescriptionFromTitle(title = "") {
  // strip LM/MD time tags and the Due tag, keep other text
  let s = String(title);
  s = s.replace(/\(\s*(LM|MD)\s+\d{1,2}\s+\w+\s+\d{2}:\d{2}\s*\)/gi, "");
  s = s.replace(/\(\s*Due[^)]*\)/gi, "");
  s = s.replace(/\s{2,}/g, " ").replace(/\s*-\s*$/,"").trim();
  // Style: "Re: <remaining>"
  return s ? `Re: ${s}` : "";
}

// --- Trello custom field setter ---
async function setCardCustomField(cardId, fieldName, valueText) {
  const res = await fetch("/.netlify/functions/trello-set-custom-field", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ cardId, fieldName, valueText }),
  });
  const json = await res.json().catch(async () => ({ raw: await res.text().catch(() => "") }));
  if (!res.ok || json?.ok !== true) {
    const msg = JSON.stringify(json);
    throw new Error(`Trello write failed (${res.status}): ${msg}`);
  }
  return json;
}

// NEW: Description setter (writes Trello card.desc)
async function setCardDescription(cardId, desc) {
  const res = await fetch("/.netlify/functions/trello-set-description", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ cardId, desc }),
  });
  const json = await res.json().catch(async () => ({ raw: await res.text().catch(() => "") }));
  if (!res.ok || json?.ok !== true) {
    const msg = JSON.stringify(json);
    throw new Error(`Trello description write failed (${res.status}): ${msg}`);
  }
  return json;
}

/* --- CUSTOM FIELD OPTIONS & COLORS --- */

const PRIORITY_OPTIONS = [
  "HIGH URGENT",
  "URGENT + IMPORTANT",
  "URGENT",
  "NEW CLIENT"
];

const ACTIVE_OPTIONS = [
  "Working on it",
  "Not working on it",
  "Do not move card"
];

const STATUS_OPTIONS = [
  "To Do - RAF",
  "To Do - Other",
  "Doing",
  "Data Review",
  "Asking IP",
  "Ready to be reviewed - 24hr",
  "Ready to be reviewed - URGENT",
  "Ready to be reviewed - New Client Urgent",
  "Ready to be reviewed - Longer Cases",
  "2nd Review",
  "Analyst to Update",
  "Reviewer Respond",
  "Ready To Send",
  "Waiting for client info",
  "Approved",
  "Actuary Expert",
  "Pause",
  "Asking Senior Analyst",
  "Capturing Data",
  "Checklist Doing"
];

// Helper: Get the CSS class for the Select Box based on the selected value
function getCFColorClass(field, value) {
  const v = (value || "").trim();
  if (!v) return "cf-grey-light"; // Default

  // --- PRIORITY ---
  if (field === "Priority") {
    if (v === "HIGH URGENT") return "cf-green-light";
    if (v === "URGENT + IMPORTANT") return "cf-red-light";
    if (v === "URGENT") return "cf-pink-light";
    if (v === "NEW CLIENT") return "cf-pink-light";
  }

  // --- ACTIVE ---
  if (field === "Active") {
    if (v === "Working on it") return "cf-green-light";
    if (v === "Not working on it") return "cf-orange-light";
    if (v === "Do not move card") return "cf-red-light";
  }

  // --- STATUS ---
  if (field === "Status") {
    // Orange
    if (["To Do - RAF", "Ready to be reviewed - Longer Cases", "Pause"].includes(v)) return "cf-orange-light";
    // Blue
    if (["To Do - Other", "Data Review", "Ready to be reviewed - URGENT", "Analyst to Update", "Actuary Expert"].includes(v)) return "cf-blue-light";
    // Green
    if (["Doing", "Ready To Send", "Capturing Data", "Data Review"].includes(v)) return "cf-green-light";
    // Purple
    if (["Asking IP", "Waiting for client info", "Approved"].includes(v)) return "cf-purple-light";
    // Pink
    if (["Ready to be reviewed - 24hr"].includes(v)) return "cf-pink-light";
    // Yellow
    if (["Ready to be reviewed - New Client Urgent", "Asking Senior Analyst"].includes(v)) return "cf-yellow-light";
    // Grey
    if (["2nd Review", "Checklist Doing"].includes(v)) return "cf-grey-light";
    // Red
    if (["Reviewer Respond"].includes(v)) return "cf-red-light";
  }

  return "cf-grey-light";
}

/* Exact Colors from Screenshot 11 */
const ALL_LABEL_OPTIONS = [
 // Green
 { name: "Breach of Contract", bg: "#baf3db", color: "#164b35" },
 { name: "Paid", bg: "#baf3db", color: "#164b35" },
 { name: "Payment arrangement", bg: "#baf3db", color: "#164b35" },
 { name: "Personal injury", bg: "#baf3db", color: "#164b35" },
 { name: "Financial Loss and Damages", bg: "#4bce97", color: "#164b35" },
 { name: "RAF LOE", bg: "#4bce97", color: "#164b35" },
 { name: "Non-RAF LOE", bg: "#4bce97", color: "#164b35" },
 { name: "Pension Calculations", bg: "#1f845a", color: "#ffffff" },
 
 // Yellow/Gold
 { name: "Labour", bg: "#f8e6a0", color: "#533f04" },
 { name: "Maintenance", bg: "#f5cd47", color: "#533f04" },
 { name: "Investment Portfolio Calc", bg: "#9a782d", color: "#ffffff" },
 { name: "Training", bg: "#9a782d", color: "#ffffff" },
 
 // Orange
 { name: "Innovation", bg: "#ffe2bd", color: "#5f3811" },
 { name: "Medical Expenses", bg: "#ffe2bd", color: "#5f3811" },
 { name: "Past Medical Negligence", bg: "#faa53d", color: "#5f3811" },
 { name: "Arbitration", bg: "#b65c02", color: "#ffffff" },
 
 // Red
 { name: "Benefits Calculation", bg: "#ffd2cc", color: "#5d1f1a" },
 { name: "Bond Calculation", bg: "#ffd2cc", color: "#5d1f1a" },
 { name: "Forensic Audit", bg: "#f87462", color: "#5d1f1a" },
 { name: "RyanGPT", bg: "#c9372c", color: "#ffffff" },
 { name: "Waiting payment", bg: "#c9372c", color: "#ffffff" },
 
 // Purple
 { name: "Broken Contract Calc", bg: "#dfd8fd", color: "#352c63" },
 { name: "Building Model", bg: "#dfd8fd", color: "#352c63" },
 { name: "Other", bg: "#9f8fef", color: "#352c63" },
 { name: "Deceased Estate", bg: "#6e5dc6", color: "#ffffff" },
];

function getLabelStyle(name) {
 const colorClass = getLabelColor(name);
 const colorMap = {
  "label-green-light": { backgroundColor: "#baf3db", color: "#164b35" },
  "label-green-norm": { backgroundColor: "#4bce97", color: "#164b35" },
  "label-green-dark": { backgroundColor: "#1f845a", color: "#ffffff" },
  "label-yellow-light": { backgroundColor: "#f8e6a0", color: "#533f04" },
  "label-yellow-norm": { backgroundColor: "#f5cd47", color: "#533f04" },
  "label-brown-norm": { backgroundColor: "#d3c4a5", color: "#4a3a23" },
  "label-orange-light": { backgroundColor: "#ffe2bd", color: "#5f3811" },
  "label-orange-norm": { backgroundColor: "#faa53d", color: "#5f3811" },
  "label-orange-dark": { backgroundColor: "#b65c02", color: "#ffffff" },
  "label-red-light": { backgroundColor: "#ffd2cc", color: "#5d1f1a" },
  "label-red-norm": { backgroundColor: "#f87462", color: "#5d1f1a" },
  "label-red-dark": { backgroundColor: "#ca3521", color: "#ffffff" },
  "label-purple-light": { backgroundColor: "#dfd8fd", color: "#352c63" },
  "label-purple-norm": { backgroundColor: "#9f8fef", color: "#352c63" },
  "label-purple-dark": { backgroundColor: "#6e5dc6", color: "#ffffff" },
  "label-blue-norm": { backgroundColor: "#579dff", color: "#09326c" },
  "label-default": { backgroundColor: "#091e420f", color: "#172b4d" }
 };
 return colorMap[colorClass] || colorMap["label-default"];
}

// Keep these for backward compatibility
function canonicalPriority(txt) {
  const p = String(txt || "").replace(/\s+/g, " ").trim().toUpperCase();
  if (p.includes("HIGH URGENT")) return "HIGH URGENT";
  if (p.includes("URGENT + IMPORTANT")) return "URGENT + IMPORTANT";
  if (p === "URGENT") return "URGENT";
  if (p.includes("NEW CLIENT")) return "NEW CLIENT";
  return "";
}

function priorityTypeFromText(txt) {
  const p = canonicalPriority(txt);
  return getCFColorClass("Priority", p).replace("cf-", "priority-");
}

function statusTypeFromText(txt) {
  return getCFColorClass("Status", txt).replace("cf-", "status-"); 
}

function activeTypeFromText(txt) {
  return getCFColorClass("Active", txt).replace("cf-", "active-");
}

// Helper to assign specific colors and shades to standard labels
function getLabelColor(text) {
 const t = (text || "").toLowerCase().trim();

 // --- GREEN ---
 // Light Green
 if (["breach of contract", "paid", "payment arrangement", "personal injury"].some(k => t.includes(k))) return "label-green-light";
 // Normal Green
 if (["financial loss", "non-raf loe", "raf loe", "raf los"].some(k => t.includes(k))) return "label-green-norm";
 // Dark Green
 if (["pension calculations"].some(k => t.includes(k))) return "label-green-dark";

 // --- YELLOW ---
 // Light Yellow
 if (["labour"].some(k => t.includes(k))) return "label-yellow-light";
 // Normal Yellow
 if (["maintenance"].some(k => t.includes(k))) return "label-yellow-norm";

 // --- BROWN (Mapped to Trello's Orange/Neutral shades) ---
 // Normal Brown
 if (["investment portfolio", "training"].some(k => t.includes(k))) return "label-brown-norm";

 // --- ORANGE ---
 // Light Orange
 if (["innovation", "medical expenses"].some(k => t.includes(k))) return "label-orange-light";
 // Normal Orange
 if (["past medical negligence"].some(k => t.includes(k))) return "label-orange-norm";
 // Dark Orange
 if (["arbitration"].some(k => t.includes(k))) return "label-orange-dark";

 // --- RED ---
 // Light Red
 if (["benefits calculation", "bond calculation"].some(k => t.includes(k))) return "label-red-light";
 // Normal Red
 if (["forensic audit"].some(k => t.includes(k))) return "label-red-norm";
 // Dark Red
 if (["ryangpt", "ryan gpt", "waiting payment"].some(k => t.includes(k))) return "label-red-dark";

 // --- PURPLE ---
 // Light Purple
 if (["broken contract", "building model"].some(k => t.includes(k))) return "label-purple-light";
 // Normal Purple
 if (["other"].some(k => t === "other" || t.includes("other -"))) return "label-purple-norm";
 // Dark Purple
 if (["deceased estate"].some(k => t.includes(k))) return "label-purple-dark";

 // --- BLUE (Extra ones from your previous list if needed) ---
 if (["non-raf los", "share valuation", "farm", "joint actuarial", "professional negligence", "wrongful", "divorce", "accrual", "commercial", "ip los", "general damages", "interest"].some(k => t.includes(k))) return "label-blue-norm";

 return "label-default";
}

function ensureBadgeTypes(badges = []) {
  return (badges || []).map(b => {
    const t = b?.text || "";
    
    // 1. Status / Active (Bottom Row)
    if (/^Active\s*:/i.test(t)) {
      const val = t.replace(/^Active\s*:\s*/i, "");
      return { ...b, type: b.type || activeTypeFromText(val), isBottom: true };
    }
    if (/^Status\s*:/i.test(t)) {
      const val = t.replace(/^Status\s*:\s*/i, "");
      return { ...b, type: b.type || statusTypeFromText(val), isBottom: true };
    }
    
    // 2. Priority (MOVED TO BOTTOM ROW) 
    if (/^Priority\s*:/i.test(t)) {
      const val = t.replace(/^Priority\s*:\s*/i, "");
      //  Changed isTop -> isBottom
      return { ...b, type: b.type || priorityTypeFromText(val), isBottom: true }; 
    }

    // 3. Standard Labels (Top Row) - Assign colors dynamically
    return { ...b, type: b.type || getLabelColor(t), isTop: true };
  });
}

//  NEW HELPER: Match card titles to Trello Cover Colors
function getTrelloCoverColor(title) {
  const t = String(title || "").toLowerCase();
  if (t.includes("out of office")) return "#6CC3E0";  //  CHANGED: Light Blue (Sky)
  if (t.includes("training - analyst")) return "#579dff"; // Trello Blue
  if (t.includes("innovation gold")) return "#faa53d"; // Trello Orange/Gold
  return null;
}

const RightPanel = React.memo(function RightPanel() {
  //  HYDRATE FROM CACHE: Gives notifications permanent memory across page refreshes!
  const knownTrelloCardsRef = useRef(null);
  const immuneCardsRef = useRef(new Map()); //  NEW: Memory shield to stop echoes
  useEffect(() => {
    if (!knownTrelloCardsRef.current) {
        try {
            const cache = JSON.parse(localStorage.getItem("TRELLO_CACHE") || "[]");
            if (cache.length > 0) {
                const map = new Map();
                cache.forEach(list => list.cards.forEach(c => map.set(c.id, list.title)));
                knownTrelloCardsRef.current = map;
            }
        } catch(e) {}
    }
  }, []);

 const [preview, setPreview] = React.useState(null);
 const [showArchiveModal, setShowArchiveModal] = useState(false);
 const [archivedCards, setArchivedCards] = useState([]);
 const [archivedLoading, setArchivedLoading] = useState(false);
 const [archiveSearch, setArchiveSearch] = useState(""); //  NEW: Archive Search

//  NEW: Inline Card Creation State
  const [addingToList, setAddingToList] = useState(null);
  const [newCardTitle, setNewCardTitle] = useState("");

  const handleCreateCard = async (listId) => {
      if (!newCardTitle.trim()) return;
      
      const titleToCreate = newCardTitle.trim();
      const tempId = "temp-" + Date.now(); // Temporary ID for instant UI rendering

      // 1. Reset input UI immediately
      setAddingToList(null);
      setNewCardTitle("");

      // 2. Optimistic Update: Draw the card instantly on screen
      setTrelloBuckets(prev => prev.map(b => {
          if (b.id === listId) {
              return {
                  ...b,
                  cards: [...b.cards, {
                      id: tempId,
                      title: titleToCreate,
                      labels: [],
                      badges: [],
                      people: [],
                      customFields: {},
                      listId: listId,
                      list: b.title
                  }]
              };
          }
          return b;
      }));

      // 3. Send to Trello Backend
      try {
          const res = await fetch("/.netlify/functions/trello-add-card", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name: titleToCreate, idList: listId })
          });
          const json = await res.json();
          
          if (json.ok && json.card) {
              // Swap the temporary ID for the real Trello ID once the server replies
              setTrelloBuckets(prev => prev.map(b => {
                  if (b.id === listId) {
                      return {
                          ...b,
                          cards: b.cards.map(c => c.id === tempId ? { ...c, id: json.card.id } : c)
                      };
                  }
                  return b;
              }));
          }
      } catch (err) {
          console.error("Failed to create card:", err);
      }
  };

  //  NEW: Track Pinned Lists
  const [pinnedLists, setPinnedLists] = useState(() => {
    try { return JSON.parse(localStorage.getItem("PINNED_LISTS") || "[]"); }
    catch { return []; }
  });

  const togglePin = (listId, e) => {
      e.stopPropagation(); // Prevents dragging the list when clicking the pin
      setPinnedLists(prev => {
          let next;
          if (prev.includes(listId)) {
              next = prev.filter(id => id !== listId); // unpin
          } else {
              next = [...prev, listId]; // pin (adds to bottom of pinned group)
          }
          localStorage.setItem("PINNED_LISTS", JSON.stringify(next));
          
          // Instantly re-sort the UI without waiting for the background poller
          setTrelloBuckets(oldBuckets => {
              const newBuckets = [...oldBuckets].sort((a, b) => {
                  const aPin = next.indexOf(a.id);
                  const bPin = next.indexOf(b.id);
                  if (aPin !== -1 && bPin !== -1) return aPin - bPin;
                  if (aPin !== -1) return -1;
                  if (bPin !== -1) return 1;
                  
                  let idxA = listOrderRef.current.indexOf(a.title);
                  let idxB = listOrderRef.current.indexOf(b.title);
                  return (idxA !== -1 ? idxA : 999) - (idxB !== -1 ? idxB : 999);
              });
              // Update master ref so dragging doesn't break
              listOrderRef.current = newBuckets.map(b => b.title);
              return newBuckets;
          });
          return next;
      });
  };

 const openArchiveBin = async () => {
    setShowArchiveModal(true);
    setArchivedLoading(true);
    try {
      //  SYNCED: This specifically matches your filename "trello-archived"
      const res = await fetch("/.netlify/functions/trello-archived");
      const json = await res.json();
      if (json.cards) {
        //  DATA MAPPER: Formats raw Trello data to match your UI perfectly
        const mapped = json.cards.map(c => {
           const labelNames = (c.labels || []).map(l => l.name).filter(Boolean);
           
           // Extract the translated custom fields from the new backend
           let badgeArr = labelNames.map(l => ({ text: l, isBottom: false }));
           if (c.parsedCustomFields) {
               if (c.parsedCustomFields.Priority) badgeArr.push({ text: `Priority: ${c.parsedCustomFields.Priority}`, isBottom: true });
               if (c.parsedCustomFields.Status) badgeArr.push({ text: `Status: ${c.parsedCustomFields.Status}`, isBottom: true });
               if (c.parsedCustomFields.Active) badgeArr.push({ text: `Active: ${c.parsedCustomFields.Active}`, isBottom: true });
           }

           return {
              id: c.id,
              title: c.name,
              due: c.due || "",
              labels: labelNames,
              badges: ensureBadgeTypes(badgeArr),
              people: c.idMembers || [],
              listId: c.idList,
              list: "Archived",
              customFields: c.parsedCustomFields || {},
              description: c.desc || "",
              cover: c.cover || null,
              isArchived: true
           };
        });
        setArchivedCards(mapped);
      }
    } catch(err) { console.error("Failed to load archive", err); }
    setArchivedLoading(false);
  };


  //  SWR CACHE: Load instantly from memory so the screen is never empty
  const [trelloBuckets, setTrelloBuckets] = useState(() => {
    try {
      const cached = localStorage.getItem("TRELLO_CACHE");
      return cached ? JSON.parse(cached) : [];
    } catch(e) { return []; }
  });
  const [clientFiles, setClientFiles] = useState([]);

  //  INSTANT REACTION: Listens to the main app and updates Right Pane in 0ms
  useEffect(() => {
    const handler = (e) => setTrelloBuckets(e.detail);
    window.addEventListener("optimisticRightPane", handler);
    return () => window.removeEventListener("optimisticRightPane", handler);
  }, []);

 // --- DRAG AND DROP STATE ---
  
  
  useEffect(() => {
    const handleMemoryUpdate = (e) => {
      if (knownTrelloCardsRef.current) {
        knownTrelloCardsRef.current.set(e.detail.cardId, e.detail.listName);
      }
      //  Grant 60-second immunity from fake duplicate notifications
      if (immuneCardsRef.current) immuneCardsRef.current.set(e.detail.cardId, Date.now()); 
    };
    window.addEventListener("updateTrelloMemory", handleMemoryUpdate);
    return () => window.removeEventListener("updateTrelloMemory", handleMemoryUpdate);
  }, []);

  const [dragging, setDragging] = useState(false);
  const dragItem = useRef(); // Tracks { grpI, itemI } (Group Index, Item Index)
  const dragNode = useRef(); // Tracks the actual HTML element
  const lastMoveTime = useRef(0); //  ADD THIS
  const hasSnapshotRef = useRef(false);

  //  ADD THIS: Initialize with your default order
  const listOrderRef = useRef(
    PERSONA.toUpperCase() === "SIYA"
      ? ["Siya - Review", "Siya", "Bonisa", "Songeziwe", "Enock"]
      : ["Yolandie to Data Capture", "Yolandie to Analyst", "Yolandie to Data Analyst", "Yolandie to Reviewer", "Yolandie to Send"]
  );

  // --- LIST REORDERING LOGIC ---

  const handleListDragStart = (e, index) => {
    e.stopPropagation(); // Don't trigger card drags
    dragItem.current = { listIdx: index };
    dragNode.current = e.currentTarget;
    e.dataTransfer.effectAllowed = 'move';

    if (e.currentTarget.parentElement) {
        e.dataTransfer.setDragImage(e.currentTarget.parentElement, 20, 20);
    }

    setDragging(true);
  };

  const handleListDragEnter = (e, index) => {
    if (!dragItem.current || dragItem.current.listIdx === undefined) return;
    if (dragItem.current.listIdx === index) return;

    //  Capture the exact from-index BEFORE the state update
    const fromIdx = dragItem.current.listIdx;
    
    // Move the ref instantly so rapidly firing events don't trip over each other
    dragItem.current.listIdx = index; 

    setTrelloBuckets(prev => {
      const newList = [...prev];
      
      //  CRITICAL SAFETY GUARD: Stop if the queue gets out of sync
      if (fromIdx < 0 || fromIdx >= newList.length || !newList[fromIdx]) {
          return prev; 
      }

      const item = newList.splice(fromIdx, 1)[0];
      newList.splice(index, 0, item);
      
      //  Clean out any potential ghost undefined items before reading titles
      const safeList = newList.filter(Boolean);
      listOrderRef.current = safeList.map(b => b.title);
      
      // Safely sync pins in the background
      setTimeout(() => {
          setPinnedLists(oldPins => {
              const newPins = safeList.map(b => b.id).filter(id => oldPins.includes(id));
              localStorage.setItem("PINNED_LISTS", JSON.stringify(newPins));
              return newPins;
          });
      }, 0);

      return safeList;
    });
  };

  // 1. Start Dragging (Overlay Strategy)
  const handleDragStart = (e, params) => {
    dragItem.current = params;
    dragNode.current = e.currentTarget;

    const rect = dragNode.current.getBoundingClientRect();
    const ghost = dragNode.current.cloneNode(true);
    
    Object.assign(ghost.style, {
        position: "fixed", top: `${rect.top}px`, left: `${rect.left}px`,
        width: `${rect.width}px`, height: `${rect.height}px`,
        zIndex: "9999", pointerEvents: "none", transition: "none",
        transform: "rotate(5deg)", opacity: "1", background: "#fff",
        boxShadow: "0 15px 30px rgba(0,0,0,0.3)" 
    });

    document.body.appendChild(ghost);
    void ghost.offsetWidth; // Force Reflow
    e.dataTransfer.setDragImage(ghost, 20, 20);

    setTimeout(() => {
        if (document.body.contains(ghost)) document.body.removeChild(ghost);
        setDragging(true); 
    }, 0);
  };

  const handleColumnDragEnter = (grpI) => {
    if (dragItem.current?.listIdx !== undefined) return;
    if (!dragItem.current || dragItem.current.grpI === undefined || dragItem.current.grpI === grpI) return;

    const dragGrpIdx = dragItem.current.grpI;
    const dragItemIdx = dragItem.current.itemI;

    setTrelloBuckets((oldBuckets) => {
      let newBuckets = JSON.parse(JSON.stringify(oldBuckets));

      //  SAFETY GUARDS
      if (!newBuckets[dragGrpIdx] || !newBuckets[dragGrpIdx].cards) return oldBuckets;
      const cardToMove = newBuckets[dragGrpIdx].cards[dragItemIdx];
      if (!cardToMove) return oldBuckets;

      newBuckets[dragGrpIdx].cards.splice(dragItemIdx, 1);
      
      if (!newBuckets[grpI]) return oldBuckets;
      if (!newBuckets[grpI].cards) newBuckets[grpI].cards = [];
      
      newBuckets[grpI].cards.push(cardToMove);
      dragItem.current = { grpI, itemI: newBuckets[grpI].cards.length - 1 };

      return newBuckets;
    });
  };

  // 2. Drag Enter (The "Make Space" Logic)
  const handleDragEnter = (e, params) => {
    if (
        !dragItem.current || 
        (dragItem.current.grpI === params.grpI && dragItem.current.itemI === params.itemI)
    ) return;

    const dragGrpIdx = dragItem.current.grpI;
    const dragItemIdx = dragItem.current.itemI;
    
    // Update instantly to prevent race conditions
    dragItem.current = params;

    setTrelloBuckets(oldBuckets => {
        let newBuckets = JSON.parse(JSON.stringify(oldBuckets));
        
        //  SAFETY GUARDS
        if (!newBuckets[dragGrpIdx] || !newBuckets[dragGrpIdx].cards) return oldBuckets;
        const cardToMove = newBuckets[dragGrpIdx].cards[dragItemIdx];
        if (!cardToMove) return oldBuckets;

        newBuckets[dragGrpIdx].cards.splice(dragItemIdx, 1);
        
        const targetGrpIdx = params.grpI;
        const targetItemIdx = params.itemI;
        
        if (!newBuckets[targetGrpIdx]) return oldBuckets;
        if (!newBuckets[targetGrpIdx].cards) newBuckets[targetGrpIdx].cards = [];
        
        newBuckets[targetGrpIdx].cards.splice(targetItemIdx, 0, cardToMove);
        
        return newBuckets;
    });
  };

  // 3. End Dragging (Safe Version)
  const handleDragEnd = async () => {
    if (!dragItem.current) return;

    setDragging(false);
    
    if (dragNode.current) {
        dragNode.current.style.transform = "";
        dragNode.current.style.opacity = "";
    }

    lastMoveTime.current = Date.now(); 

    const { grpI, itemI } = dragItem.current;
    
    //  Instantly clear refs to prevent post-drop ghost triggers
    dragItem.current = null;
    dragNode.current = null;

    // If it was a list drag, grpI will be undefined, so we stop here securely
    if (grpI === undefined || itemI === undefined) return;

    const destList = trelloBuckets[grpI];
    if (!destList || !destList.cards) return;
    
    const card = destList.cards[itemI];
    if (!card) return;
    
    console.log(`Moving card to List: ${destList.title}, Index: ${itemI}`);
    
    const oldListTitle = knownTrelloCardsRef.current ? knownTrelloCardsRef.current.get(card.id) : null;
    if (oldListTitle && oldListTitle !== destList.title) {
        window.dispatchEvent(new CustomEvent("notify", {
            detail: {
                text: `Card moved to ${destList.title}: ${card.title}`,
                alt: "Trello",
                icon: trelloIcon,
                cardData: card,
                timestamp: new Date().toISOString()
            }
        }));
    }

    if (knownTrelloCardsRef.current) knownTrelloCardsRef.current.set(card.id, destList.title);
    //  NEW: Grant 60-second immunity right as the drag-and-drop finishes
    if (immuneCardsRef.current) immuneCardsRef.current.set(card.id, Date.now()); 
    
    fetch("/.netlify/functions/trello-move", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ cardId: card.id, targetListId: destList.id, newIndex: itemI }),
    }).catch(e => console.error("Move failed", e));
  };
  // 4. Style Helper
  const getStyles = (grpI, itemI) => {
      // Only show placeholder if we are ACTIVELY dragging
      if (dragging && dragItem.current?.grpI === grpI && dragItem.current?.itemI === itemI) {
          return "tl-card dnd-placeholder"; 
      }
      return "tl-card";
  };

  /* ... (Keep your existing Helpers: patchCardInBuckets, refs, useEffects) ... */
  // NOTE: For brevity, I am hiding the helper functions I didn't change (like onSetClientFiles). 
  // ensure you KEEP them in your file. 
  
  // (Paste your existing useEffects here: setClientFiles, openEmailAttachmentPreview, fetchTrello, bucketsUpdated)
  // ... [PASTE YOUR EXISTING USE EFFECTS HERE] ...

  // To save space, I will jump to the return statement where the DRAG EVENTS are attached.

  // --- BULLETPROOF TRELLO POLLING (Anti-429) ---
  const fetchGenRef = useRef(0); //  Tracks active fetches to kill glitches

  useEffect(() => {
    let isMounted = true;
    let pollTimer = null;

    // Listen for moves/archives from the Middle Panel
    const handlePause = () => { 
      lastMoveTime.current = Date.now(); 
      fetchGenRef.current += 1; //  KILLS THE GLITCH: Invalidates any currently running fetches!
    };
    window.addEventListener("pauseTrelloPolling", handlePause);

    async function fetchTrello(force = false) {
      if (!isMounted) return;

      // 1. SAFETY CHECKS (Removed the UI pause here so notifications still run fast!)
      if (document.hidden && !force) return; 

      // 2. RATE LIMITING (The "Mutex")
      const now = Date.now();
      const lastFetch = parseInt(localStorage.getItem("lastTrelloFetch") || "0");
      
      // SPEED UP: Lowered lock from 8s to 5s
      if (!force && (now - lastFetch < 5000)) return;

      // 3. LOCK & FETCH
      localStorage.setItem("lastTrelloFetch", now.toString());
      
      // Lock this specific request to a generation ID
      const myGen = fetchGenRef.current;

      try {
        const res = await fetch(`/.netlify/functions/trello?t=${now}`);
        
        // Handle 429 specifically
        if (!res.ok) {
           if (res.status === 429) console.warn("Trello Rate Limit Hit - Cooling down...");
           return;
        }

        let json = await res.json();
        if (!isMounted) return;

        // --- YOUR ORIGINAL DATA PROCESSING LOGIC ---
        let rawBuckets = Array.isArray(json?.buckets) ? json.buckets : (Array.isArray(json) ? json : []);

        // 1. DEFINE TEAM DATA
        const TEAM_DATA = [
          { id: "list-siya-review", title: "Siya - Review", cards: [] },
          { id: "list-siya", title: "Siya", cards: [] },
          { id: "list-bonisa", title: "Bonisa", cards: [] },
          { id: "list-songeziwe", title: "Songeziwe", cards: [] },
          { id: "list-enock", title: "Enock", cards: [] }
        ];

        // 2. ROBUST MERGE
        TEAM_DATA.forEach(teamList => {
          const existingIndex = rawBuckets.findIndex(b => {
             const apiTitle = (b.title || b.name || b.list || "").trim().toLowerCase();
             const myTitle  = teamList.title.trim().toLowerCase();
             return apiTitle === myTitle;
          });

          if (existingIndex === -1) {
            rawBuckets.push(teamList);
          } else {
            const existingBucket = rawBuckets[existingIndex];
            // Clean cards
            const realCards = existingBucket.cards || [];
            rawBuckets[existingIndex] = { ...existingBucket, cards: realCards };
          }
        });

        // 3. MAP FIELDS
        let mapped = rawBuckets.map((b) => {
          const title = b.title || b.name || b.list || "";
          return {
            id: b.id,
            title,
            cards: (b.cards || []).map((c) => ({
              id: c.id,
              title: c.name || c.title,
              due: c.due || "",
              badges: ensureBadgeTypes(Array.isArray(c.badges) ? c.badges : []),
              labels: c.labels || [], 
              people: c.idMembers || c.people || [],
              listId: b.id,
              list: title,
              customFields: (() => {
                 let safeCF = {};
                 for (let k in (c.customFields || {})) {
                    //  THE FIX: Catch the "[SYSTEM]" tags coming from Trello and map them to the React UI
                    if (k.includes("WorkStartTime") || k.includes("WorkTimerStart")) {
                        safeCF.WorkTimerStart = c.customFields[k];
                    } else if (k.includes("WorkDuration")) {
                        safeCF.WorkDuration = c.customFields[k];
                    } else if (k === "TimerStart") {
                        safeCF.TimerStart = c.customFields[k];
                    } else if (k === "Duration") {
                        safeCF.Duration = c.customFields[k];
                    } else {
                        safeCF[k] = c.customFields[k];
                    }
                 }
                 return safeCF;
              })(),
              description: c.desc || c.description || "",
              cover: c.cover || null
            })),
          };
        });

        // 4. PERSONA FILTER
        let persona = (import.meta.env.VITE_PERSONA || "").toLowerCase().trim();
        if (!persona || persona === "unknown") persona = "siya"; 

        const PERSONA_TITLES = persona === "siya"
            ? ["Siya - Review", "Siya", "Bonisa", "Songeziwe", "Enock"]
            : ["Yolandie to Data Capture", "Yolandie to Analyst", "Yolandie to Data Analyst", "Yolandie to Reviewer", "Yolandie to Send"];

        // Broadcast ALL lists (unfiltered) so the Move dropdown has every option
        const allListsRaw = mapped.map(b => ({ id: b.id, title: b.title, cardsLength: b.cards.length }));
        window.dispatchEvent(new CustomEvent("updateAllLists", { detail: allListsRaw }));

        let filtered = mapped.filter((b) => PERSONA_TITLES.includes(b.title));
        
        // 5. SORT LOGIC
    filtered.sort((a, b) => {
          // Check pins first
          const pins = JSON.parse(localStorage.getItem("PINNED_LISTS") || "[]");
          const aPin = pins.indexOf(a.id);
          const bPin = pins.indexOf(b.id);
          
          if (aPin !== -1 && bPin !== -1) return aPin - bPin;
          if (aPin !== -1) return -1;
          if (bPin !== -1) return 1;

          // Fallback to manual drag order
     let idxA = listOrderRef.current.indexOf(a.title);
     let idxB = listOrderRef.current.indexOf(b.title);
     if (idxA === -1) idxA = 999;
     if (idxB === -1) idxB = 999;
     return idxA - idxB;
    });
        
        if (filtered.length > 0) mapped = filtered;

        //  THE GLITCH FIX MOVED UP: Block stale data BEFORE it triggers false notifications!
        if (myGen !== fetchGenRef.current) return;
        if (dragging && !force) return;
        if (Date.now() - lastMoveTime.current < 10000 && !force) return;

        // --- NOTIFICATION LOGIC ---
        // 1. If we have NO memory yet, we are just booting up. Memorize silently.
        if (!hasSnapshotRef.current && (!knownTrelloCardsRef.current || knownTrelloCardsRef.current.size === 0)) {
            const map = new Map();
            mapped.forEach(list => list.cards.forEach(c => map.set(c.id, list.title)));
            knownTrelloCardsRef.current = map;
            hasSnapshotRef.current = true; 
            console.log(" [Notifications] First boot. Memorized board silently.");
        } 
        // 2. If we DO have memory, it means we are actively polling. Compare and Notify.
        else {
            hasSnapshotRef.current = true; // Ensure shield is permanently off
            const newMap = new Map();
            
            mapped.forEach(list => {
                list.cards.forEach(c => {
                    newMap.set(c.id, list.title);
                    
                    // Look up where the card was 6 seconds ago
                    const oldListTitle = knownTrelloCardsRef.current ? knownTrelloCardsRef.current.get(c.id) : null;

                    //  THE SIYA FILTER: Enforce the exact rules
                    const targetListTitle = list.title.toLowerCase();
                    const isSiyaList = targetListTitle.includes("siya");
                    const hasSiyaMember = (c.people || []).some(m => String(m).toLowerCase().includes("siya"));
                    
                    // If it lands in a Siya list OR Siya is assigned to it
                    if (isSiyaList || hasSiyaMember) {
                        
                        // Scenario A: Brand new card
                        if (!oldListTitle && knownTrelloCardsRef.current) {
                            console.log(` [Trello Notify] New Card Detected: "${c.title}" in ${list.title}`);
                            window.dispatchEvent(new CustomEvent("notify", {
                                detail: {
                                    text: `New card in ${list.title}: ${c.title}`,
                                    alt: "Trello",
                                    icon: trelloIcon,
                                    cardData: c,
                                    timestamp: new Date().toISOString()
                                }
                            }));
                        } 
                        // Scenario B: Card moved from a different list into this one
                        else if (oldListTitle && oldListTitle !== list.title) {
                            //  ECHO SHIELD: Block false notifications if we just moved this card
                            const immunityTime = immuneCardsRef.current?.get(c.id) || 0;
                            if (Date.now() - immunityTime < 60000) return;

                            console.log(` [Trello Notify] Move Detected! "${c.title}" moved from [${oldListTitle}] to [${list.title}]`);
                            window.dispatchEvent(new CustomEvent("notify", {
                                detail: {
                                    text: `Card moved to ${list.title}: ${c.title}`,
                                    alt: "Trello",
                                    icon: trelloIcon,
                                    cardData: c,
                                    timestamp: new Date().toISOString()
                                }
                            }));
                        }
                    }
                });
            });
            // Overwrite the memory map with the new positions for the next 6-second check
            knownTrelloCardsRef.current = newMap;
        }
        // --- END USER LOGIC ---

        // Only update if data changed (Simple check)
        setTrelloBuckets(prev => {
            if (JSON.stringify(prev) === JSON.stringify(mapped)) return prev;
            
            // Broadcast the fresh data to the main App for the Middle Pane to use!
            window.dispatchEvent(new CustomEvent("trelloPolled", { detail: mapped }));
            
            //  CACHE SAVE: Memorize the latest lists for the next time you open the app
            localStorage.setItem("TRELLO_CACHE", JSON.stringify(mapped));
            
            return mapped;
        });

      } catch (err) {
        console.error("Trello Poll Error:", err);
      }
    }

    // Initial Fetch (Bypass the cooldown block on first load)
    fetchTrello(true);

    // SPEED UP: Poll every 6 seconds to make notifications snappy
    pollTimer = setInterval(() => fetchTrello(), 6000);

    return () => {
        isMounted = false; 
        clearInterval(pollTimer);
        window.removeEventListener("pauseTrelloPolling", handlePause);
    };
  }, [dragging]); // fetchGenRef and lastMoveTime are refs, safe to omit

  // ... (keep allow patch buckets logic) ...
  // --- LISTEN FOR INSTANT UPDATES (Fixes Right Pane Delay) ---
  useEffect(() => {
    function handlePatch(e) {
      const { cardId, updater } = e.detail;
      setTrelloBuckets(prevBuckets => {
        // Deep clone to avoid mutation reference issues
        const newBuckets = prevBuckets.map(b => ({
          ...b,
          cards: b.cards.map(c => {
            if (c.id !== cardId) return c;
            
            // Apply the update (e.g., change Priority)
            const updatedCard = updater(c);
            
            // Re-calculate badges for the Right Panel view immediately
            const newBadges = [];
            
            // 1. Priority
            if (updatedCard.customFields?.Priority) {
               newBadges.push({ text: `Priority: ${updatedCard.customFields.Priority}`, isBottom: true });
            }
            // 2. Status
            if (updatedCard.customFields?.Status) {
               newBadges.push({ text: `Status: ${updatedCard.customFields.Status}`, isBottom: true });
            }
            // 3. Active
            if (updatedCard.customFields?.Active) {
               newBadges.push({ text: `Active: ${updatedCard.customFields.Active}`, isBottom: true });
            }
            
            // Preserve labels
            updatedCard.labels.forEach(l => newBadges.push({ text: l, isBottom: false }));
            
            updatedCard.badges = ensureBadgeTypes(newBadges);
            return updatedCard;
          })
        }));
        return newBuckets;
      });
    }

    window.addEventListener("patchCardInBuckets", handlePatch);
    return () => window.removeEventListener("patchCardInBuckets", handlePatch);
  }, []);

  // Map clientFiles -> UI files (unchanged)
  const files = (clientFiles || []).map((f, i) => {
    let type = f.type || "other";
    if (!f.type && f.mimeType) {
      if (f.mimeType === "application/pdf") type = "pdf";
      else if (f.mimeType.startsWith("image/")) type = "img";
      else if (f.mimeType === "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" || f.mimeType === "application/vnd.ms-excel") type = "xls";
    }
    const url = f.url || (f.id ? `/.netlify/functions/drive-download?id=${encodeURIComponent(f.id)}` : "#");
    const thumbUrl = f.thumbUrl || url;
    return { id: f.id || `att-${i}`, name: f.name || `Attachment ${i + 1}`, type, url, thumbUrl };
  });

  const isImage = (t) => t === "img";
  const isPdf = (t) => t === "pdf";
  const isExcel = (t) => t === "xls";

  return (
    <div className="right-panel">
      <div className="panel-title" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', paddingRight: '8px' }}>
        <span>Trello Cards</span>
        <button 
          onClick={openArchiveBin} 
          style={{ background: 'transparent', border: 'none', color: '#9fadbc', cursor: 'pointer', fontSize: '12px', display: 'flex', alignItems: 'center', gap: '4px', fontWeight: 500, transition: 'color 0.2s' }}
          onMouseEnter={e => e.currentTarget.style.color = '#8993a4'} //  LIGHT GRAY HOVER
          onMouseLeave={e => e.currentTarget.style.color = '#9fadbc'}
        >
          <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM6.24 5h11.52l.83 1H5.41l.83-1zM5 19V8h14v11H5zm11-5.5l-4 4-4-4 1.41-1.41L11 13.67V10h2v3.67l1.59-1.58L16 13.5z"/></svg>
          Archive Bin
        </button>
      </div>

      {/* ARCHIVE MODAL OVERLAY */}
      {showArchiveModal && (
        <div style={{ position: 'fixed', top:0, left:0, width:'100vw', height:'100vh', background:'rgba(0,0,0,0.6)', zIndex: 9999, display:'grid', placeItems:'center' }} onClick={() => setShowArchiveModal(false)}>
          <div style={{ background: '#f4f5f7', width: '400px', maxHeight: '80vh', borderRadius: '3px', display: 'flex', flexDirection: 'column', boxShadow: '0 8px 16px rgba(0,0,0,0.4)' }} onClick={e => e.stopPropagation()}>
             
             {/* HEADER */}
             <div style={{ padding: '16px 16px 8px 16px', display: 'flex', justifyContent: 'space-between', color: '#172b4d', fontWeight: 600 }}>
                <span>Archived items</span>
                <button onClick={() => setShowArchiveModal(false)} style={{ background:'none', border:'none', color:'#42526e', cursor:'pointer', fontSize:'16px' }}></button>
             </div>
             
             {/*  ARCHIVE SEARCH BAR */}
             <div style={{ padding: '0 16px 12px 16px', borderBottom: '1px solid rgba(9,30,66,0.13)' }}>
                <input 
                  type="text" 
                  placeholder="Search archives..." 
                  value={archiveSearch}
                  onChange={(e) => setArchiveSearch(e.target.value)}
                  style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', outline: 'none', fontSize: '13px', color: '#172b4d' }}
                />
             </div>

             <div style={{ padding: '16px', overflowY: 'auto', flex: 1, display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {archivedLoading ? <div style={{ color: '#5e6c84', textAlign:'center', padding: '20px' }}>Loading archive...</div> :
                  archivedCards.filter(c => c.title.toLowerCase().includes(archiveSearch.toLowerCase())).length === 0 ? <div style={{ color: '#5e6c84', textAlign:'center', padding: '20px' }}>No archived cards found.</div> :
                  archivedCards.filter(c => c.title.toLowerCase().includes(archiveSearch.toLowerCase())).map(c => (
                    <div 
                      key={c.id} 
                      style={{ background: '#ffffff', borderRadius: '3px', padding: '12px', marginBottom: '8px', cursor: 'pointer', position: 'relative', boxShadow: '0 1px 1px rgba(9,30,66,0.25)', display: 'flex', flexDirection: 'column', gap: '8px', border: '1px solid transparent' }}
                      onMouseEnter={e => e.currentTarget.style.borderColor = '#0079bf'}
                      onMouseLeave={e => e.currentTarget.style.borderColor = 'transparent'}
                      onClick={() => {
                        window.dispatchEvent(new CustomEvent("openTrelloCard", { detail: c }));
                        setShowArchiveModal(false);
                      }}
                    >
                       <div style={{ color: '#172b4d', fontWeight: 500, fontSize: '14px', paddingRight: '30px', lineHeight: '1.4' }}>
                          {c.title}
                       </div>
                       
                       <div style={{ display: 'flex', gap: '6px', flexWrap: 'wrap', alignItems: 'center' }}>
                          <span style={{ background: '#ebecf0', padding: '4px 8px', borderRadius: '3px', fontSize: '12px', color: '#42526e', display: 'flex', alignItems: 'center', gap: '6px', fontWeight: 500 }}>
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM6.24 5h11.52l.83 1H5.41l.83-1zM5 19V8h14v11H5zm11-5.5l-4 4-4-4 1.41-1.41L11 13.67V10h2v3.67l1.59-1.58L16 13.5z"/></svg>
                            Archived
                          </span>
                          
                          {(c.badges || []).map((b, k) => (
                            <span key={k} className={`tl-badge ${b.type || "label-default"}`} style={{ padding: '4px 8px', fontSize: '12px' }}>
                              {b.text}
                            </span>
                          ))}
                       </div>

                       <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: '4px' }}>
                          <div className="tl-people" style={{ margin: 0 }}>
                            {c.people?.map((p, idx) => {
                              const img = avatarFor(p);
                              return img ? <img key={idx} className="av-img" src={img} alt={p} style={{ width: 24, height: 24 }} /> : <div key={idx} className="av" style={{ width: 24, height: 24 }}>{p.slice(0,1)}</div>;
                            })}
                          </div>
                       </div>

                       <button
                         title="Recover"
                         onClick={async (e) => {
                            e.stopPropagation();
                            window.dispatchEvent(new Event("pauseTrelloPolling"));
                            setArchivedCards(prev => prev.filter(x => x.id !== c.id));
                            fetch("/.netlify/functions/trello-restore", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ cardId: c.id }) });
                         }}
                         style={{ position: 'absolute', top: '12px', right: '12px', background: 'transparent', border: 'none', color: '#6b778c', cursor: 'pointer', padding: '4px', display: 'grid', placeItems: 'center', transition: 'color 0.2s' }}
                         onMouseEnter={e => e.currentTarget.style.color = '#172b4d'}
                         onMouseLeave={e => e.currentTarget.style.color = '#6b778c'}
                       >
                          <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg>
                       </button>
                    </div>
                  ))
                }
             </div>
          </div>
        </div>
      )}
      <div className="right-scroll left-scroll">
        <div className="trello-col-wrap">
          {trelloBuckets.map((bucket, i) => (
            <div 
                className="tl-col" 
                key={bucket.id || i}
                // 1. Mandatory for dropping
                onDragOver={(e) => e.preventDefault()} 
                // 2. INTELLIGENT ROUTING: List Swap vs Card Move
                onDragEnter={(e) => {
                    e.preventDefault();
                    if (dragging) {
                        // If dragging a LIST -> Reorder Lists
                        if (dragItem.current?.listIdx !== undefined) handleListDragEnter(e, i);
                        // If dragging a CARD -> Move Card to this List
                        else handleColumnDragEnter(i);
                    }
                }}
                // 3. Drop Handler
                onDrop={(e) => {
                    e.preventDefault();
                    // Save Card Move
                    if (dragItem.current?.grpI !== undefined) handleDragEnd();
                    // Finish List Move
                    if (dragItem.current?.listIdx !== undefined) setDragging(false);
                }}
            >
              {/* HEADER (Draggable) */}
              <div 
                className="tl-head"
                draggable
                onDragStart={(e) => handleListDragStart(e, i)}
                onDragEnd={() => {
                    setDragging(false);
                    dragItem.current = null;
                    dragNode.current = null;
                }}
                style={{ cursor: "grab", display: 'flex', justifyContent: 'space-between', alignItems: 'center' }} 
              >
                <span className="tl-title">{bucket.title}</span>
                <span 
                    className="tl-actions" 
                    onClick={(e) => togglePin(bucket.id, e)}
                    style={{ 
                        cursor: "pointer", 
                        opacity: pinnedLists.includes(bucket.id) ? 1 : 0.4, 
                        color: pinnedLists.includes(bucket.id) ? '#0052cc' : '#42526e', 
                        display: 'flex', 
                        alignItems: 'center', 
                        padding: '4px',
                        transition: 'all 0.2s ease'
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.opacity = 1}
                    onMouseLeave={(e) => e.currentTarget.style.opacity = pinnedLists.includes(bucket.id) ? 1 : 0.4}
                    title={pinnedLists.includes(bucket.id) ? "Unpin List" : "Pin List"}
                >
                    <svg width="16" height="16" viewBox="0 0 24 24" fill={pinnedLists.includes(bucket.id) ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <line x1="12" y1="17" x2="12" y2="22"></line>
                        <path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 11.2V6a3 3 0 0 0-6 0v5.2a2 2 0 0 1-1.11 1.35l-1.78.9A2 2 0 0 0 5 15.24Z"></path>
                    </svg>
                </span>
              </div>
              
              {/* CARDS */}
              <div className="tl-cards">
                {bucket.cards.map((card, j) => (
                  <div
                    key={card.id || j}
                    draggable
                    onDragStart={(e) => handleDragStart(e, { grpI: i, itemI: j })}
                    onDragEnter={dragging ? (e) => handleDragEnter(e, { grpI: i, itemI: j }) : null}
                    onDragOver={(e) => e.preventDefault()}
                    onDragEnd={handleDragEnd}
                    className={getStyles(i, j)}
                    onClick={() => window.dispatchEvent(new CustomEvent("openTrelloCard", { detail: card }))}
                  >
                     {/* ... (Your Card Content - Colors, Badges, Title, Footer) ... */}
                     {/* Copy your existing card inner content here if needed, or leave it as is */}
                     
                     {/* RE-INSERTING YOUR CARD CONTENT FOR CLARITY: */}
                     {(() => {
                      const coverColor = card.cover?.color;
                      const titleColor = getTrelloCoverColor(card.title);
                      const colorMap = { sky: "#6CC3E0", orange: "#FAA53D", blue: "#579DFF", green: "#4BCE97", yellow: "#F5CD47", red: "#F87168", purple: "#9F8FEF" };
                      const finalColor = titleColor || colorMap[coverColor];
                      if (finalColor) return ( <div className="tl-card-cover" style={{ backgroundColor: finalColor }} /> );
                      return null;
                    })()}

                    {(() => {
                      const labelBadges = (card.labels || []).map(l => ({ text: l, type: getLabelColor(l), isTop: true }));
                      const labelTexts = new Set(labelBadges.map(b => (b.text || "").toLowerCase().trim()));
                      const uniqueCardBadges = (card.badges || []).filter(b => !labelTexts.has((b.text || "").toLowerCase().trim()));
                      const allBadges = [...labelBadges, ...uniqueCardBadges];
                      const topBadges = allBadges.filter(b => b.isTop);
                      const bottomBadges = allBadges.filter(b => b.isBottom);
                      
                      return (
                        <>
                          {topBadges.length > 0 && <div className="tl-badges">{topBadges.map((b, k) => <span key={k} className={`tl-badge ${b.type || "label-default"}`}>{b.text}</span>)}</div>}
                          <div className="tl-card-title">{card.title}</div>
                          {bottomBadges.length > 0 && <div className="tl-badges" style={{marginTop:"6px", flexDirection:"column", alignItems:"flex-start", gap:"4px"}}>{bottomBadges.map((b, k) => <span key={k} className={`tl-badge ${b.type || "label-default"}`}>{b.text}</span>)}</div>}
                        </>
                      );
                    })()}

                    {(card.description || card.due || (card.people && card.people.length > 0)) && (
                        <div className="tl-footer">
                          <div className="tl-icons">
                            {card.description && <span></span>} 
                            {card.due && <span></span>}
                          </div>
                          <div className="tl-people">
                            {card.people?.map((p, idx) => {
                              const img = avatarFor(p);
                              return img ? <img key={idx} className="av-img" src={img} alt={p} /> : <div key={idx} className="av">{p.slice(0,1)}</div>;
                            })}
                          </div>
                        </div>
                    )}
                  </div>
                ))}
              </div>

              {/*  DYNAMIC ADD CARD INPUT */}
              {addingToList === bucket.id ? (
                <div style={{ padding: '8px', background: '#fff', borderRadius: '8px', boxShadow: '0 1px 2px rgba(0,0,0,0.1)', marginTop: '8px' }}>
                  <textarea
                    autoFocus
                    placeholder="Enter a title for this card..."
                    value={newCardTitle}
                    onChange={(e) => setNewCardTitle(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleCreateCard(bucket.id);
                      }
                      if (e.key === 'Escape') {
                        setAddingToList(null);
                        setNewCardTitle("");
                      }
                    }}
                    style={{ width: '100%', border: 'none', resize: 'none', outline: 'none', fontSize: '14px', fontFamily: 'inherit', color: '#172b4d', minHeight: '54px' }}
                  />
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '4px' }}>
                    <button 
                      onClick={() => handleCreateCard(bucket.id)} 
                      style={{ padding: '6px 12px', borderRadius: '3px', border: 'none', background: '#0b57d0', color: 'white', fontWeight: 500, cursor: 'pointer', fontSize: '13px' }}
                    >
                      Add card
                    </button>
                    <button 
                      onClick={() => { setAddingToList(null); setNewCardTitle(""); }} 
                      style={{ background: 'transparent', border: 'none', cursor: 'pointer', color: '#42526e', fontSize: '20px', display: 'grid', placeItems: 'center', width: '32px', height: '32px', borderRadius: '3px' }} 
                      onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} 
                      onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                    >
                      
                    </button>
                  </div>
                </div>
              ) : (
                <button 
                  className="tl-add" 
                  onClick={() => {
                    setAddingToList(bucket.id);
                    setNewCardTitle("");
                  }}
                >
                  <span>+</span> Add a card
                </button>
              )}
            </div>
          ))}
        </div>

        <div className="panel-title" style={{ marginTop: "0.75rem" }}>Client Files</div>
        <div className="doc-grid">
           {files.map((f) => (
            <button key={f.id} className={`doc-card ${f.type}`} onClick={() => window.dispatchEvent(new CustomEvent("openEmailAttachmentPreview", { detail: { file: f } }))} title={f.name}>
              <div className="doc-preview">
                {isImage(f.type) ? <img src={f.thumbUrl || f.url} alt={f.name} /> : isPdf(f.type) ? <iframe title={f.name} src={f.url} className="pdf-frame" /> : isExcel(f.type) ? <div className="doc-icon">XLS</div> : <div className="doc-icon">FILE</div>}
              </div>
              <div className="doc-info">
                <span className={`doc-badge ${f.type}`}>{f.type === "xls" ? "XLSX" : f.type.toUpperCase()}</span>
                <span className="doc-name">{f.name}</span>
              </div>
              <span className="doc-corner" />
            </button>
          ))}
        </div>
      </div>
    </div>
  );
});

//  NEW: Text Formatter for GChat (Bolding + Links + Newlines)
function formatChatText(text) {
  if (!text) return "";
  
  // 1. Split by newlines, URLs, and *bold* markers
  // Regex captures: (\n) OR (http...) OR (*bold*)
  const parts = text.split(/(\n|https?:\/\/[^\s]+|\*[^*]+\*)/g);

  return parts.map((part, i) => {
    // A. Handle Newlines
    if (part === "\n") return <br key={i} />;
    
    // B. Handle URLs
    if (part.match(/^https?:\/\//)) {
      return (
        <a 
          key={i} 
          href={part} 
          target="_blank" 
          rel="noopener noreferrer" 
          style={{ color: "#1a73e8", textDecoration: "underline", wordBreak: "break-all" }}
          onClick={(e) => e.stopPropagation()}
        >
          {part}
        </a>
      );
    }
    
    // C. Handle *Bold*
    if (part.startsWith("*") && part.endsWith("*") && part.length > 2) {
      return <strong key={i}>{part.slice(1, -1)}</strong>;
    }

    // D. Plain Text
        return part;
      });
    }

const EmailSignature = () => (
  <div style={{ padding: "0 16px 24px 16px", fontFamily: "Verdana, Arial, sans-serif", fontSize: "13px", color: "#3c4043", lineHeight: "1.6", cursor: "default" }}>
    <div style={{ marginBottom: "16px" }}>Kind regards</div>
    <div style={{ color: "#b38f6a", fontWeight: "bold", fontSize: "15px", marginBottom: "16px" }}>Siyabonga Nono</div>
    <div style={{ color: "#b38f6a", marginBottom: "16px" }}>Bsc in Math Science in Actuarial Science</div>
    
    <div style={{ marginBottom: "12px", color: "#5f6368" }}>
      <b style={{ color: "#5f6368" }}>T</b> 011 463 0313 <span style={{ display: "inline-block", width: "8px" }}></span> <b style={{ color: "#5f6368" }}>M</b> 072 689 0562
    </div>
    <div style={{ marginBottom: "12px", color: "#5f6368" }}>
      <b style={{ color: "#5f6368" }}>E</b> <a href="mailto:siyabonga@actuaryconsulting.co.za" style={{ color: "#1a73e8", textDecoration: "none" }}>siyabonga@actuaryconsulting.co.za</a> <span style={{ display: "inline-block", width: "8px" }}></span> <b style={{ color: "#5f6368" }}>W</b> <a href="http://actuaryconsulting.co.za" style={{ color: "#1a73e8", textDecoration: "none" }}>actuaryconsulting.co.za</a>
    </div>
    <div style={{ marginBottom: "20px", color: "#5f6368" }}>
      <b style={{ color: "#5f6368" }}>A</b> Corner 5th &amp; Maude Street, Sandown, Sandton, 2031
    </div>
    
    <div style={{ marginBottom: "16px" }}>
      <div style={{ fontFamily: "Georgia, 'Times New Roman', serif", fontSize: "32px", color: "#b38f6a", letterSpacing: "1px", lineHeight: "1" }}>ACTUARY</div>
      <div style={{ fontFamily: "Verdana, sans-serif", fontSize: "12px", color: "#5f6368", letterSpacing: "6.5px", marginTop: "6px", marginLeft: "2px" }}>CONSULTING</div>
    </div>
    
    <div style={{ fontSize: "10px", color: "#9aa0a6", lineHeight: "1.5", textAlign: "justify", borderTop: "1px solid #f1f3f4", paddingTop: "12px" }}>
      The information contained in this email is confidential and may be subject to legal privilege. The content of this email, which may include one or more attachments, is strictly confidential, and is intended solely for the use of the named recipient/s. If you are not the intended recipient, you cannot use, copy, distribute, disclose or retain the email or any part of its contents or take any action in reliance on it. If you have received this email in error, please email the sender by replying to this message and to permanently delete it and all attachments from your computer. All reasonable precautions have been taken to ensure that no viruses are present in this email and the company cannot accept responsibility for any loss or damage arising from the use of this email or attachments.
    </div>
 </div>
);

const EmailMetadata = ({ email }) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div style={{ position: "relative", marginTop: "2px" }}>
      <div 
        style={{ 
          fontSize: "12px", 
          color: "#5f6368", 
          display: "inline-flex", 
          alignItems: "center", 
          gap: "4px", 
          cursor: "pointer", 
          padding: "2px 4px", 
          marginLeft: "-4px", 
          borderRadius: "4px",
          position: "relative", 
          zIndex: isOpen ? 95 : "auto" 
        }}
        onClick={(e) => {
          //  STOP BUBBLING: Prevents the parent email container from refreshing or closing
          e.preventDefault();
          e.stopPropagation();
          setIsOpen(prev => !prev);
        }}
        onMouseEnter={e => e.currentTarget.style.background = "#f1f3f4"}
        onMouseLeave={e => e.currentTarget.style.background = "transparent"}
      >
        to me <span style={{ fontSize: "10px" }}>{isOpen ? "" : ""}</span>
      </div>

      {isOpen && (
        <>
          {/* Backdrop to capture clicks outside the box */}
          <div 
            style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 90 }} 
            onClick={(e) => {
              e.preventDefault();
              e.stopPropagation();
              setIsOpen(false);
            }}
          />
          
          <div 
            style={{
              position: "absolute",
              top: "100%",
              left: "0",
              marginTop: "4px",
              background: "white",
              border: "1px solid #dadce0",
              borderRadius: "8px",
              boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
              padding: "16px",
              zIndex: 100,
              minWidth: "480px",
              fontSize: "13px",
              color: "#202124",
              display: "flex",
              flexDirection: "column",
              cursor: "default"
            }}
            //  SHIELD: Ensures clicking inside the details box doesn't close the email view
            onClick={e => e.stopPropagation()} 
          >
            <div style={{ display: "grid", gridTemplateColumns: "75px 1fr", gap: "8px 12px", alignItems: "baseline" }}>
              <span style={{ color: "#5f6368", textAlign: "right" }}>from:</span>
              <span><strong>{email.fromName}</strong> {email.fromEmail}</span>
              
              <span style={{ color: "#5f6368", textAlign: "right" }}>to:</span>
              <span>{Array.isArray(email.to) ? email.to.join(", ") : email.to || "Siyabonga Nono <siya@actuaryspace.co.za>"}</span>
              
              <span style={{ color: "#5f6368", textAlign: "right" }}>date:</span>
              <span>{email.date ? new Date(email.date).toLocaleString("en-GB", { day: "numeric", month: "short", year: "numeric", hour: "2-digit", minute: "2-digit" }) : email.time}</span>
              
              <span style={{ color: "#5f6368", textAlign: "right" }}>subject:</span>
              <span>{email.subject}</span>

              <span style={{ color: "#5f6368", textAlign: "right" }}>security:</span>
              <span style={{ display: "flex", alignItems: "center", gap: "6px" }}>
                <svg width="14" height="14" viewBox="0 0 24 24"><path fill="#5f6368" d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6zm9 14H6V10h12v10zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"/></svg>
                Standard encryption (TLS)
              </span>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

// NEW: Authentic Google Calendar Icon Component
const CalendarIcon = () => {
  const today = new Date().getDate(); 
  
  return (
    <svg width="20" height="20" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" style={{ flexShrink: 0 }}>
      {/* Custom path for 3 rounded corners and 1 sharp corner (bottom-right) */}
      <clipPath id="cal-clip">
        <path d="M 20 0 H 80 A 20 20 0 0 1 100 20 V 100 H 20 A 20 20 0 0 1 0 80 V 20 A 20 20 0 0 1 20 0 Z" />
      </clipPath>
      
      <g clipPath="url(#cal-clip)">
        {/* Background White */}
        <rect x="0" y="0" width="100" height="100" fill="#ffffff" />
        
        {/* Left and Top Blue */}
        <rect x="0" y="0" width="26" height="100" fill="#4285F4" />
        <rect x="0" y="0" width="100" height="26" fill="#4285F4" />
        
        {/* Right Yellow */}
        <rect x="74" y="0" width="26" height="74" fill="#FBBC05" />
        
        {/* Bottom Green */}
        <rect x="0" y="74" width="74" height="26" fill="#34A853" />
        
        {/* Bottom Right Red Triangle (The Fold) */}
        <polygon points="74,100 100,74 100,100" fill="#EA4335" />
        
        {/* Inner White Square */}
        <rect x="26" y="26" width="48" height="48" fill="#ffffff" />
      </g>
      
      {/* Dynamic Date Text */}
      <text x="50" y="64" fontSize="38" fontWeight="bold" fontFamily="'Google Sans', Roboto, Arial, sans-serif" fill="#4285F4" textAnchor="middle">
        {today}
      </text>
    </svg>
  );
};

/* ---------- app ---------- */
export default function App() {
  const [currentView, setCurrentView] = useState({ app: "none", contact: null });
  const [isGchatSoundEnabled, setIsGchatSoundEnabled] = useState(false);

  //  SESSION START: Marks the exact millisecond the user opened the workspace
  const sessionStartTime = useRef(new Date());

  //  NEW: Fetch Live Trello Members on load and populate the cache
  useEffect(() => {
    fetch("/.netlify/functions/trello-members")
      .then(res => res.json())
      .then(data => {
        if (data.ok && data.members) {
          data.members.forEach(m => {
            if (m.avatarUrl) {
              const full = m.fullName.toLowerCase().trim();
              const first = full.split(' ')[0];
              //  FIX: Trello API returns base URLs. We must append /50.png to make them visible!
              const finalUrl = m.avatarUrl.endsWith('.png') ? m.avatarUrl : m.avatarUrl + '/50.png';
              
              LIVE_TRELLO_AVATARS[full] = finalUrl;
              LIVE_TRELLO_AVATARS[first] = finalUrl;
            }
          });
        }
      })
      .catch(err => console.error("Failed to fetch Trello members", err));
  }, []);

  const [inputValue, setInputValue] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [notifications, setNotifications] = useState([]);

//  RESTORED: The "Ear" that listens for Trello, Gmail, and Chat notifications
  useEffect(() => {
    const onNotify = (e) => {
      const { text, cardData, icon, alt, spaceId, gmailData, timestamp } = e.detail || {};
      if (!text) return;

      //  DYNAMIC TIMESTAMP
      let actualDate = new Date();
      if (gmailData && gmailData.date) {
        actualDate = new Date(gmailData.date);
      } else if (timestamp) {
        actualDate = new Date(timestamp);
      }

      //  SESSION REFRESH: Only show notifications received since opening the app
      // Using getTime() with a 5-second buffer to handle server/client clock differences
      if (actualDate.getTime() <= (sessionStartTime.current.getTime() - 5000)) return;
     //  MULTI-APP PRODUCTION-GRADE SOUND TRIGGER
try {
  let soundData = null;

  // 1. Logic picks either Gmail or Google Chat
  if (alt === "Gmail") {
    soundData = GMAIL_SOUND_DATA;
  } else if (alt === "Google Chat") {
    soundData = GCHAT_SOUND_DATA;
  } else if (alt === "Trello") {
    // You can add trello here too if you have the string ready
    soundData = TRELLO_SOUND_DATA; 
  }

  // 2. Play the sound if a match was found
  if (soundData) {
    const audio = new Audio(soundData);
    audio.volume = 0.6;
    
    const playPromise = audio.play();

    if (playPromise !== undefined) {
      playPromise.catch(error => {
        // This triggers if Siya hasn't interacted with the page yet
        console.warn(` ${alt} sound blocked. Siya, click the app once to enable audio!`);
      });
    }
  }
} catch (err) {
  console.error(" Audio playback error:", err);
}
      const uniqueId = `notif-${Date.now()}-${Math.random()}`;
      
      const newItem = {
        id: uniqueId,
        alt: alt || "System",
        icon: icon || trelloIcon,
        text: text, 
        time: formatUKTimeWithSeconds(actualDate),
        timestamp: actualDate.toISOString(),
        cardData,
        spaceId,
        gmailData
      };

      setNotifications((prev) => {
        //  STRONG DEDUPLICATION: Block identical notifications within 60 seconds
        const isDuplicate = prev.some(p => {
            // Check if the exact same text was just posted
            if (p.text === text) {
                const diff = actualDate.getTime() - new Date(p.timestamp).getTime();
                // If it happened less than 60 seconds ago, it's a glitch. Block it.
                if (diff < 60000 && diff > -60000) return true; 
            }
            return p.id === uniqueId;
        });
        
        if (isDuplicate) return prev;
        
        const nextList = [newItem, ...prev];
        //  FORCED SORT: Strict descending order (Newest First)
        return nextList.sort((a, b) => {
          return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
        }).slice(0, 100);
      });
    };

    window.addEventListener("notify", onNotify);
    return () => window.removeEventListener("notify", onNotify);
  }, []);

  //  NEW: State for the Gmail-style Snackbar pop-up and Undo tracking
  const [snackbar, setSnackbar] = useState({ show: false, text: "" });
  const [lastAction, setLastAction] = useState(null); // { type: 'delete' | 'restore', ids: [] }

  const triggerSnackbar = (text, actionInfo = null) => {
    setSnackbar({ show: true, text });
    setLastAction(actionInfo);
    setTimeout(() => {
      setSnackbar({ show: false, text: "" });
      setLastAction(null);
    }, 5000); 
  };

  const handleUndo = async () => {
    if (!lastAction) return;
    const { type, ids } = lastAction;
    setSnackbar({ show: false, text: "" });
    setGmailLoading(true);

    try {
      // If last action was DELETE, Undo = RESTORE
      // If last action was RESTORE, Undo = DELETE
      const isUndoRestore = type === "delete"; 

      await fetch("/.netlify/functions/gmail-delete-bulk", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          messageIds: ids, 
          restore: isUndoRestore, 
          permanent: false // Undo never performs permanent deletion
        })
      });

      setLastAction(null);
      setGmailEmails([]);
      setGmailRefreshTrigger(p => p + 1);
    } catch (e) {
      console.error("Undo failed", e);
    }
    setGmailLoading(false);
  };



 //  NEW state for the label picker
 const [showLabelPicker, setShowLabelPicker] = useState(false);

 const nextIdRef = useRef(0);
 const rotateIdxRef = useRef(0);
 const emailRotateRef = useRef(0);
 const chatTextareaRef = useRef(null);
 const fileInputRef = useRef(null);
 const seenGmailIdsRef = useRef(null); //  NEW: Track seen Gmail IDs to avoid spamming notifications
  const seenGchatIdsRef = useRef(null); //  NEW: Track seen GChat IDs like Gmail
  
  const [showPlusMenu, setShowPlusMenu] = useState(false);;



 /* Google Chat */
  const gchatBodyRef = useRef(null);
  const [showNewChatModal, setShowNewChatModal] = useState(false);
  const [newChatTarget, setNewChatTarget] = useState("");
  const newChatEmailRef = useRef(null);

  //  NEW: Track last active space for background polling
  const lastActiveSpaceRef = useRef(null);

  const [gchatSpaces, setGchatSpaces] = useState([]);
  const [gchatLoading, setGchatLoading] = useState(false);
  const [gchatError, setGchatError] = useState("");
  const [gchatSelectedSpace, setGchatSelectedSpace] = useState(null);

  const [gchatMessages, setGchatMessages] = useState([]);
  const [gchatNextPageToken, setGchatNextPageToken] = useState(null);
  const [gchatLoadingOlder, setGchatLoadingOlder] = useState(false); //  NEW: Tracks history fetching
  const [gchatMe, setGchatMe] = useState(null);
  const [gchatMsgLoading, setGchatMsgLoading] = useState(false);
  const [gchatMsgError, setGchatMsgError] = useState("");
const [gchatComposer, setGchatComposer] = useState("");
 const [editingMsgId, setEditingMsgId] = useState(null);
  const [editValue, setEditValue] = useState("");
  const [gchatDmNames, setGchatDmNames] = useState(() => {
    try { return JSON.parse(localStorage.getItem("GCHAT_DM_NAMES") || "{}"); }
    catch { return {}; }
  });
  const [gchatAutoScroll, setGchatAutoScroll] = useState(true);
  const [gchatSearchQuery, setGchatSearchQuery] = useState("");
  const [pendingUpload, setPendingUpload] = useState(null); // { file: File, kind: "pdf" }

//  REFS BLOCK
  const currentViewRef = useRef(currentView);
  const gchatMeRef = useRef(gchatMe); 
  const gchatSelectedSpaceRef = useRef(gchatSelectedSpace); 
  const gchatDmNamesRef = useRef(gchatDmNames); 

  //  SYNC REFS
  useEffect(() => { 
    currentViewRef.current = currentView; 
    gchatMeRef.current = gchatMe;
    gchatSelectedSpaceRef.current = gchatSelectedSpace;
    gchatDmNamesRef.current = gchatDmNames;
  }, [currentView, gchatMe, gchatSelectedSpace, gchatDmNames]);

  //  ZERO-LATENCY ENGINE: Broadcasts Middle Pane changes directly to the Right Pane
  const [trelloBuckets, _setTrelloBuckets] = useState(() => {
    try {
      const cached = localStorage.getItem("TRELLO_CACHE");
      return cached ? JSON.parse(cached) : [];
    } catch(e) { return []; }
  }); 
  const setTrelloBuckets = (action) => {
      _setTrelloBuckets(prev => {
          const next = typeof action === 'function' ? action(prev) : action;
          window.dispatchEvent(new CustomEvent("optimisticRightPane", { detail: next }));
          return next;
      });
  };

//  CACHED LISTS: Feeds the Move Menu instantly
  const [allTrelloLists, setAllTrelloLists] = useState(() => {
    try {
      const cached = localStorage.getItem("TRELLO_LISTS_CACHE");
      return cached ? JSON.parse(cached) : [];
    } catch(e) { return []; }
  });
  
  useEffect(() => {
    fetch("/.netlify/functions/trello-lists")
      .then(res => res.json())
      .then(data => {
        if (data.lists) {
          const newLists = data.lists.map(l => ({ id: l.id, title: l.name, cardsLength: 0 }));
          setAllTrelloLists(prev => {
             const merged = newLists.map(nl => {
                 const existing = prev.find(p => p.id === nl.id);
                 return existing ? { ...nl, cardsLength: existing.cardsLength } : nl;
             });
             localStorage.setItem("TRELLO_LISTS_CACHE", JSON.stringify(merged));
             return merged;
          });
        }
      })
      .catch(err => console.error("Failed to fetch lists:", err));

    const handler = e => {
      setAllTrelloLists(prevLists => {
         const activeLists = e.detail; 
         const master = [...prevLists];
         activeLists.forEach(active => {
            const found = master.find(m => m.id === active.id);
            if (found) found.cardsLength = active.cardsLength;
            else master.push(active);
         });
         localStorage.setItem("TRELLO_LISTS_CACHE", JSON.stringify(master));
         return master;
      });
    };
    window.addEventListener("updateAllLists", handler);
    return () => window.removeEventListener("updateAllLists", handler);
  }, []);

// NEW DRAFT POSITION STATE
 const [draftPos, setDraftPos] = useState({ x: 0, y: 0 });
 const isDraggingDraft = useRef(false);
 const draftWindowRef = useRef(null);

 const handleDraftMouseDown = (e) => {
   if (isDraftEnlarged) return;
   e.preventDefault(); // Prevents text highlighting which breaks the drag
   isDraggingDraft.current = true;
   const startX = e.clientX - draftPos.x;
   const startY = e.clientY - draftPos.y;

   let currentX = draftPos.x;
   let currentY = draftPos.y;

   const onMouseMove = (moveEvent) => {
     if (!isDraggingDraft.current) return;
     
     currentX = moveEvent.clientX - startX;
     currentY = moveEvent.clientY - startY;

     // Update the DOM directly to bypass React render lag (0ms latency)
     if (draftWindowRef.current) {
       draftWindowRef.current.style.transform = `translate(${currentX}px, ${currentY}px)`;
     }
   };

   const onMouseUp = () => {
     isDraggingDraft.current = false;
     document.removeEventListener("mousemove", onMouseMove);
     document.removeEventListener("mouseup", onMouseUp);
     
     // Sync back to React state ONLY when dragging stops so it persists
     setDraftPos({ x: currentX, y: currentY });
   };

   document.addEventListener("mousemove", onMouseMove);
   document.addEventListener("mouseup", onMouseUp);
 };

  //  NEW: States for the "Add Time" popup
 const [showAddTime, setShowAddTime] = useState(false);
 const [manualHours, setManualHours] = useState("0");
 const [manualMins, setManualMins] = useState("0");

  //  UPDATED: Persist last active space so notifications work after reload
  useEffect(() => {
    if (gchatSelectedSpace) {
      lastActiveSpaceRef.current = gchatSelectedSpace;
      localStorage.setItem("LAST_ACTIVE_SPACE_ID", gchatSelectedSpace.id);
    }
  }, [gchatSelectedSpace]);

  //  NEW: Audio Recording State
  const [isRecording, setIsRecording] = useState(false);
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);

  //  NEW: Persist last notification time across re-renders
  const lastNotifiedRef = useRef({ time: Date.now() });

/*  NEW  Google Chat reactions UI state */
  const pendingReactionsRef = useRef(new Map()); //  ADDED SHIELD
  const myReactionsRef = useRef({}); //  NEW: Permanent memory for your clicks

 const [hoveredMsgId, setHoveredMsgId] = useState(null);
 const [reactions, setReactions] = useState({});
 const [gchatFilePreview, setGchatFilePreview] = useState(null); // { url, name, type }

  function toggleReaction(messageId, type) {
    // 0. Shield from the poller for 15 seconds (guarantees backend sync)
    pendingReactionsRef.current.set(messageId, Date.now() + 15000);

  // 1. Optimistic UI Update (Instant visual feedback)
  setReactions((prev) => {
   const currentList = prev[messageId] || [];
   const isSame = currentList.includes(type);
      //  FIXED: Correctly append or remove without wiping other existing reactions
   const nextList = isSame ? currentList.filter(t => t !== type) : [...currentList, type]; 
      
      //  MEMORIZE FOREVER: Save to permanent memory so the poller never wipes it
      myReactionsRef.current[messageId] = nextList;

   return { ...prev, [messageId]: nextList };
  });

  // 2. Send to Google (Background API Call)
  fetch("/.netlify/functions/gchat-react", {
   method: "POST",
   credentials: "include", //  MANDATORY: Attaches Siya's cookie
   headers: { "Content-Type": "application/json" },
   body: JSON.stringify({ messageId, type })
  }).catch(err => console.error("Reaction failed", err));
 }
useEffect(() => {
    const saved = localStorage.getItem("GCHAT_ME");
    if (saved) setGchatMe(saved);
  }, []);

  useEffect(() => {
    const close = (e) => {
      if (e.target.closest?.(".chat-plus-wrap")) return;
      setShowPlusMenu(false);
    };
    document.addEventListener("click", close);
    return () => document.removeEventListener("click", close);
  }, []);

  //  put scroll effect AFTER the above state exists
  useEffect(() => {
    const el = gchatBodyRef.current;
    if (!el) return;
    if (!gchatAutoScroll) return;

    el.scrollTop = el.scrollHeight;
  }, [gchatMessages, gchatSelectedSpace?.id, gchatAutoScroll]);

  const seenDriveEmailIdsRef = useRef(new Set());

 const handleToggleStar = async (e, msgId, currentStarred) => {
    //  GATEKEEPER: Ensure we have a valid ID to target
    if (!msgId) {
      console.error("Starring failed: messageId is missing or undefined.");
      return;
    }

    if (e) {
      e.stopPropagation();
      e.preventDefault();
    }
    
    const nextStarredState = !currentStarred;

    // 1. OPTIMISTIC UPDATE: Update the main list immediately
    // Uses msgId to ensure ONLY the clicked row changes color/state
    setGmailEmails(prev => prev.map(msg => 
      (msg && msg.id === msgId) ? { ...msg, isStarred: nextStarredState } : msg
    ));

    // 2. OPTIMISTIC UPDATE: Update the individual view immediately
    // Only updates if the currently open email matches the msgId
    setEmail(prev => {
      if (prev && prev.id === msgId) {
        return { ...prev, isStarred: nextStarredState };
      }
      return prev;
    });

    try {
      const response = await fetch("/.netlify/functions/gmail-toggle-star", {
        method: "POST",
        credentials: "include", 
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messageId: msgId, starred: nextStarredState })
      });

      if (!response.ok) throw new Error("Sync failed");

      // 3. UI CLEANUP: If we are in the 'Starred' folder and unstar something, hide it from view
      if (!nextStarredState && gmailFolder === "STARRED") {
        setGmailEmails(prev => prev.filter(msg => msg.id !== msgId));
      }
    } catch (err) {
      console.error("Starring sync failed:", err);
      
      // 4. REVERT ON ERROR: If the backend fails, flip the stars back to their original state
      setGmailEmails(prev => prev.map(msg => 
        (msg && msg.id === msgId) ? { ...msg, isStarred: currentStarred } : msg
      ));
      setEmail(prev => (prev && prev.id === msgId) ? { ...prev, isStarred: currentStarred } : prev);
      
      triggerSnackbar("Failed to update star status");
    }
  };
  /* WhatsApp */
  const [waChats, setWaChats] = useState(() => buildSeedChats());
  const waBodyRef = useRef(null);


/* Email */
  const [emailIdx, setEmailIdx] = useState(0);
  const [email, setEmail] = useState(EMAIL_THREADS[0]);
  const [emailPreview, setEmailPreview] = useState(null);
  const [showEmailDetails, setShowEmailDetails] = useState(false);

/*  Calendar State */
 const [calendarEvents, setCalendarEvents] = useState([]);
 const [calendarLoading, setCalendarLoading] = useState(false);
 const [calendarError, setCalendarError] = useState("");
 const [isMonthView, setIsMonthView] = useState(true); //  NEW: Tracks if we're in Month or List view

/* Gmail Inbox State */
 const [gmailEmails, setGmailEmails] = useState([]);
 const [gmailLoading, setGmailLoading] = useState(false);
 const [gmailError, setGmailError] = useState("");
const [selectedEmailIds, setSelectedEmailIds] = useState(new Set());
const [gmailFolder, setGmailFolder] = useState("INBOX"); // Tracks current folder
const [gmailRefreshTrigger, setGmailRefreshTrigger] = useState(0); //  NEW: Hard refresh trigger
const [gmailPage, setGmailPage] = useState(1);
const [gmailTotal, setGmailTotal] = useState(0); // Tracks total exact emails
const [gmailPageTokens, setGmailPageTokens] = useState({}); //  NEW: Fast pagination tokens

// NEW: email draft helper state
 const [showDraftPicker, setShowDraftPicker] = useState(false);
 const [selectedDraftTemplate, setSelectedDraftTemplate] = useState(null);
 const [draftTo, setDraftTo] = useState("");   //  NEW
 const [isDraftEnlarged, setIsDraftEnlarged] = useState(false); //  NEW
 const [draftAttachments, setDraftAttachments] = useState([]); //  NEW: Holds email attachments
 const draftFileInputRef = useRef(null); //  NEW: Reference for the hidden file input
const [otherContacts, setOtherContacts] = useState({});
const [historyContacts, setHistoryContacts] = useState({});

useEffect(() => {
   fetch("/.netlify/functions/gmail-contacts", { credentials: "include" })
     .then(res => res.json())
     .then(data => {
       if (data.ok && data.contacts) {
         setOtherContacts(data.contacts);
       }
     })
     .catch(err => console.error("Failed to fetch contacts", err));
 }, []);

useEffect(() => {
  if (!gmailEmails || !Array.isArray(gmailEmails) || gmailEmails.length === 0) return;
  const newHits = {};
  const parse = (input) => {
    if (!input) return;
    const items = Array.isArray(input) ? input : String(input).split(/,(?=[^>]*?(?:<|$))/);
    items.forEach(raw => {
      if (!raw) return;
      let str = String(raw).trim();
      if (!str) return;

      let emailAddress = "";
      let displayName = "";

      // Logic: If the string has brackets, the content inside is the full email [cite: 84]
      if (str.includes("<") && str.includes(">")) {
        const parts = str.split("<");
        displayName = parts[0].replace(/"/g, '').trim();
        emailAddress = parts[1].replace(">", "").trim().toLowerCase();
      } else if (str.includes("@")) {
        // Fallback for raw email addresses without names
        emailAddress = str.toLowerCase();
        const prefix = emailAddress.split("@")[0];
        displayName = prefix.split(/[._]/).map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
      }

      // Ensure we only store valid email entries [cite: 211, 238]
      if (emailAddress && emailAddress.includes("@")) {
        newHits[displayName || emailAddress] = emailAddress;
      }
    });
  };
  
  gmailEmails.forEach(m => { 
    if (m) {
      parse(m.from); 
      parse(m.to); 
      parse(m.cc); 
    }
  });

if (Object.keys(newHits).length > 0) {
    setHistoryContacts(prev => {
      //  Deep compare: Only update state if we found an email address not already in the list
      const hasNew = Object.values(newHits).some(email => !Object.values(prev).includes(email));
      if (!hasNew) return prev;
      return { ...prev, ...newHits };
    });
  }
}, [gmailEmails]);

const combinedContacts = useMemo(() => {
 return {
  ...(AC_EMAIL_MAP || {}),
  ...(otherContacts || {}),
  ...(historyContacts || {})
 };
}, [otherContacts, historyContacts]);

  /* Trello modal */
 const [trelloCard, setTrelloCard] = useState(null);
 const [trelloPreview, setTrelloPreview] = useState(null); //  NEW: Controls the preview pop-up
  const trelloAttachmentRef = useRef(null); 
 const [checklists, setChecklists] = useState([]);
 const [newChecklistTitle, setNewChecklistTitle] = useState("Checklist");
 const [copyFromChecklist, setCopyFromChecklist] = useState("");
  const [attachLink, setAttachLink] = useState(""); 
  const [attachName, setAttachName] = useState(""); 
  const [cardAttachments, setCardAttachments] = useState([]); //  NEW: Holds the file data

 // Fetches checklists & attachments when the modal opens
 useEffect(() => {
  if (trelloCard?.id) {
       // 1. Fetch Checklists
   fetch(`/.netlify/functions/trello-checklists?cardId=${trelloCard.id}`)
    .then(res => res.json())
    .then(data => { if(Array.isArray(data)) setChecklists(data); })
    .catch(err => console.error("Checklist fetch failed:", err));

       // 2. Fetch Attachments
       fetch(`/.netlify/functions/trello-attachments?cardId=${trelloCard.id}`)
         .then(res => res.json())
         .then(data => { if(Array.isArray(data)) setCardAttachments(data); })
         .catch(err => console.error("Attachment fetch failed:", err));
  }
 }, [trelloCard?.id]);
  const [trelloMenuOpen, setTrelloMenuOpen] = useState(false);
  const [showMoveSubmenu, setShowMoveSubmenu] = useState(false);
  const [moveTab, setMoveTab] = useState("outbox");
  const [moveTargetList, setMoveTargetList] = useState("");
  const [moveTargetPos, setMoveTargetPos] = useState(1);
  const [moveListSearch, setMoveListSearch] = useState(""); //  NEW: Tracks search text
  
  // NEW: local Description editor state
  const [descEditing, setDescEditing] = useState(false);
  const [descDraft, setDescDraft] = useState("");
  
  const [trelloMembers, setTrelloMembers] = useState([]);
 const [showAddMenu, setShowAddMenu] = useState(false);
 const [addMenuStep, setAddMenuStep] = useState("main"); // "main" or "members"
  const [showMemberShortcut, setShowMemberShortcut] = useState(false); //  NEW

  const pendingCFRef = useRef(new Map()); // cardId -> { fieldName: expiryTs }

  useEffect(() => {
  const nice =
    PERSONA.toUpperCase() === "YOLANDIE"
      ? "Yolandie"
      : PERSONA.toUpperCase() === "SIYA"
      ? "Siya"
      : "Unknown";

  document.title = `ActuarySpace  ${nice}`;
  }, []);

  // src/App.jsx

useEffect(() => {
    async function syncAllNotifications() {
      try {
        // 1. Fetch both sources simultaneously
        const [emailRes, chatRes] = await Promise.all([
          fetch("/.netlify/functions/drive-get-emails"),
          fetch("/.netlify/functions/gchat-sync")
        ]);

        const emailData = await emailRes.json();
        const chatData = await chatRes.json();

        let combined = [];
        // Add emails
        if (chatData.ok && chatData.notifications) {
          combined = [...combined, ...chatData.notifications.map(n => {
            //  NAME RESOLUTION: Extract real name from snippet if title is generic "Someone"
            let senderLabel = n.title || "Colleague";
            let cleanText = n.text || "";

            if (senderLabel === "Someone" || senderLabel === "Colleague") {
              const nameMatch = cleanText.match(/from ([A-Z][a-z]+)/); // Scans for "from Jonathan"
              if (nameMatch) senderLabel = nameMatch[1];
            }
            
            //  "Someone" FIX: Apply the resolved name to the snippet prefix
            if (cleanText.startsWith("Someone:")) {
              cleanText = cleanText.replace("Someone:", `${senderLabel}:`);
            }
            
            const truncatedSnippet = cleanText.length > 60 ? cleanText.substring(0, 57) + "..." : cleanText;

            return {
              ...n,
              alt: "Google Chat",
              icon: gchatIcon,
              text: truncatedSnippet || `New message from ${senderLabel}`,
              senderName: senderLabel,
              timestamp: n.timestamp || n.createTime || new Date().toISOString(),
              spaceId: n.spaceId || n.space?.name 
            };
          })];
        }

        //  RECENT-FIRST SORT: Uses getTime() for strict descending chronological order
        combined.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

        // 3. Map to UI format and Filter for NEW items only
        setNotifications(prev => {
          const seenIds = new Set(prev.map(p => p.id));
          const newItems = combined
            .filter(item => {
              //  SESSION REFRESH: Only show notifications gotten since opening the app
              const isNew = !seenIds.has(item.id);
              const itemTime = new Date(item.timestamp).getTime();
              const loginTime = sessionStartTime.current.getTime();
              // Add a 5-second buffer for server/client clock drift
              return isNew && itemTime > (loginTime - 5000);
            })
            .map(item => ({
              ...item,
              time: formatUKTimeWithSeconds(new Date(item.timestamp))
            }));
          
          if (newItems.length === 0) return prev;
          
          // Merge and maintain strict newest-first order
          const next = [...newItems, ...prev].sort((a, b) => {
            return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
          });
          
          return next.slice(0, 100);
        });
      } catch (err) {
        console.error("Failed to sync inbox:", err);
      }
    }

    syncAllNotifications();
    const interval = setInterval(syncAllNotifications, 10000); // Check every 10s
    return () => clearInterval(interval);
  }, []);

  // 1. GLOBAL IDENTITY LOADER (Runs once on mount, regardless of view)
useEffect(() => {
    async function fetchWhoAmI() {
      const stored = localStorage.getItem("GCHAT_ME");
      if (stored) setGchatMe(stored);

      try {
        const res = await fetch("/.netlify/functions/gchat-whoami", {
          credentials: "include" 
        });

        //  If the response is 401 or 500, we don't try to parse it as a valid user
        if (!res.ok) {
          if (res.status === 401) console.log("User is not authenticated yet.");
          return; 
        }

        const json = await res.json().catch(() => ({}));
        const myId = json.name || json.user?.name || json.resourceName;

        if (myId) {
          console.log("identified current user as:", myId);
          setGchatMe(myId);
          localStorage.setItem("GCHAT_ME", myId);
        }
      } catch (err) {
        console.warn("Silent Auth Check:", err.message);
      }
    }
    fetchWhoAmI();
  }, []);

  // 1.5 SPACE LOADER (Fetches the list of rooms/DMs)
  useEffect(() => {
    if (currentView.app !== "gchat") return;

    let cancelled = false;

    async function loadSpaces() {
      try {
        setGchatLoading(true);
        setGchatError("");

        //  Added credentials: "include" so the sidebar can load using your cookie
        const res = await fetch("/.netlify/functions/gchat-spaces", {
          credentials: "include"
        });
        
        const json = await res.json().catch(() => ({}));

        if (!res.ok || json.ok !== true) {
          throw new Error(json?.error || `Failed to load spaces (HTTP ${res.status})`);
        }

        if (!cancelled) {
          setGchatSpaces(Array.isArray(json.spaces) ? json.spaces : []);
          setGchatSelectedSpace(null);
          setGchatMessages([]);
          setGchatMsgError("");
          setGchatComposer("");
        }
      } catch (err) {
        if (!cancelled) setGchatError(String(err?.message || err));
      } finally {
        if (!cancelled) setGchatLoading(false);
      }
    }

    loadSpaces();

    return () => {
      cancelled = true;
    };
  }, [currentView.app]);

// 2. CHAT VIEW LOADER (Runs only when opening Chat)
  useEffect(() => {
    if (currentView.app !== "gchat") return;
    if (!gchatSpaces.length) return;

    // 1. Find all DMs that are Unnamed OR explicitly called "Direct Message"
    const dmsToLoad = gchatSpaces.filter(
      (s) => 
        s.type === "DIRECT_MESSAGE" && 
        (!gchatDmNames[s.id] || gchatDmNames[s.id] === "Direct Message") //  THIS IS THE CRITICAL FIX
    );

    if (!dmsToLoad.length) return;

    // 2. Fire ALL requests in parallel (The "Blast")
    Promise.all(
      dmsToLoad.map(async (dm) => {
        try {
          const res = await fetch(
            `/.netlify/functions/gchat-dm-name?space=${encodeURIComponent(dm.id)}`
          );
          
          if (!res.ok) return;

          const json = await res.json().catch(() => ({}));

          // 3. Incrementally update state as each one lands (Instant Pop-in)
              if (json.ok && json.names) {
                const label = Object.values(json.names)[0];
                // Only update if we got a REAL name (not "Direct Message" again)
                if (label && label !== "Direct Message") {
                  setGchatDmNames((prev) => {
                    const next = { ...prev, [dm.id]: label };
                    localStorage.setItem("GCHAT_DM_NAMES", JSON.stringify(next));
                    return next;
                  });
                }
              }
        } catch (err) {
          console.error("DM name resolution failed for", dm.id, err);
        }
      })
    );
  }, [currentView.app, gchatSpaces]);

// 3. NAME LEARNER (The Fix for Sidebar Mismatch)
      useEffect(() => {
        if (!gchatSelectedSpace || !gchatMessages.length) return;
        if (gchatSelectedSpace.type !== "DIRECT_MESSAGE") return;

        //  STALE DATA GUARD: Ensure messages belong to the selected space
        const firstMsg = gchatMessages[0];
        const msgSpaceId = firstMsg?.space?.name || firstMsg?.name?.split('/messages/')[0];
        if (msgSpaceId && msgSpaceId !== gchatSelectedSpace.id) return;

        const currentListName = gchatDmNames[gchatSelectedSpace.id];

        //  IMPROVED DRIVE GUARD: Only rename if the sender is actually a BOT
        // This prevents human file-sharing from renaming the chat to "Google Drive"
        const isActualDriveBot = gchatMessages.some(m => m.sender?.type === "BOT");
        
        if (isActualDriveBot) {
          if (currentListName !== "Google Drive") {
            setGchatDmNames(prev => {
              const next = { ...prev, [gchatSelectedSpace.id]: "Google Drive" };
              localStorage.setItem("GCHAT_DM_NAMES", JSON.stringify(next));
              return next;
            });
          }
          return;
        }

        // 2. Find the REAL name from the messages
        const otherMsg = gchatMessages.find(m => {
          const sName = m.sender?.displayName || "";
          const sEmail = m.sender?.email || "";
          const isSiya = (!!gchatMe && m.sender?.name === gchatMe) ||
                         sEmail.includes('siya@') ||
                         sName.toLowerCase().includes('siya') ||
                         sName.toLowerCase().includes('actuaryspace');
          
          //  BOT SHIELD: Don't learn names from bots or system IDs
          return !isSiya && m.sender?.type === "HUMAN" && !sName.includes("users/");
        });
        
        const realName = otherMsg?.sender?.displayName;

        if (realName && currentListName !== realName && !realName.toLowerCase().includes("actuaryspace") && !realName.startsWith("users/")) {
          setGchatDmNames(prev => {
            const next = { ...prev, [gchatSelectedSpace.id]: realName };
            localStorage.setItem("GCHAT_DM_NAMES", JSON.stringify(next));
            return next;
          });
        }
      }, [gchatSelectedSpace, gchatMessages, gchatMe, gchatDmNames]);

  // Google Chat: load + poll messages when a space is selected
useEffect(() => {
  if (currentView.app !== "gchat") return;
  if (!gchatSelectedSpace?.id) return;

  let cancelled = false;

  //  THE CLEANUP FIX: Reset everything immediately when space changes
  // This prevents the previous chat's data from being processed by the name-learner logic.
  setGchatMessages([]);
  setGchatNextPageToken(null);
  setGchatMsgError("");
  setGchatMsgLoading(true);

  async function fetchLatestAndMerge() {
    try {
      const res = await fetch(
        `/.netlify/functions/gchat-messages?space=${encodeURIComponent(
          gchatSelectedSpace.id
        )}`, 
        { credentials: "include" }
      );
      
      const json = await res.json().catch(() => ({}));

      if (!res.ok || json.ok !== true) {
        throw new Error(json?.error || `Failed to load messages (HTTP ${res.status})`);
      }

      const incomingRaw = Array.isArray(json.messages) ? json.messages : [];
      const incoming = incomingRaw.map((m) => normalizeGChatMessage(m));

      if (!cancelled) {
        // Double-check space ID hasn't changed while we were fetching
        if (gchatSelectedSpace.id !== gchatSelectedSpaceRef.current.id) return;

        setGchatMessages((prev) => dedupeMergeMessages(prev, incoming));
        if (json.nextPageToken) setGchatNextPageToken(json.nextPageToken);

        setReactions((prev) => {
          const next = { ...prev };
          const now = Date.now();
          incoming.forEach((msg) => {
            const msgId = msg.id || msg.name;
            if (pendingReactionsRef.current.has(msgId)) {
                if (now < pendingReactionsRef.current.get(msgId)) return;
                pendingReactionsRef.current.delete(msgId);
            }

            let parsedReactions = [];
            if (msg.reactions && Array.isArray(msg.reactions)) {
              parsedReactions = msg.reactions.map(rx => {
                  const uni = rx.emoji?.unicode || "";
                  const name = (rx.emoji?.name || "").toLowerCase();
                  if (uni.includes("") || name.includes("thumb") || name.includes("+1")) return "like";
                  if (uni.includes("") || uni.includes("") || uni === "" || name.includes("heart")) return "heart";
                  if (uni.includes("") || uni.includes("") || uni === "" || name.includes("laugh") || name.includes("joy") || name.includes("smile") || name.includes("grin")) return "laugh";
                  return null;
              }).filter(Boolean);
            } 
            const mySaved = myReactionsRef.current[msgId] || [];
            next[msgId] = [...new Set([...mySaved, ...parsedReactions])];
          });
          return next;
        });
      }
    } catch (err) {
      if (!cancelled) setGchatMsgError(String(err?.message || err));
    } finally {
      if (!cancelled) setGchatMsgLoading(false);
    }
  }

  fetchLatestAndMerge();
  const pollId = setInterval(fetchLatestAndMerge, 4000);

  return () => {
    cancelled = true;
    clearInterval(pollId);
    //  SAFETY RESET: Ensure nothing lingers when the component unmounts or switches
    setGchatMessages([]);
    setGchatMsgLoading(false);
  };
}, [currentView.app, gchatSelectedSpace?.id]);

  //  FIXED: Google Chat Background Poller (Stable Version using decoupled Refs)
 useEffect(() => {
  const pollGlobal = async () => {
   // 1. RATE LIMIT GUARD: Prevent multi-tab spamming (like Trello)
   const now = Date.now();
   const lastFetch = parseInt(localStorage.getItem("lastGchatPoll") || "0");
   if (now - lastFetch < 12000) return; // Wait 12s minimum
   localStorage.setItem("lastGchatPoll", now.toString());

   let targetSpaceId = lastActiveSpaceRef.current?.id || localStorage.getItem("LAST_ACTIVE_SPACE_ID");

      if (!targetSpaceId || targetSpaceId === "undefined") {
        try {
          const res = await fetch("/.netlify/functions/gchat-spaces", { credentials: "include" });
          const json = await res.json().catch(() => ({}));
          if (json.ok && json.spaces?.length > 0) {
            targetSpaceId = json.spaces[0].id || json.spaces[0].name;
            localStorage.setItem("LAST_ACTIVE_SPACE_ID", targetSpaceId);
          }
        } catch (e) {}
      }

      if (!targetSpaceId || targetSpaceId === "undefined") return;

   // 2. VIEW STATE CHECK: Use stable refs so the poller runs continuously without restarts
   const amIWatching = currentViewRef.current?.app === "gchat" && gchatSelectedSpaceRef.current?.id === targetSpaceId;
   if (amIWatching) return;

   try {
    const res = await fetch(
     `/.netlify/functions/gchat-messages?space=${encodeURIComponent(targetSpaceId)}`,
     { credentials: "include" }
    );
    const json = await res.json().catch(() => ({}));
    
    if (!json.ok || !Array.isArray(json.messages)) return;
    const msgs = json.messages.map(normalizeGChatMessage);

    // 3. FIRST RUN: Memorize state silently (Like Gmail)
    if (seenGchatIdsRef.current === null) {
     seenGchatIdsRef.current = new Set(msgs.map(m => m.name || m.id));
     return;
    }

    // 4. NOTIFICATION LOOP: Notify for any NEW IDs not seen before
    msgs.forEach(msg => {
     const msgId = msg.name || msg.id;
     if (!seenGchatIdsRef.current.has(msgId)) {
      seenGchatIdsRef.current.add(msgId);

      // Only notify if NOT from Siya
            if (msg.sender?.name !== gchatMeRef.current) {
              const learnedName = gchatDmNamesRef.current[targetSpaceId]; 
              
              //  MASTER LIST RESOLVER: Map raw IDs to clean names from your gchat-dm-name master list
       const KNOWN_USERS = {
        "users/109833975621386956073": "Bonolo",
        "users/116928759608148752435": "Simon Streicher",
                "users/101273447946115685891": "Tiffany Harzon-Cuyler",
                "users/110481684541592719996": "Albert Grobler",
                "users/103060225088465733197": "Tinashe Chikwamba",
                "users/105158373279991959375": "Ethan Maburutse",
                "users/112681921793658298066": "Min Moolman",
                "users/114609724339659491302": "Bianca Wiid",
                "users/100183703799963986718": "Alicia Oberholzer",
                "users/106094639157491328183": "Leonah Marewangepo",
                "users/100973980027446317396": "Eugene Cloete",
                "users/101954867987984084170": "Alicia Kotz",
                "users/108929714281084389788": "Songeziwe Chiya",
                "users/110745530036003772233": "Bonisa Mqonqo",
                "users/100710383419487896813": "Cameron Curtis",
                "users/104310623309718505350": "Shamiso Hapaguti",
                "users/113565695109176296608": "Waldo Jenkins",
                "users/108628384720735354945": "Melvin Smith",
                "users/115863503558522206541": "Yolandie",
                "users/105726015150067918055": "Enock Kazembe",
                "users/114022848581179253421": "Matthew Darch",
                "users/104654529926543347255": "Martin Otto", 
                "users/111372729949487816593": "Melokuhle Mabuza",
                "users/113385769871096416574": "Willem Havenga",
                "users/103669371912398598964": "Jennifer Mouton",
                "users/117489264027903000976": "Conah MacFarlane",
                "users/112422887282158931745": "Repository",
                "users/117124449099034019701": "Robyn Anderson",
                "users/112417469383977278282": "Siyolise Mazwi",
              };

              // Identify the sender ID
              const senderId = msg.sender?.name || "";
              
              // Use logic: Master List Name > Display Name > Sidebar Learned Name > Colleague
              let senderName = KNOWN_USERS[senderId] || msg.sender?.displayName || learnedName || "Colleague";
              
              // Final fallback if we still have a raw ID string
              if (senderName.startsWith("users/")) {
                senderName = learnedName || "Colleague";
              }
              
              let rawText = msg.text || "";
              if (!rawText && msg.attachment?.length) {
                rawText = `Sent an attachment: ${msg.attachment[0].contentName || "a file"}`;
              }
              
              const previewText = rawText.length > 45 ? rawText.substring(0, 42) + "..." : rawText;

              window.dispatchEvent(new CustomEvent("notify", {
                detail: {
                  id: msgId, 
                  text: `${senderName}: ${previewText}`, 
                  alt: "Google Chat",
                  icon: gchatIcon,
                  spaceId: targetSpaceId,
                  senderName: senderName,
                  timestamp: msg.createTime 
                }
              }));
            }
     }
    });
   } catch (err) {
    console.error("Background poll error", err);
   }
  };

  pollGlobal();
  const intervalId = setInterval(pollGlobal, 15000); // Decoupled 15s interval matching Gmail
  return () => clearInterval(intervalId);
 }, []);

  // (pollBackground removed: pollGlobal handles background notifications efficiently)

  //  FIX: Track active search and folder states so the background poller doesn't inject unrelated emails into search results
  const activeSearchRef = useRef("");
  const activeFolderRef = useRef("INBOX");
  useEffect(() => { activeSearchRef.current = searchQuery; }, [searchQuery]);
  useEffect(() => { activeFolderRef.current = gmailFolder; }, [gmailFolder]);

  //  Poll Data Centre (Google Drive) for new instruction emails
//  GMAIL BACKGROUND POLLER (Real Inbox)
  useEffect(() => {
    const pollGmailBackground = async () => {
      try {
        const res = await fetch("/.netlify/functions/gmail-inbox?limit=50");
        const json = await res.json().catch(() => ({}));
        
        if (!json.ok || !Array.isArray(json.emails)) return;

     // 1. FIRST RUN: Memorize inbox AND trigger notifications for UNREAD emails
        if (seenGmailIdsRef.current === null) {
          seenGmailIdsRef.current = new Set(json.emails.map(e => e.id));
          
          // Reverse the array so the absolute newest emails are processed LAST, 
          // placing them at the very top of the notification stack.
          [...json.emails].reverse().forEach(email => {
            if (email.isUnread) {
              const cleanFrom = email.from ? email.from.split("<")[0].replace(/"/g, '').trim() : "Someone";
              const cleanSubject = email.subject || "(No Subject)";
              window.dispatchEvent(new CustomEvent("notify", {
                detail: {
                  text: `${cleanFrom}: ${cleanSubject}`,
                  alt: "Gmail",
                  icon: gmailIcon,
                  gmailData: email
                }
              }));
            }
          });
          return;
        }

        // 2. SUBSEQUENT RUNS: Check for new emails
        // Reverse here as well to ensure batch arrivals stack chronologically
        [...json.emails].reverse().forEach(email => {
          if (!seenGmailIdsRef.current.has(email.id)) {
            // Add to seen list so it doesn't trigger twice
            seenGmailIdsRef.current.add(email.id);

            // Clean up sender name
            const cleanFrom = email.from ? email.from.split("<")[0].replace(/"/g, '').trim() : "Someone";
            const cleanSubject = email.subject || "(No Subject)";

            // Dispatch Notification
                window.dispatchEvent(new CustomEvent("notify", {
                  detail: {
                    text: `${cleanFrom}: ${cleanSubject}`,
                    alt: "Gmail",
                    icon: gmailIcon,
                    gmailData: email // Pass the real email data
                  }
                }));

                //  FIX: Only inject new emails into the UI if the user is looking at the standard INBOX and NOT searching.
                // Otherwise, unrelated background emails will ruin the search results!
                if (!activeSearchRef.current && activeFolderRef.current === "INBOX") {
                  setGmailEmails(prev => {
                    const exists = prev.find(p => p.id === email.id);
                    if (exists) return prev;
                    return [email, ...prev];
                  });
                }
              }
            });
          } catch (err) {
            console.error("Background Gmail poll failed", err);
          }
        };

    pollGmailBackground();
    const id = setInterval(pollGmailBackground, 15000); 
    return () => clearInterval(id);
  }, []);

//  Poll Data Centre (Google Drive) for new instruction emails
  useEffect(() => {
    // DISABLED: We are now using the real Gmail API polling below.
    // This stops the raw .eml Drive file IDs from spamming the notifications panel.
  }, [setNotifications]);

//  GMAIL INBOX LOADER
useEffect(() => {
  if (currentView.app !== "gmail") return;

  let cancelled = false;

  const loadInbox = async () => {
    setGmailLoading(true);
    setGmailError("");
    try {
      let currentToken = "";
      //  Ensure we use the correct token for the requested page
      if (gmailPage > 1) {
        currentToken = gmailPageTokens[gmailPage] || "";
      }

      const baseQ = searchQuery.trim();
      let finalQ = baseQ;
      if (baseQ.toUpperCase().includes("AC REF") && !baseQ.includes('"')) {
          finalQ = `"${baseQ}"`;
      }
      
      const qParam = finalQ ? `in:all ${finalQ}` : "";
      const folderParam = finalQ ? "ALL" : gmailFolder;

      const res = await fetch(`/.netlify/functions/gmail-inbox?folder=${folderParam}&limit=50&pageToken=${currentToken}&q=${encodeURIComponent(qParam)}`);
      const json = await res.json().catch(() => ({}));

      if (!res.ok || !json.ok) throw new Error(json.error || `HTTP ${res.status}`);

      if (!cancelled) {
        setGmailEmails(json.emails || []);
        
        //  FORCE UPDATE TOTAL: This removes the 500 cap from the UI
        if (json.total !== undefined) {
          setGmailTotal(json.total);
        }
        
        if (json.nextPageToken) {
          setGmailPageTokens(prev => ({ ...prev, [gmailPage + 1]: json.nextPageToken }));
        }
      }
    } catch (err) {
      if (!cancelled) setGmailError(String(err.message || err));
    } finally {
      if (!cancelled) setGmailLoading(false);
    }
  };

  if (gmailPage === 1) {
    setGmailPageTokens({});
  }

  // Run immediately if no search, otherwise wait for user to finish typing
    const delay = searchQuery ? 600 : 0;
    const timeOutId = setTimeout(loadInbox, delay);

    return () => { 
      cancelled = true; 
      clearTimeout(timeOutId);
    };
  }, [currentView.app, gmailFolder, gmailRefreshTrigger, gmailPage, searchQuery, isMonthView]);

  //  CALENDAR EVENTS LOADER
  useEffect(() => {
    if (currentView.app !== "calendar") return;

    let cancelled = false;
    setCalendarLoading(true);
    setCalendarError("");

    fetch("/.netlify/functions/calendar-events", { credentials: "include" })
      .then(res => res.json())
      .then(data => {
        if (cancelled) return;
        if (data.ok) {
          setCalendarEvents(data.events || []);
        } else {
          setCalendarError(data.error || "Failed to load events");
        }
      })
      .catch(err => {
        if (!cancelled) setCalendarError(err.message);
      })
      .finally(() => {
        if (!cancelled) setCalendarLoading(false);
      });

    return () => { cancelled = true; };
  }, [currentView.app]);

 
    // When we are not looking at an email, the right-panel client files should be empty
  useEffect(() => {
    if (currentView.app !== "email") {
      window.dispatchEvent(
        new CustomEvent("setClientFiles", { detail: { files: [] } })
      );
    }
  }, [currentView.app]);

    // When right-panel client files are clicked, open PDF in middle-pane split view
  useEffect(() => {
    function onOpenEmailAttachmentPreview(e) {
      const file = e.detail?.file;
      if (!file) return;

      // Switch to Gmail view
      setCurrentView({ app: "email", contact: null });

      // Open the preview in the split view
      setEmailPreview(file);
    }

    window.addEventListener(
      "openEmailAttachmentPreview",
      onOpenEmailAttachmentPreview
    );

    return () => {
      window.removeEventListener(
        "openEmailAttachmentPreview",
        onOpenEmailAttachmentPreview
      );
    };
  }, []);

useEffect(() => {
  const handler = (e) => {
    setTrelloMenuOpen(false);
    setDescEditing(false);
    setDescDraft("");

    setCurrentView({ app: "trello", contact: null });
    setTrelloCard({
      id: e.detail.id,
      boardList: e.detail.list || "Yolandie",
      listId: e.detail.listId || null,
      title: e.detail.title,
      dueDisplay: e.detail.due,
      members: e.detail.people || [],
      labels: Array.isArray(e.detail.labels) ? e.detail.labels : [],
      badges: ensureBadgeTypes(Array.isArray(e.detail.badges) ? e.detail.badges : []),
      description: (e.detail.description ?? deriveDescriptionFromTitle(e.detail.title)),
      customFields: e.detail.customFields || {}, /*  CRITICAL: Loads the saved time when tab opens */
      timers: { time: e.detail.eta || "0m" },
                  activity: [],
                  isArchived: e.detail.isArchived || false // <-- THIS IS THE FIX
                });
  };
  window.addEventListener("openTrelloCard", handler);
  return () => window.removeEventListener("openTrelloCard", handler);
}, []);



//  NEW: Fetch Board Members on load
  useEffect(() => {
    fetch("/.netlify/functions/trello-members")
      .then(res => res.json())
      .then(data => { if (data.ok && data.members) setTrelloMembers(data.members); })
      .catch(err => console.error("Failed to fetch members", err));
  }, []);

  useEffect(() => {
  const close = (e) => {
   if (e.target.closest?.(".kebab-wrap")) return;
   setTrelloMenuOpen(false);
   setShowMoveSubmenu(false);
  
   if (!e.target.closest?.(".add-menu-wrap")) {
    setShowAddMenu(false);
   }
      //  NEW: Close the shortcut menu if clicking outside
      if (!e.target.closest?.(".member-shortcut-wrap")) {
        setShowMemberShortcut(false);
      }
  };
  document.addEventListener("click", close);
  return () => document.removeEventListener("click", close);
 }, []);

  // 1. TRACK PENDING UPDATES (Prevents flickering)
  useEffect(() => {
    function onPendingCF(e) {
      const { cardId, field, ttlMs = 2000 } = e.detail || {}; 
      if (!cardId || !field) return;
      const now = Date.now();
      const m = pendingCFRef.current;
      const rec = m.get(cardId) || {};
      rec[field] = now + ttlMs; // Ignore server updates for this field for 2s
      m.set(cardId, rec);
    }
    window.addEventListener("pendingCF", onPendingCF);
    return () => window.removeEventListener("pendingCF", onPendingCF);
  }, []);
  
// CATCH POLLED DATA FROM RIGHT PANEL
  useEffect(() => {
    function handlePoll(e) {
      _setTrelloBuckets(e.detail); //  Use _set to avoid echoing back to RightPanel
    }
    window.addEventListener("trelloPolled", handlePoll);
    return () => window.removeEventListener("trelloPolled", handlePoll);
  }, []);

  // 2. MIDDLE PANE: INSTANT UPDATE LISTENER (Fixes 10s delay)
  useEffect(() => {
    function handlePatch(e) {
      const { cardId, updater } = e.detail;
      _setTrelloBuckets(prevBuckets => { //  Use _set to avoid echoing back to RightPanel
        return prevBuckets.map(b => ({
          ...b,
          cards: b.cards.map(c => {
            if (c.id !== cardId) return c;
            
            // Apply the update locally
            const updatedCard = updater(c);
            
            // Re-calculate badges for the Right Panel view immediately
            const newBadges = [];
            
            // Priority
            if (updatedCard.customFields?.Priority) {
               newBadges.push({ text: `Priority: ${updatedCard.customFields.Priority}`, isBottom: true });
            }
            // Status
            if (updatedCard.customFields?.Status) {
               newBadges.push({ text: `Status: ${updatedCard.customFields.Status}`, isBottom: true });
            }
            // Active
            if (updatedCard.customFields?.Active) {
               newBadges.push({ text: `Active: ${updatedCard.customFields.Active}`, isBottom: true });
            }
            
            // Preserve labels
            (updatedCard.labels || []).forEach(l => newBadges.push({ text: l, isBottom: false }));
            
            updatedCard.badges = ensureBadgeTypes(newBadges);
            return updatedCard;
          })
        }));
      });
    }

    window.addEventListener("patchCardInBuckets", handlePatch);
    return () => window.removeEventListener("patchCardInBuckets", handlePatch);
  }, []);

  // 3. MIDDLE PANE: SYNC WITH TRELLO (Fixes "Not Updating")
  useEffect(() => {
    if (!trelloCard?.id) return;

    // A. Find fresh copy of the open card
    let fresh = null;
    for (const b of trelloBuckets) {
      const hit = (b.cards || []).find(x => x.id === trelloCard.id);
      if (hit) { fresh = hit; break; }
    }
    if (!fresh) return;

    // B. Check which fields are "Pending" (edited recently by user)
    const now = Date.now();
    const pend = pendingCFRef.current.get(trelloCard.id) || {};
    const isPending = (field) => pend[field] && pend[field] > now;

    // C. Detect Changes
  const oldCF = JSON.stringify(trelloCard.customFields || {});
  const newCF = JSON.stringify(fresh.customFields || {});
  const oldLabels = JSON.stringify(trelloCard.labels || []);
  const newLabels = JSON.stringify(fresh.labels || []);
  const oldDesc = trelloCard.description || "";
  const newDesc = fresh.description || "";
    const oldMembers = JSON.stringify(trelloCard.members || []);
    const newMembers = JSON.stringify(fresh.people || []);

  // D. Update if changed (BUT respect pending fields)
  if (oldCF !== newCF || oldLabels !== newLabels || oldDesc !== newDesc || oldMembers !== newMembers) {
   setTrelloCard(prev => {
     const mergedCF = { ...fresh.customFields };
          
          //  MEMBER SHIELD: Ignore Trello's data if we just clicked Add/Remove
          const mergedMembers = isPending("Members") ? prev.members : (fresh.people || []);
          //  PROTECT LOCAL EDITS: If user just edited these, ignore Server value for a few seconds
     if (isPending("Priority")) mergedCF.Priority = prev.customFields.Priority;
     if (isPending("Status"))  mergedCF.Status  = prev.customFields.Status;
     if (isPending("Active"))  mergedCF.Active  = prev.customFields.Active;
     if (isPending("Duration")) mergedCF.Duration = prev.customFields.Duration;
     if (isPending("TimerStart")) mergedCF.TimerStart = prev.customFields.TimerStart;
          if (isPending("WorkDuration"))   mergedCF.WorkDuration   = prev.customFields.WorkDuration;
          if (isPending("WorkTimerStart")) mergedCF.WorkTimerStart = prev.customFields.WorkTimerStart;  

          return {
             ...prev,
             labels: fresh.labels,       // Always take fresh labels
             members: mergedMembers, //  ADD THIS LINE
             description: descEditing ? prev.description : newDesc, 
             customFields: mergedCF,     // Smart Merge
             badges: ensureBadgeTypes([
                ...(mergedCF.Priority ? [{text: `Priority: ${mergedCF.Priority}`, isBottom: true}] : []),
                ...(mergedCF.Status   ? [{text: `Status: ${mergedCF.Status}`, isBottom: true}] : []),
                ...(mergedCF.Active   ? [{text: `Active: ${mergedCF.Active}`, isBottom: true}] : []),
                ...(fresh.labels || []).map(l => ({text: l, isBottom: false}))
             ])
          };
       });
    }
  }, [trelloBuckets]);

  const detectContact = (text, fallback) => {
    const hit = AC_CONTACTS.find((n) => text.includes(n));
    return hit || fallback;
  };

const onNotificationClick = async (n) => {
 // Ensure the panel is dismissed immediately upon clicking
 dismissNotification(n);

 // 1. Google Chat Handler
 if (n.alt === "Google Chat") {
  setCurrentView({ app: "gchat", contact: null });
  const sid = n.spaceId || n.gmailData?.spaceId || n.id;
  if (sid) {
   const targetSpace = gchatSpaces.find((s) => s.id === sid || s.name === sid);
   if (targetSpace) {
    setGchatSelectedSpace(targetSpace);
   } else {
    setGchatSelectedSpace({ id: sid, name: sid, type: "DIRECT_MESSAGE", displayName: n.senderName });
   }
  }
  return;
 }

 // 2. Trello Handler
 if (n.alt === "Trello" && n.cardData) {
  setCurrentView({ app: "trello", contact: null });
  window.dispatchEvent(new CustomEvent("openTrelloCard", { detail: n.cardData }));
  return;
 }

 // 3. Gmail Inbox Handler (Real API)
 if (n.alt === "Gmail" && n.gmailData) {
  const msg = n.gmailData;
 
  // UI Feedback: Mark read immediately
  setGmailEmails(prev => prev.map(e => e.id === msg.id ? { ...e, isUnread: false } : e));
 
  const isHtml = /<(html|body|div|p|br|b|strong|i|em|a|span|table|style)[^>]*>/i.test(msg.body || "");
  let rawBody = msg.body || msg.snippet || "";
 
  // Logic: Handle plain text newline preservation for instruction emails
  if (!isHtml && rawBody.split('\n').length < 4) {
   rawBody = rawBody
    .replace(/(---------- Forwarded message ---------)/gi, '\n\n$1\n')
    .replace(/(From:|Date:|Subject:|To:|Cc:)/g, '\n$1')
    .replace(/(Dear\s+[A-Za-z]+|Hi\s+[A-Za-z]+|Good\s+day)/gi, '\n\n$1\n\n')
    .replace(/(Kind\s+Regards|Regards|Sincerely|Thank\s+you)/gi, '\n\n$1\n')
    .replace(/(On\s+(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)[^:]+wrote:)/gi, '\n\n$1\n')
    .trim();
  }

  // INTERCEPT DRAFTS: Open editor instead of viewer
  if (msg.labelIds?.includes("DRAFT") || gmailFolder === "DRAFTS") {
   let toEmail = "";
   if (msg.to) {
    const toStr = Array.isArray(msg.to) ? msg.to[0] : msg.to;
    const emailMatch = (typeof toStr === "string" ? toStr : "").match(/<([^>]+)>/);
    toEmail = emailMatch ? emailMatch[1].trim() : (typeof toStr === "string" ? toStr.replace(/"/g, '').trim() : "");
   }

   setSelectedDraftTemplate({
    id: "existing_draft",
    draftId: msg.id,
    label: "Edit Draft",
    subject: msg.subject || "",
    body: (isHtml ? rawBody.replace(/<[^>]+>/g, "") : rawBody) + "\n\n",
    isForward: false
   });
   setDraftTo(toEmail);
  
   if (msg.attachments?.length > 0) {
    Promise.all(msg.attachments.map(async (a) => {
     const fileUrl = `/.netlify/functions/gmail-download?messageId=${msg.id}&attachmentId=${a.id}&filename=${encodeURIComponent(a.name)}&mimeType=${encodeURIComponent(a.mimeType)}`;
     const res = await fetch(fileUrl);
     const blob = await res.blob();
     return new File([blob], a.name, { type: a.mimeType });
    })).then(files => setDraftAttachments(files));
   }

   setEmail(null);
   setCurrentView({ app: "gmail", contact: null });
   return;
  }

  const fromParts = msg.from ? msg.from.split("<") : ["Unknown", ""];
  const fromName = fromParts[0].replace(/"/g, '').trim();
  const fromEmail = fromParts[1] ? "<" + fromParts[1] : "";

  setEmail({
   id: msg.id, subject: msg.subject, fromName, fromEmail,
   to: msg.to,
   date: msg.date,
   isStarred: msg.isStarred,
   time: new Date(msg.date).toLocaleString("en-GB", { day: "numeric", month: "short", hour: "2-digit", minute: "2-digit" }),
   body: isHtml ? "" : rawBody,
   bodyHtml: isHtml ? msg.body : "",
   attachments: msg.attachments ? msg.attachments.map(a => ({
    ...a,
    type: a.mimeType.includes("pdf") ? "pdf" : a.mimeType.includes("image") ? "img" : a.mimeType.includes("spreadsheet") || a.mimeType.includes("excel") ? "xls" : "file",
    url: `/.netlify/functions/gmail-download?messageId=${msg.id}&attachmentId=${a.id}&filename=${encodeURIComponent(a.name)}&mimeType=${encodeURIComponent(a.mimeType)}`
   })) : [],
   actions: [{ key: "submit_trello", label: "Submit to Trello" }, { key: "update_tracker", label: "Update AC Tracker" }]
  });

  setEmailPreview(null);
  setCurrentView({ app: "email", contact: null });
  return;
 }

 // 4. Drive Email Handler (Legacy Data Centre)
 if (n.alt === "Gmail" && n.driveEmail) {
  setCurrentView({ app: "email", contact: null });
  return;
 }
};

  /* dismiss notif */
 const dismissNotification = (n) => {
  // If it's a real Gmail notification, mark it as read in the background
  if (n.alt === "Gmail" && n.gmailData?.id) {
   fetch("/.netlify/functions/gmail-mark-read", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ messageId: n.gmailData.id })
   }).catch(err => console.error("Mark read failed", err));

   // Optimistically update the inbox UI to remove the bold text
   setGmailEmails(prev => prev.map(e => e.id === n.gmailData.id ? { ...e, isUnread: false } : e));
  }

  // Remove from UI (handles both objects and raw IDs just in case)
  const idToRemove = typeof n === "string" ? n : n.id;
  setNotifications((prev) => prev.filter((x) => x.id !== idToRemove));
 };

  /* composer sizing */
  const handleAutoGrow = (ta) => {
    if (!ta) return;
    const maxLines = 10;
    const lh = parseFloat(getComputedStyle(ta).lineHeight || "22");
    const max = lh * maxLines;
    ta.style.height = "auto";
    ta.style.height = Math.min(ta.scrollHeight, max) + "px";
    ta.style.overflowY = ta.scrollHeight > max ? "auto" : "hidden";
    const chatBar = ta.closest(".chat-bar");
    const isExpanded = ta.scrollHeight > lh * 1.6;
    if (chatBar) chatBar.classList.toggle("expanded", isExpanded);
  };

  /* Email actions (real Trello + Tracker + Create Draft) */
const handleEmailAction = (actionKey) => {
  if (!email) return;

  // for now, use a demo Case Card text so you can test end-to-end
  const caseCardText = DEMO_CASE_CARD_TEXT;

  // helper to extract AC REF from subject (used for tracker fallback)
  const extractACRef = (subjectRaw) => {
    const m = (subjectRaw || "").match(/AC REF[:\s]*([A-Z0-9]+)/i);
    return m ? m[1].trim() : "";
  };

  /* SUBMIT TO TRELLO */
  if (actionKey === "submit_trello") {
    const instructionTimeIso = new Date().toISOString(); // now; later you can pass the real email time

    fetch("/.netlify/functions/trello-create-card", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        caseCardText,
        instructionTimeIso,
        fallbackDescription: email.subject || "",
      }),
    })
      .then((res) => res.json())
      .then((json) => {
        if (!json || json.ok === false) {
          console.error("trello-create-card error:", json);
          setEmail((prev) =>
            prev
              ? {
                  ...prev,
                  systemNote:
                    "Tried to submit to Trello but something went wrong. Please check the console.",
                }
              : prev
          );
       } else {
          setEmail((prev) =>
            prev
              ? {
                  ...prev,
                  systemNote: "Submitted to Trello and linked to AC REF.",
                }
              : prev
          );
          //  TRIGGER SNACKBAR
          triggerSnackbar("Submitted to Trello");
        }
      })
      .catch((err) => {
        console.error("trello-create-card fetch failed:", err);
        setEmail((prev) =>
          prev
            ? {
                ...prev,
                systemNote:
                  "Tried to submit to Trello but the request failed. Please check the console.",
              }
            : prev
        );
      });

    return;
  }

  /* UPDATE AC TRACKER (simple, as before) */
  if (actionKey === "update_tracker") {
  //  For now, reuse the Case Card text you already have.
  // Eventually youll plug in the REAL .txt content from Drive.
  const caseCardText = DEMO_CASE_CARD_TEXT; // or whatever you have

  fetch("/.netlify/functions/sheet-update-tracker", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ caseCardText }),
  })
    .then((res) => res.json())
    .then((json) => {
      if (json.ok) {
        setEmail((prev) =>
          prev
            ? {
                ...prev,
                systemNote: "AC Reports Tracker updated for this case.",
              }
            : prev
        );
      } else {
        setEmail((prev) =>
          prev
            ? {
                ...prev,
                systemNote:
                  "Tracker update failed. See console for details.",
              }
            : prev
        );
        console.error("sheet-update-tracker error:", json);
      }
    })
    .catch((err) => {
      console.error("sheet-update-tracker fetch failed:", err);
      setEmail((prev) =>
        prev
          ? { ...prev, systemNote: "Tracker update failed (network error)." }
          : prev
      );
    });

  return;
}

  /* CREATE DRAFT  open the template picker */
  if (actionKey === "create_draft") {
    setShowDraftPicker((v) => !v);
    setSelectedDraftTemplate(null);
    setEmail((prev) =>
      prev
        ? {
            ...prev,
            systemNote: "Choose a draft template below.",
          }
        : prev
    );
    return;
  }

  /* CANCEL */
  setEmail((prev) =>
    prev ? { ...prev, systemNote: "Action cancelled." } : prev
  );
};

  /* send + auto reply (WhatsApp + Google Chat) */
/* src/App.jsx - Improved handleSend */

//  NEW: Voice Note Logic
  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const recorder = new MediaRecorder(stream);
      mediaRecorderRef.current = recorder;
      audioChunksRef.current = [];

      recorder.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunksRef.current.push(e.data);
      };

      recorder.onstop = () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: "audio/mp3" });
        const audioFile = new File([audioBlob], "voice-note.mp3", { type: "audio/mp3" });
        
        // Reuse existing upload logic
        setPendingUpload({ file: audioFile, kind: "file" });
        
        // Stop all tracks to release microphone
        stream.getTracks().forEach(track => track.stop());
      };

      recorder.start();
      setIsRecording(true);
    } catch (err) {
      console.error("Microphone error:", err);
      alert("Could not access microphone.");
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  };

//  UPDATE: Added 'forcedEmail' parameter to allow the Dropdown to bypass state
const handleStartChat = async (forcedEmail = null) => {
    const rawEmail = forcedEmail || newChatTarget || newChatEmailRef.current?.value || "";
    const targetEmail = rawEmail.trim();

    if (!targetEmail) {
      alert("Please enter an email address.");
      return;
    }

    //  LOGIC FIX: Stop the alert if we have a valid email from the dropdown
    if (!targetEmail.includes("@") || !targetEmail.includes(".")) {
      alert("Please enter a full email address (e.g. name@company.co.za).");
      return;
    }
    
    setGchatLoading(true);
    
    try {
      const res = await fetch("/.netlify/functions/gchat-find-gm", {
        method: "POST",
        credentials: "include", 
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: targetEmail })
      });
      
      const json = await res.json().catch(() => ({}));
      
      if (json.ok && json.space) {
        const newSpace = { ...json.space, id: json.space.name };

        const resolvedName = json.displayName || targetEmail;
        setGchatDmNames(prev => {
          const next = { ...prev, [newSpace.id]: resolvedName };
          localStorage.setItem("GCHAT_DM_NAMES", JSON.stringify(next));
          return next;
        });

        setGchatSpaces(prev => {
          const exists = prev.find(s => s.id === newSpace.id);
          return exists ? prev : [newSpace, ...prev];
        });

        setCurrentView({ app: "gchat", contact: null });
        setGchatSelectedSpace(newSpace);
        
        if (newChatEmailRef.current) newChatEmailRef.current.value = "";
        setNewChatTarget("");
        setShowNewChatModal(false); 
        
        lastActiveSpaceRef.current = newSpace;
        localStorage.setItem("LAST_ACTIVE_SPACE_ID", newSpace.id);
      } else {
        alert(json.error || "User not found. Ensure the email is correct.");
      }
    } catch (err) {
      console.error("Initiate chat failed:", err);
      alert("System Error: Could not connect to the chat initiator.");
    } finally {
      setGchatLoading(false);
    }
  };
  
  const handleDeleteGChatMessage = async (messageId) => {
    if (!window.confirm("Delete this message?")) return;
    try {
      // Optimistic delete
      setGchatMessages(prev => prev.filter(m => (m.name || m.id) !== messageId));
      await fetch("/.netlify/functions/gchat-delete-message", {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messageId })
      });
    } catch (err) { console.error("Delete failed", err); }
  };

  const handleUpdateGChatMessage = async (messageId) => {
    if (!editValue.trim()) return;
    try {
      // Optimistic update
      setGchatMessages(prev => prev.map(m => (m.name || m.id) === messageId ? { ...m, text: editValue } : m));
      setEditingMsgId(null);
      await fetch("/.netlify/functions/gchat-update-message", {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messageId, text: editValue })
      });
    } catch (err) { console.error("Update failed", err); }
  };
  
  /* src/App.jsx - Improved handleSend */
  const handleSend = async () => {
  const text = inputValue.trim();
  if (!text && !pendingUpload) return;

  // WhatsApp (Unchanged)
  if (currentView.app === "whatsapp" && currentView.contact) {
    /* ... keep your existing WhatsApp logic here ... */
    const contact = currentView.contact;
    setWaChats((prev) => {
      const list = prev[contact] ? [...prev[contact]] : [];
      list.push({ from: "me", text, time: formatUKTime(new Date()) });
      return { ...prev, [contact]: list };
    });
    setInputValue("");
    // ... auto reply logic ...
    return;
  }

 // Google Chat Logic
  if (currentView.app === "gchat" && gchatSelectedSpace) {
    try {
      let json = {};

      if (pendingUpload) {
        // --- UPLOAD FLOW ---
        const reader = new FileReader();
        reader.readAsDataURL(pendingUpload.file);
        
        await new Promise((resolve, reject) => {
          reader.onload = async () => {
            try {
              const base64Content = reader.result.split(",")[1];
              
              const res = await fetch("/.netlify/functions/gchat-upload", {
                method: "POST",
                credentials: "include", //  MANDATORY
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  space: gchatSelectedSpace.id,
                  text: text, 
                  filename: pendingUpload.file.name,
                  mimeType: pendingUpload.file.type,
                  fileBase64: base64Content
                }),
              });
              
              json = await res.json().catch(() => ({}));
              
              if (!res.ok || !json.ok) {
                console.error("Upload failed:", json);
                alert(`Upload failed: ${json.error || "Unknown error"}`);
                reject(); 
                return;
              }
              
              resolve(); 
            } catch (e) {
              console.error("Reader/Fetch error:", e);
              reject();
            }
          };
        });

        setPendingUpload(null);

     } else {
    // --- TEXT ONLY FLOW ---
    const res = await fetch("/.netlify/functions/gchat-send", {
     method: "POST",
     credentials: "include", //  MANDATORY
     headers: { "Content-Type": "application/json" },
     body: JSON.stringify({
      space: gchatSelectedSpace.id,
      text,
     }),
    });
    json = await res.json().catch(() => ({}));
   }

   if (json.ok && json.message) {
    const me = json.message?.sender?.name;
    if (me && !gchatMe) {
     setGchatMe(me);
     localStorage.setItem("GCHAT_ME", me);
    }
        
        //  FORCE IDENTITY ON OUTGOING MESSAGE IMMEDIATELY
        if (json.message.sender) {
          json.message.sender.displayName = "Siyabonga Nono";
        }
        
    setGchatMessages((prev) => dedupeMergeMessages(prev, [json.message]));
    setInputValue("");
   }

  } catch (err) {
      console.error("gchat-send/upload failed:", err);
      alert("Message failed to send. Check console.");
    }
    
    // Reset height of text box
    const ta = document.querySelector(".chat-textarea");
    if (ta) {
      ta.style.height = "auto";
      ta.style.overflowY = "hidden";
      ta.closest(".chat-bar")?.classList.remove("expanded");
    }
    return;
  }
};

/* middle renderer */
  const middleContent = useMemo(() => {
    // SAFE FILTER LOGIC
    let rawQ = (searchQuery || "").toLowerCase().trim();
    let searchTerms = [];
    
    if (rawQ.includes(':')) {
      searchTerms = []; 
    } else if (rawQ.startsWith('"') && rawQ.endsWith('"') && rawQ.length > 1) {
      searchTerms = [rawQ.slice(1, -1)];
    } else if (rawQ) {
      searchTerms = [rawQ];
    }
    
    //  IMPROVED ACCURACY: If there is a search query, do NOT filter locally.
    // The Gmail API handles the historical search. Local filtering is only for the default Inbox view.
    const filteredEmails = (searchQuery.trim() !== "") 
      ? (gmailEmails || []) 
      : (gmailEmails || []).filter((msg) => {
          if (searchTerms.length === 0) return true;
          const subject = (msg.subject || "").toLowerCase();
          const from = (msg.fromName || msg.fromEmail || msg.from || "").toLowerCase();
          const snippet = (msg.snippet || "").toLowerCase();
          const bodyText = (msg.body || msg.bodyHtml || "").toLowerCase();
          const searchable = `${subject} ${from} ${snippet} ${bodyText}`;
          return searchTerms.every(term => searchable.includes(term));
        });

    const filteredGchatSpaces = (gchatSpaces || []).filter(s => {
      if (searchTerms.length === 0) return true;
      const learnedName = gchatDmNames[s.id] || "";
      const title = (s.type === "DIRECT_MESSAGE" 
        ? (learnedName || s.displayName || "Direct Message") 
        : (s.displayName || "Unnamed")).toLowerCase();
      return searchTerms.every(term => title.includes(term));
    });

    if (currentView.app === "whatsapp" && currentView.contact) {
   const msgs = waChats[currentView.contact] || [];
   return (
    <div className="wa-chat">
     <div className="wa-header">
      <div className="wa-avatar">
       {avatarFor(currentView.contact)
        ? <img src={avatarFor(currentView.contact)} alt={currentView.contact} />
        : <span>{currentView.contact?.slice(0,1)}</span>}
      </div>
      <div className="wa-meta">
       <div className="wa-name">{currentView.contact}</div>
       <div className="wa-status">online</div>
      </div>
     </div>
     <div className="wa-body" ref={waBodyRef}>
      {msgs.map((m, idx) => (
       <div key={idx} className={`wa-msg ${m.from}`}>
        <div className="wa-bubble">
         <div className="wa-text">{m.text}</div>
         <div className="wa-time">
          {m.time}
          {m.from === "me" && <span className="wa-ticks"></span>}
         </div>
        </div>
       </div>
      ))}
     </div>
    </div>
   );
  }

if (currentView.app === "gchat") {
  //  IMPROVED NAME SNIFFER: Explicitly filters out resource IDs
  const otherPersonName = gchatMessages.find((m) => {
    const sName = m.sender?.displayName || "";
    const sEmail = m.sender?.email || "";
    const sId = m.sender?.name || "";

    const isSiya = 
      (!!gchatMe && sId === gchatMe) || 
      sEmail.includes('siya@') ||
      sName.toLowerCase().includes('siya') ||
      sName.toLowerCase().includes('actuaryspace');

    // Return the first sender that is NOT Siya and has a HUMAN name (no users/ prefix)
    return !isSiya && sName && !sName.includes("users/");
  })?.sender?.displayName;
  //  NEW: PREVIEW INTERCEPTOR
    // If a file is selected, return the Preview UI *instead* of the Chat UI
    if (gchatFilePreview) {
      const isImg = ["img", "png", "jpg", "jpeg", "gif", "webp"].includes(gchatFilePreview.type);
      
      //  CORRECT: The URL is already fully constructed in the onClick handler
      const src = gchatFilePreview.url;

      return (
        <div className="gchat-preview-container">
          <div className="gchat-preview-bar">
            <div className="gchat-preview-title">{gchatFilePreview.name}</div>
            <div className="gchat-preview-actions">
              <a href={src} download={gchatFilePreview.name} className="gchat-preview-btn">Download</a>
              <button className="gchat-preview-close" onClick={() => setGchatFilePreview(null)}>
                 Close
              </button>
            </div>
          </div>
          <div className="gchat-preview-body">
            {isImg ? (
              <img src={src} alt="Preview" className="gchat-preview-img" />
            ) : (
              <iframe src={src} title="Preview" className="gchat-preview-frame" />
            )}
          </div>
        </div>
      );
    }

    //  Standard Chat UI (If no preview is active)
    return (
      <div className="gchat-shell" style={{ display: "flex", height: "100%", position: "relative" }}>
        
        {/* Modal Overlay - Centered in Middle Panel */}
        {showNewChatModal && (
          <>
            {/* Backdrop for instant close */}
            <div 
              style={{ position: "fixed", top:0, left:0, width:"100vw", height:"100vh", zIndex: 9998 }}
              onMouseDown={(e) => { e.stopPropagation(); setNewChatTarget(""); setShowNewChatModal(false); }}
            />
            
            <div 
              style={{
                position: "fixed", top: "100px", left: "50%", transform: "translateX(-50%)", width: "600px",
                background: "white", padding: "24px", borderRadius: "12px",
                boxShadow: "0 12px 40px rgba(0,0,0,0.3)", zIndex: 9999, border: "1px solid #dadce0"
              }}
              onClick={(e) => e.stopPropagation()} 
            >
              <div style={{fontWeight:500, marginBottom:12, fontSize:"1rem", color:"#202124"}}>
                Start direct message
              </div>
              
              <div style={{fontSize:".8rem", color:"#5f6368", marginBottom:"4px"}}>
                Add 1 or more people
              </div>
              
             <div style={{ position: "relative" }}>
                <input 
                  ref={newChatEmailRef}
                  autoFocus
                  style={{ width: "100%", padding: "10px 12px", borderRadius: "4px", border: "1px solid #dadce0", marginBottom: "16px", fontSize: "14px", boxSizing: "border-box", outline: "none" }}
                  placeholder="Search by name or enter email..."
                  value={newChatTarget}
                  onChange={(e) => setNewChatTarget(e.target.value)}
                  onKeyDown={e => e.key === "Enter" && handleStartChat()}
                />

                {(newChatTarget || "").length > 0 && !(newChatTarget || "").includes("@") && (
                  <div style={{
                    position: "absolute",
                    top: "42px",
                    left: "0",
                    right: "0",
                    background: "white",
                    border: "1px solid #dadce0",
                    boxShadow: "0 8px 16px rgba(0,0,0,0.15)",
                    zIndex: 9999,
                    maxHeight: "220px",
                    overflowY: "auto",
                    borderRadius: "6px"
                  }}>
                    
{Object.entries(combinedContacts)
  .filter(([name, email]) => 
    name.toLowerCase().includes((newChatTarget || "").toLowerCase()) || 
    email.toLowerCase().includes((newChatTarget || "").toLowerCase())
  )
  .map(([name, email]) => (
    <div 
      key={email}
      //  THE FIX: Auto-fill the email and immediately fire the Start Chat function
      onClick={async (e) => {
  e.preventDefault();
  e.stopPropagation();
  
  // 1. Sync UI
  setNewChatTarget(email);
  if (newChatEmailRef.current) {
    newChatEmailRef.current.value = email;
  }

  // 2.  FORCE FULL EMAIL: Pass the full email directly to the function
  // This skips the state race condition and prevents the "partial email" error alert.
  handleStartChat(email); 
}}
      onMouseEnter={(e) => e.currentTarget.style.background = "#f8f9fa"}
      onMouseLeave={(e) => e.currentTarget.style.background = "transparent"}
      style={{
        padding: "10px 14px",
        cursor: "pointer",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        borderBottom: "1px solid #f1f3f4"
      }}
    >
      <div style={{ display: 'flex', flexDirection: 'column' }}>
        <span style={{ fontWeight: 600, fontSize: "13px", color: "#202124" }}>{name}</span>
        <span style={{ color: "#5f6368", fontSize: "11px" }}>{email}</span>
      </div>
      <div style={{ color: '#0b57d0', fontSize: '11px', fontWeight: 600 }}>Start Chat</div>
    </div>
  ))
}
                    {Object.entries(combinedContacts).filter(([n, e]) => n.toLowerCase().includes((newChatTarget || "").toLowerCase()) || e.toLowerCase().includes((newChatTarget || "").toLowerCase())).length === 0 && (
                      <div style={{ padding: "10px 14px", fontSize: "13px", color: "#5f6368", fontStyle: "italic" }}>
                        No contacts found
                      </div>
                    )}
                  </div>
                )}
              </div>
              
              <div style={{display:"flex", justifyContent:"flex-end", gap:10}}>
                 <button 
                  className="btn ghost" 
                  style={{ borderRadius:4, padding: "6px 12px", color: "#1a73e8", fontWeight: 500, cursor: "pointer", border: "none", background: "transparent" }} 
                  onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); setNewChatTarget(""); setShowNewChatModal(false); }}
                  disabled={gchatLoading}
                >
                  Cancel
                </button>
                <button 
                  className="btn blue" 
                  style={{ borderRadius:4, padding: "6px 16px", background: gchatLoading ? "#9aa0a6" : "#1a73e8", color: "#fff", fontWeight: 500, cursor: "pointer", border: "none" }} 
                  onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); handleStartChat(); }}
                  disabled={gchatLoading}
                >
                  {gchatLoading ? "Starting..." : "Start chat"}
                </button>
              </div>
            </div>
          </>
        )}

      {/* LEFT 1/4  spaces + DMs */}
      <div
        className="gchat-sidebar"
        style={{
          width: "25%",
          borderRight: "1px solid #ddd",
          overflowY: "auto",
          padding: "12px", 
          position: "relative",
          display: "flex",
          flexDirection: "column",
          alignItems: "center"
        }}
        onClick={() => {}}
      >
{/* "Start direct message" Button */}
        <div style={{ width: "100%", paddingBottom: "16px" }}>
          <button 
            style={{ 
              width: "100%",
              padding: "10px 16px",
              borderRadius: "24px", 
              background: "#e3e3e3", 
              color: "#1f1f1f",
              border: "none",
              fontSize: "14px", 
              fontWeight: 500, 
              cursor: "pointer",
              textAlign: "center",
              transition: "background 0.2s ease"
            }}
            onMouseEnter={e => {
              e.currentTarget.style.background = "#d6d6d6";
            }}
            onMouseLeave={e => {
              e.currentTarget.style.background = "#e3e3e3";
            }}
            onMouseDown={(e) => { e.stopPropagation(); setShowNewChatModal(true); }}
          >
            Start direct message
          </button>
        </div>

     {/*  GCHAT SEARCH BAR */}
        <div style={{ width: "100%", marginBottom: "16px", position: "relative", display: "flex", alignItems: "center" }}>
          <svg 
            style={{ position: "absolute", left: "14px", color: "#444746" }}
            width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"
          >
            <circle cx="11" cy="11" r="8"></circle>
            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
          </svg>
          <input 
            type="text" 
            placeholder="Search chat" 
            value={gchatSearchQuery}
            onChange={(e) => setGchatSearchQuery(e.target.value)}
            style={{
              width: "100%",
              padding: "10px 16px 10px 42px",
              borderRadius: "24px",
              border: "none",
              fontSize: "14px",
              outline: "none",
              boxSizing: "border-box",
              background: "#edf2fa",
              color: "#1f1f1f"
            }}
          />
        </div>

        {gchatLoading && <div className="gchat-muted">Loading</div>}
        {gchatError && <div className="gchat-error">{gchatError}</div>}

{!gchatLoading && (() => {
          // 1. Filter based on search query
          const filtered = gchatSpaces.filter((s) => {
            if (!gchatSearchQuery.trim()) return true;
            const search = gchatSearchQuery.toLowerCase();
            const learnedName = gchatDmNames[s.id] || "";
            let title = s.displayName || "Unnamed Space";
            
            if (s.type === "DIRECT_MESSAGE") {
              if (learnedName && learnedName !== "Direct Message" && !learnedName.includes("users/")) title = learnedName;
              else if (s.displayName && !s.displayName.includes("users/")) title = s.displayName;
              else title = "Direct Message";
            }
            return title.toLowerCase().includes(search);
          });

         // 2. Render each item as its own standalone pill
          return (
            <div style={{ display: "flex", flexDirection: "column", gap: "3px", width: "100%", boxSizing: "border-box" }}>
              {filtered.map((s) => {
                const learnedName = gchatDmNames[s.id] || "";
                let title = s.displayName || "Unnamed Space";

                if (s.type === "DIRECT_MESSAGE") {
                   if (learnedName && learnedName !== "Direct Message" && !learnedName.includes("users/")) title = learnedName;
                   else if (s.displayName && !s.displayName.includes("users/")) title = s.displayName;
                   else title = "Direct Message";
                }

                const isActive = gchatSelectedSpace?.id === s.id;

               return (
                  <button
                    key={s.id} 
                    className={`gchat-item ${isActive ? "active" : ""}`} 
                    style={{ 
                      width: "100%", 
                      maxWidth: "100%", 
                      margin: 0,        
                      boxSizing: "border-box",
                      display: "flex", 
                      alignItems: "center",
                      padding: "8px 16px", 
                      textAlign: "left",
                      background: isActive ? "#c2e7ff" : "#f1f3f4", 
                      color: isActive ? "#001d35" : "#202124",
                      border: isActive ? "1px solid #c2e7ff" : "1px solid #dadce0", 
                      cursor: "pointer",
                      borderRadius: "24px", 
                      transition: "all 0.2s",
                      fontSize: "13px"
                    }} 
                    onClick={() => setGchatSelectedSpace(s)}
                    onMouseEnter={e => !isActive && (e.currentTarget.style.background = "#e8eaed")}
                    onMouseLeave={e => !isActive && (e.currentTarget.style.background = "#f1f3f4")}
                  >
                    <div className="gchat-item-text" style={{ overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>
                      <div className="gchat-item-title" style={{ fontWeight: isActive ? "600" : "500" }}>
                        {title}
                      </div>
                    </div>
                  </button>
                );
              })}
            </div>
          );
        })()}
      </div>

      {/* RIGHT 3/4  message thread */}
      <div
        className="gchat-thread"
        style={{
          width: "75%",
          display: "flex",
          flexDirection: "column",
        }}
      >
        <div
     className="gchat-topbar"
     style={{
      borderBottom: "1px solid #ddd",
      padding: "8px",
     }}
    >
 <div className="gchat-top-title">
  {(() => {
    if (!gchatSelectedSpace) return "Select a space";
    if (gchatSelectedSpace.type !== "DIRECT_MESSAGE") return gchatSelectedSpace.displayName || "Unnamed Space";

    const spaceKey = gchatSelectedSpace.id || gchatSelectedSpace.name;
    const cachedName = gchatDmNames[spaceKey] || "";
    
    //  THE IDENTITY FIX: Resolve resource IDs for Bonolo and Repository
    const KNOWN_USERS = {
      "users/109833975621386956073": "Bonolo",
      "users/112422887282158931745": "Repository",
      "users/115863503558522206541": "Yolandie"
    };

    // 1. Prioritize internal ID map (Fixes Yolandie -> Repository and Jonathan -> Bonolo)
    if (KNOWN_USERS[cachedName]) return KNOWN_USERS[cachedName];
    if (KNOWN_USERS[otherPersonName]) return KNOWN_USERS[otherPersonName];
    if (KNOWN_USERS[gchatSelectedSpace.displayName]) return KNOWN_USERS[gchatSelectedSpace.displayName];

    // 2. Fallback to learned human names
    if (cachedName && cachedName !== "Direct Message" && !cachedName.includes("users/")) return cachedName;
    if (otherPersonName && !otherPersonName.includes("users/")) return otherPersonName;

    return gchatSelectedSpace.displayName && !gchatSelectedSpace.displayName.includes("users/") 
      ? gchatSelectedSpace.displayName 
      : "Direct Message";
  })()}
</div>
    </div>

        <div
          className="gchat-thread-body"
          ref={gchatBodyRef}
          onScroll={() => {
            const el = gchatBodyRef.current;
            if (!el) return;

            const atBottom =
              el.scrollHeight - el.scrollTop - el.clientHeight < 40;

            setGchatAutoScroll(atBottom);
          }}
          style={{
            flex: 1,
            overflowY: "auto",
            padding: "12px"
          }}
        >
          {/*  UPDATED: Text removed */}
          {!gchatSelectedSpace && null}

          {gchatSelectedSpace && (
            <>
              {gchatMsgLoading && <div className="gchat-muted">Loading messages</div>}
              {gchatMsgError && <div className="gchat-error">{gchatMsgError}</div>}

              {!gchatMsgLoading && !gchatMsgError && (
        <div className="gchat-msg-list">
         {/*  PAGINATION BUTTON: Appears only if older messages exist */}
         {gchatNextPageToken && (
          <div style={{ textAlign: 'center', padding: '10px 0' }}>
           <button
            className="t-btn-gray"
            style={{ fontSize: '13px', borderRadius: '20px', opacity: gchatLoadingOlder ? 0.6 : 1 }}
            disabled={gchatLoadingOlder} //  Prevent double-clicking
            onClick={async (e) => {
             e.stopPropagation();
             setGchatLoadingOlder(true); //  Start loading
             try {
              const res = await fetch(`/.netlify/functions/gchat-messages?space=${encodeURIComponent(gchatSelectedSpace.id)}&pageToken=${gchatNextPageToken}`, { credentials: "include" });
              const json = await res.json();
              if (json.ok) {
               const older = (json.messages || []).map(normalizeGChatMessage);
               setGchatMessages(prev => dedupeMergeMessages(older, prev));
               setGchatNextPageToken(json.nextPageToken || null);
              }
             } catch (err) { console.error("Load older failed", err); }
             setGchatLoadingOlder(false); //  Stop loading
            }}
           >
            {gchatLoadingOlder ? "Loading older messages..." : "Load older messages"}
           </button>
          </div>
         )}

         {/*  AUTHENTIC CONVERSATION START HEADER (Replica of Screenshot 23) */}
                  {!gchatNextPageToken && !gchatMsgLoading && gchatSelectedSpace && (
                    <div style={{ 
                      display: 'flex', 
                      flexDirection: 'column', 
                      alignItems: 'center', 
                      padding: '48px 20px 0px 20px', 
                      textAlign: 'center'
                    }}>
                      {/*  Large Avatar */}
                      <div style={{ width: '80px', height: '80px', borderRadius: '50%', marginBottom: '12px', overflow: 'hidden', background: '#f1f3f4', display: 'grid', placeItems: 'center' }}>
                        {(() => {
                          const name = gchatDmNames[gchatSelectedSpace.id] || gchatSelectedSpace.displayName || "C";
                          const img = avatarFor(name);
                          return img ? <img src={img} style={{ width: '100%', height: '100%', objectFit: 'cover' }} /> : <span style={{ fontSize: '32px', fontWeight: '500', color: '#5f6368' }}>{name[0].toUpperCase()}</span>;
                        })()}
                      </div>

                      {/*  Name & Email Block */}
                      {(() => {
                        const name = gchatDmNames[gchatSelectedSpace.id] || gchatSelectedSpace.displayName || "Direct Message";
                        //  FIX: Use the combinedContacts lookup with the cleaned name
                        const emailAddress = combinedContacts[name] || AC_EMAIL_MAP[name]; 
                        return (
                          <>
                            <div style={{ fontSize: '22px', fontWeight: '500', color: '#1f1f1f', marginBottom: '4px', fontFamily: "'Google Sans', Roboto, Arial, sans-serif" }}>{name}</div>
                            {emailAddress && <div style={{ fontSize: '14px', color: '#444746', marginBottom: '4px' }}>{emailAddress}</div>}
                            <div style={{ fontSize: '14px', color: '#444746', marginBottom: '24px' }}>{getGchatTimezone()}</div>
                            
                            {/*  Creation Milestone (Moved ABOVE the box) */}
                            <div style={{ fontSize: '13.5px', color: '#1f1f1f', marginBottom: '24px' }}>
                              {gchatSelectedSpace.createTime 
                                ? `You created this chat on ${formatLongDate(gchatSelectedSpace.createTime)}.` 
                                : `This is the very beginning of your direct message history with ${name}.`}
                            </div>
                            
                            {/*  HISTORY STATUS BOX (Material Style) */}
                            <div style={{ 
                              display: 'flex', 
                              alignItems: 'center', 
                              gap: '12px', 
                              background: '#f8f9fa', 
                              padding: '12px 16px', 
                              borderRadius: '8px', 
                              textAlign: 'left',
                              maxWidth: '400px',
                              width: 'fit-content',
                              marginBottom: '40px',
                              border: '1px solid #f1f3f4'
                            }}>
                              <div style={{ color: '#444746', display: 'flex' }}>
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                              </div>
                              <div style={{ display: 'flex', flexDirection: 'column' }}>
                                <div style={{ fontSize: '11px', fontWeight: '700', color: '#1f1f1f', letterSpacing: '0.8px', textTransform: 'uppercase' }}>History is on</div>
                                <div style={{ fontSize: '13px', color: '#444746' }}>Messages are saved.</div>
                              </div>
                            </div>

                            {/*  STANDALONE DATE DIVIDER (Full Width Border) */}
                            <div style={{ 
                              width: '100%', 
                              display: 'flex', 
                              alignItems: 'center', 
                              justifyContent: 'center', 
                              margin: '10px 0 30px 0',
                              position: 'relative'
                            }}>
                              <div style={{ position: 'absolute', width: '100%', height: '1px', background: '#f1f3f4', zIndex: 1 }}></div>
                              <div style={{ 
                                fontSize: '11px', 
                                fontWeight: '700', 
                                color: '#444746', 
                                padding: '0 16px', 
                                background: '#fff', 
                                position: 'relative', 
                                zIndex: 2,
                                textTransform: 'uppercase',
                                letterSpacing: '0.4px'
                              }}>
                                {gchatMessages.length > 0 
                                  ? formatDividerDate(gchatMessages[0].createTime) 
                                  : formatDividerDate(new Date().toISOString())}
                              </div>
                            </div>
                          </>
                        );
                      })()}
                    </div>
                  )}
         {/*  PERMANENT SIYA LOCK: Siya (Right) vs Others (Left). Reactions & Hover preserved. */}
                  {gchatMessages.map((m, idx) => {
                    const msg = normalizeGChatMessage(m);
                    const rawName = msg?.sender?.displayName || "";
                    const spaceKey = gchatSelectedSpace?.id || gchatSelectedSpace?.name || "";
                    const cachedName = gchatDmNames[spaceKey] || "";

                    //  CHECK IF IT'S MINE BEFORE ASSIGNING A NAME
                    const isMine = (!!gchatMe && msg?.sender?.name === gchatMe) || 
                                   (msg?.sender?.email === 'siya@actuaryspace.co.za') ||
                                   (msg?.sender?.email === 'siya@actuaryconsulting.co.za') ||
                                   (rawName.toLowerCase().includes("siya")) ||
                                   (rawName.toLowerCase().includes("actuaryspace"));

                    //  ENFORCE CORRECT NAME (FALLBACK CHAIN)
let senderName = "Colleague";
const senderId = msg?.sender?.name || ""; // The unique resource ID

//  THE IDENTITY FIX: Prioritize ID resolution for Bonolo and Repository
const KNOWN_USERS = {
  "users/109833975621386956073": "Bonolo Mokatse",
  "users/112422887282158931745": "Repository",
  "users/115863503558522206541": "Yolandie"
};

const isDriveMsg = msg?.sender?.type === "BOT" || (msg?.text && msg.text.includes("shared ") && msg.text.includes(" with you"));

if (KNOWN_USERS[senderId]) {
  senderName = KNOWN_USERS[senderId]; // Fixed identities resolved first
} else if (isDriveMsg) {
  senderName = "Google Drive";
} else if (isMine) {
  senderName = "Siyabonga Nono";
} else if (rawName && !rawName.includes("users/")) {
  senderName = rawName;
} else if (cachedName && !cachedName.includes("users/") && cachedName !== "Direct Message") {
  senderName = cachedName;
} else if (gchatSelectedSpace?.displayName && !gchatSelectedSpace.displayName.includes("users/") && gchatSelectedSpace.displayName !== "Direct Message") {
  senderName = gchatSelectedSpace.displayName;
}

                    const msgId = msg?.name || msg?.id || `msg-${idx}`;
                    const avatar = isDriveMsg ? "https://ssl.gstatic.com/images/branding/product/1x/drive_2020q4_48dp.png" : avatarFor(senderName);

          const hasAttachment = msg.attachment && msg.attachment.length > 0;
                    const fileData = hasAttachment ? msg.attachment[0] : null;
                    const fileName = fileData?.contentName || fileData?.name || "Attachment";
                    const ext = fileName.split(".").pop().toLowerCase();
                    
                    const isVideo = ["mp4", "webm", "ogg", "mov"].includes(ext);
                    const isAudio = ["mp3", "wav", "m4a", "aac"].includes(ext);

                    let fileType = "FILE";
                    let iconClass = "default";
                    if (ext === "pdf") { fileType = "PDF"; iconClass = "pdf"; }
                    else if (["png", "jpg", "jpeg", "gif", "webp"].includes(ext)) { fileType = "IMG"; iconClass = "img"; }
                    else if (["xls", "xlsx", "csv"].includes(ext)) { fileType = "XLS"; iconClass = "xls"; }
                    else if (["doc", "docx"].includes(ext)) { fileType = "DOC"; iconClass = "doc"; }

                    return (
                      <div
            key={msgId}
            className={`gchat-msg ${isMine ? "mine" : "theirs"}`}
            style={{
             position: "relative",
             display: "flex",
             width: "100%",
             //  ALIGNMENT ANCHOR 1: Row-level force
             justifyContent: isMine ? "flex-end" : "flex-start",
             marginBottom: "12px",
             gap: "8px"
            }}
           >
            {!isMine && (
             <div className="gchat-avatar-circle" style={{ alignSelf: 'flex-start', flexShrink: 0 }}>
              {avatar ? <img src={avatar} alt={senderName} /> : <span>{senderName.slice(0, 1).toUpperCase()}</span>}
             </div>
            )}

            <div
             className="gchat-msg-content group"
                          onMouseEnter={() => setHoveredMsgId(msgId)}
                          onMouseLeave={() => setHoveredMsgId(null)}
             style={{
              display: "flex",
              flexDirection: "column",
              //  ALIGNMENT ANCHOR 2: Content-level force
              alignItems: isMine ? "flex-end" : "flex-start",
              position: "relative",
              maxWidth: "75%",
              marginLeft: isMine ? "auto" : "0", //  Magnetic pull to right
              marginRight: isMine ? "0" : "auto"
             }}
            >
                          {/*  UNIVERSAL HOVER ACTION BAR (Reactions + Edit + Delete) */}
                          {hoveredMsgId === msgId && !editingMsgId && (
                            <div className="gchat-hover-actions" style={{
                              position: 'absolute', top: '-22px', [isMine ? 'right' : 'left']: '0px',
                              background: 'white', border: '1px solid #dadce0', borderRadius: '24px',
                              display: 'flex', gap: '8px', padding: '4px 14px', boxShadow: '0 2px 8px rgba(0,0,0,0.15)', zIndex: 100
                            }}>
                              <button title="Like" onClick={(e) => { e.stopPropagation(); toggleReaction(msgId, "like"); }} style={{border:'none', background:'none', cursor:'pointer', fontSize: '16px'}}></button>
                              <button title="Heart" onClick={(e) => { e.stopPropagation(); toggleReaction(msgId, "heart"); }} style={{border:'none', background:'none', cursor:'pointer', fontSize: '16px'}}></button>
                              <button title="Laugh" onClick={(e) => { e.stopPropagation(); toggleReaction(msgId, "laugh"); }} style={{border:'none', background:'none', cursor:'pointer', fontSize: '16px'}}></button>
                              {isMine && (
                                <button title="Edit" onClick={(e) => { e.stopPropagation(); setEditingMsgId(msgId); setEditValue(msg.text || ""); }} style={{border:'none', background:'none', cursor:'pointer', color:'#5f6368', display: 'grid', placeItems: 'center'}}>
                                  <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                                </button>
                              )}
                              <button title="Delete" onClick={() => handleDeleteGChatMessage(msgId)} style={{border:'none', background:'none', cursor:'pointer', color:'#d93025', display: 'grid', placeItems: 'center'}}>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                              </button>
                            </div>
                          )}
                          <div className="gchat-meta" style={{ textAlign: isMine ? "right" : "left", width: "100%" }}>
                            {!isMine && <strong style={{ marginRight: '8px' }}>{senderName}</strong>}
                            <span className="gchat-time" style={{ marginLeft: isMine ? "0" : "8px", marginRight: isMine ? "8px" : "0" }}>
                              {formatGchatTime(msg?.createTime)}
                            </span>
                          </div>

                          {editingMsgId === msgId ? (
                            <div style={{ width: '100%', background: '#f1f3f4', padding: '8px', borderRadius: '12px', border: '1px solid #dadce0', minWidth: '300px' }}>
                              <textarea 
                                autoFocus
                                value={editValue} 
                                onChange={e => setEditValue(e.target.value)}
                                style={{ width: '100%', border: '1px solid #dadce0', borderRadius: '4px', padding: '10px', fontSize: '14px', outline: 'none', minHeight: '60px', fontFamily: 'inherit' }}
                              />
                              <div style={{ display: 'flex', gap: '8px', marginTop: '8px', justifyContent: 'flex-end' }}>
                                <button onClick={() => setEditingMsgId(null)} style={{ background: 'transparent', border: 'none', color: '#5f6368', cursor: 'pointer', fontSize: '13px', fontWeight: 500 }}>Cancel</button>
                                <button onClick={() => handleUpdateGChatMessage(msgId)} style={{ background: '#0b57d0', border: 'none', color: 'white', cursor: 'pointer', fontSize: '13px', fontWeight: 500, padding: '4px 16px', borderRadius: '16px' }}>Save</button>
                              </div>
                            </div>
                          ) : (
                            <div className="gchat-bubble" style={{ position: "relative", textAlign: 'left' }}>
                              {hasAttachment && (
                                <div style={{ marginBottom: msg?.text ? "8px" : "0" }}>
                                  <div className="gchat-file-card" onClick={(e) => {
                                    e.stopPropagation();
                                    const finalUrl = fileData?.attachmentDataRef?.resourceName ? `/.netlify/functions/gchat-download?uri=api:${fileData.attachmentDataRef.resourceName}` : fileData?.downloadUri;
                                    const isViewable = ["pdf", "png", "jpg", "jpeg", "gif", "webp"].includes(ext);
                                    if (isViewable) { setGchatFilePreview({ name: fileName, url: finalUrl, type: iconClass }); }
                                    else { window.open(finalUrl, '_blank'); }
                                  }}>
                                    <div className={`gchat-file-icon ${iconClass}`}>{fileType}</div>
                                    <div className="gchat-file-info"><div className="gchat-file-name">{fileName}</div></div>
                                  </div>
                                </div>
                              )}
                              {(msg?.text || msg?.formattedText) && formatChatText(msg?.text || msg?.formattedText)}
                            </div>
                          )}
                          
                          {/* Reaction Chips Row */}
             {Array.isArray(reactions[msgId]) && reactions[msgId].length > 0 && (
              <div style={{ marginTop: 4, display: "flex", gap: 4 }}>
               {reactions[msgId].map((r) => (
                <button key={r} onClick={(e) => { e.stopPropagation(); toggleReaction(msgId, r); }} className="gchat-reaction-chip-btn">
                 {r === "like" ? " 1" : r === "heart" ? " 1" : " 1"}
                </button>
               ))}
              </div>
             )}
            </div>
           </div>
          );
                  })}
                </div>
              )}
            </>
          )}
        </div>
      </div>

    </div>
  );
}

if (currentView.app === "gmail") {
    const allSelected = (filteredEmails || []).length > 0 && selectedEmailIds.size === filteredEmails.length;

    const toggleSelectAll = () => {
      if (allSelected) setSelectedEmailIds(new Set());
      else setSelectedEmailIds(new Set(filteredEmails.map(e => e.id)));
    };

    const handleDeleteSelected = async () => {
      const snapshotIds = Array.from(selectedEmailIds);
      if (snapshotIds.length === 0) return;
      
      const isPerm = gmailFolder === "TRASH";
      const countToRemove = snapshotIds.length;
      
      // 1. OPTIMISTIC COUNT REDUCTION: Subtract from the total immediately
      setGmailTotal(prev => Math.max(0, prev - countToRemove));
      setGmailLoading(true);
      
      try {
        const bulkResponse = await fetch("/.netlify/functions/gmail-delete-bulk", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messageIds: snapshotIds, permanent: isPerm })
        });

        const bulkResult = await bulkResponse.json().catch(() => ({ ok: bulkResponse.ok }));

        if (bulkResponse.ok && bulkResult.ok) {
          setSelectedEmailIds(new Set());
          setGmailEmails([]); 
          setGmailRefreshTrigger(p => p + 1);
          
          triggerSnackbar(
            isPerm ? `${countToRemove} item(s) permanently deleted.` : `${countToRemove} conversation(s) moved to Trash.`,
            isPerm ? null : { type: "delete", ids: snapshotIds }
          );
          
          window.dispatchEvent(new CustomEvent("notify", { 
            detail: { 
              text: isPerm ? `${countToRemove} item(s) permanently deleted` : `${countToRemove} item(s) moved to Trash`, 
              alt: "Gmail", 
              icon: gmailIcon 
            } 
          }));
        } else {
          // Revert count on error
          setGmailTotal(prev => prev + countToRemove);
          setGmailLoading(false);
          alert(`Error: ${bulkResult.error || "Server failed to process request"}`);
        }
      } catch (e) { 
        setGmailTotal(prev => prev + countToRemove);
        console.error("Delete handler error:", e);
        setGmailLoading(false);
        alert("Action failed.");
      }
    };

    return (
            <div style={{ position: "relative", display: "flex", flexDirection: "column", height: "100%", background: "#fff", borderRadius: "12px", border: "1px solid #e6e6e6", overflow: "hidden" }}>
              
              {/*  TOP ROW: COMPOSE + SEARCH BAR */}
              <div style={{ padding: "12px 16px", background: "#fff", borderBottom: "1px solid #eee", display: "flex", alignItems: "center", gap: "16px" }}>
                <button 
                  className="btn blue" 
                  onClick={() => {
                    setEmail(null);
                    setEmailPreview(null);
                    setSelectedDraftTemplate({ ...DRAFT_TEMPLATES.find(t => t.id === "new_blank") });
                    setDraftTo("");
                    setDraftAttachments([]);
                  }}
                  onMouseDown={(e) => {
                    e.currentTarget.style.background = "#c2e7ff";
                    e.currentTarget.style.boxShadow = "inset 0 1px 2px rgba(0,0,0,0.1)";
                  }}
                  onMouseUp={(e) => {
                    e.currentTarget.style.background = "#fff";
                    e.currentTarget.style.boxShadow = "0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15)";
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = "#f8f9fa";
                    e.currentTarget.style.boxShadow = "0 1px 3px 0 rgba(60,64,67,0.30), 0 4px 8px 3px rgba(60,64,67,0.15)";
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = "#fff";
                    e.currentTarget.style.boxShadow = "0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15)";
                  }}
                  style={{ 
                    borderRadius: "16px", 
                    padding: "10px 24px", 
                    fontSize: "14px", 
                    fontWeight: 500, 
                    display: "flex", 
                    alignItems: "center", 
                    gap: "12px",
                    background: "#fff", /*  Default light state */
                    color: "#444746",
                    border: "none",
                    boxShadow: "0 1px 2px 0 rgba(60,64,67,0.30), 0 1px 3px 1px rgba(60,64,67,0.15)", /* Standard Gmail FAB shadow */
                    flexShrink: 0,
                    transition: "all 0.1s ease"
                  }}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                  Compose
                </button>

                <div style={{ position: "relative", flex: 1 }}>
                  <input
                    type="text"
                    placeholder="Search in mail..."
                    value={searchQuery}
                    onChange={(e) => {
                      setSearchQuery(e.target.value);
                      setGmailPage(1);
                    }}
                    style={{
                      width: "100%",
                      padding: "10px 12px 10px 44px",
                      borderRadius: "24px",
                      border: "none",
                      fontSize: "15px",
                      outline: "none",
                      background: "#f1f3f4"
                    }}
                  />
                  <svg style={{ position: "absolute", left: "16px", top: "50%", transform: "translateY(-50%)", color: "#5f6368" }} width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                </div>
              </div>

              {/*  SECOND ROW: SELECT ALL + NAV PILLS + PAGINATION */}
              <div style={{ padding: "8px 16px", borderBottom: "1px solid #eee", background: "#fff", display: "flex", alignItems: "center", minHeight: "48px", gap: "16px" }}>
                
                {/* 1. Select All Box */}
                <div style={{ display: "flex", alignItems: "center", width: "40px", justifyContent: "center", flexShrink: 0 }}>
                  <input type="checkbox" checked={allSelected} onChange={toggleSelectAll} style={{ cursor: "pointer", width: "18px", height: "18px" }} />
                </div>

                {/* 2. Selection Count & Bulk Actions */}
                {selectedEmailIds.size > 0 ? (
                  <div style={{ display: "flex", alignItems: "center", gap: "12px", flex: 1 }}>
                    <span style={{ fontSize: "14px", color: "#202124", fontWeight: 500 }}>
                      {selectedEmailIds.size} selected
                    </span>
                    
                    <div style={{ display: "flex", alignItems: "center", gap: "8px", borderLeft: "1px solid #dadce0", paddingLeft: "12px" }}>
                      {/* MOVE TO TRASH / PERMANENT DELETE */}
                      <button 
                        onClick={handleDeleteSelected} 
                        title={gmailFolder === "TRASH" ? "Delete permanently" : "Move to Trash"}
                        style={{ background: "transparent", border: "none", cursor: "pointer", color: "#5f6368", padding: "6px", borderRadius: "50%", display: "grid", placeItems: "center" }}
                        onMouseEnter={e => e.currentTarget.style.background = "#f1f3f4"}
                        onMouseLeave={e => e.currentTarget.style.background = "transparent"}
                      >
                        <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                      </button>

                      {/* RESTORE BUTTON (Only shows in Trash) */}
                      {gmailFolder === "TRASH" && (
                  <button 
                    onClick={async () => {
                      const snapshotIds = Array.from(selectedEmailIds);
                      setGmailLoading(true);
                      try {
                        const res = await fetch("/.netlify/functions/gmail-delete-bulk", {
                          method: "POST",
                          headers: { "Content-Type": "application/json" },
                          body: JSON.stringify({ messageIds: snapshotIds, restore: true })
                        });
                        if (res.ok) {
                          setSelectedEmailIds(new Set());
                          setGmailEmails([]);
                          setGmailRefreshTrigger(p => p + 1);
                          //  Trigger "Action completed" Snackbar with Undo info
                          triggerSnackbar(
                            `${snapshotIds.length} conversation(s) restored to Inbox.`,
                            { type: "restore", ids: snapshotIds }
                          );
                        }
                      } catch (e) { console.error(e); }
                      setGmailLoading(false);
                    }}
                          title="Restore to Inbox"
                          style={{ background: "transparent", border: "none", cursor: "pointer", color: "#5f6368", padding: "6px", borderRadius: "50%", display: "grid", placeItems: "center" }}
                          onMouseEnter={e => e.currentTarget.style.background = "#f1f3f4"}
                          onMouseLeave={e => e.currentTarget.style.background = "transparent"}
                        >
                          <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/></svg>
                        </button>
                      )}
                    </div>
                  </div>
                ) : (
                  /* 3. Navigation Pills Group (Shows when nothing is selected) */
                  <div style={{ display: "flex", alignItems: "center", gap: "4px" }}>
                    <button
                      onClick={() => { 
                        setGmailEmails([]); 
                        setGmailRefreshTrigger(p => p + 1); 
                        setGmailFolder("INBOX"); 
                        setGmailPage(1); 
                        setSelectedEmailIds(new Set()); 
                      }}
                      style={{ height: "32px", padding: "0 16px", borderRadius: "100px", fontSize: "14px", fontWeight: 500, cursor: "pointer", background: gmailFolder === "INBOX" ? "#c2e7ff" : "transparent", color: gmailFolder === "INBOX" ? "#001d35" : "#444746", border: "none", display: "flex", alignItems: "center", gap: "10px" }}
                    >
                      {gmailFolder === "INBOX" ? <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5v-3h3.56c.69 1.19 1.97 2 3.44 2s2.75-.81 3.44-2H19v3zm0-5h-4.99c0 1.1-.9 2-2 2s-2-.9-2-2H5V5h14v9z"/></svg> : <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M22 12h-6l-2 3h-4l-2-3H2"></path><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path></svg>}
                      <span>Inbox</span>
                    </button>

                    <button
                      onClick={() => { 
                        setGmailEmails([]); 
                        setGmailRefreshTrigger(p => p + 1); 
                        setGmailFolder("STARRED"); 
                        setGmailPage(1); 
                        setSelectedEmailIds(new Set()); 
                      }}
                      style={{ height: "32px", padding: "0 16px", borderRadius: "100px", fontSize: "14px", fontWeight: 500, cursor: "pointer", background: gmailFolder === "STARRED" ? "#c2e7ff" : "transparent", color: gmailFolder === "STARRED" ? "#001d35" : "#444746", border: "none", display: "flex", alignItems: "center", gap: "10px" }}
                    >
                      {gmailFolder === "STARRED" ? <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg> : <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>}
                      <span>Starred</span>
                    </button>

                    <button
                      onClick={() => { 
                        setGmailEmails([]); 
                        setGmailRefreshTrigger(p => p + 1); 
                        setGmailFolder("SENT"); 
                        setGmailPage(1); 
                        setSelectedEmailIds(new Set()); 
                      }}
                      style={{ height: "32px", padding: "0 16px", borderRadius: "100px", fontSize: "14px", fontWeight: 500, cursor: "pointer", background: gmailFolder === "SENT" ? "#c2e7ff" : "transparent", color: gmailFolder === "SENT" ? "#001d35" : "#444746", border: "none", display: "flex", alignItems: "center", gap: "10px" }}
                    >
                      {gmailFolder === "SENT" ? <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg> : <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>}
                      <span>Sent</span>
                    </button>

                    <button
                      onClick={() => { 
                        setGmailEmails([]); 
                        setGmailRefreshTrigger(p => p + 1); 
                        setGmailFolder("DRAFTS"); 
                        setGmailPage(1); 
                        setSelectedEmailIds(new Set()); 
                      }}
                      style={{ height: "32px", padding: "0 16px", borderRadius: "100px", fontSize: "14px", fontWeight: 500, cursor: "pointer", background: gmailFolder === "DRAFTS" ? "#c2e7ff" : "transparent", color: gmailFolder === "DRAFTS" ? "#001d35" : "#444746", border: "none", display: "flex", alignItems: "center", gap: "10px" }}
                    >
                      {gmailFolder === "DRAFTS" ? <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg> : <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>}
                      <span>Drafts</span>
                    </button>

                    <button
                      onClick={() => { 
                        setGmailEmails([]); 
                        setGmailRefreshTrigger(p => p + 1); 
                        setGmailFolder("TRASH"); 
                        setGmailPage(1); 
                        setSelectedEmailIds(new Set()); 
                      }}
                      style={{ height: "32px", padding: "0 16px", borderRadius: "100px", fontSize: "14px", fontWeight: 500, cursor: "pointer", background: gmailFolder === "TRASH" ? "#c2e7ff" : "transparent", color: gmailFolder === "TRASH" ? "#001d35" : "#444746", border: "none", display: "flex", alignItems: "center", gap: "10px" }}
                    >
                      {gmailFolder === "TRASH" ? <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg> : <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>}
                      <span>Trash</span>
                    </button>
                  </div>
                )}

        {/* 4. Reload & Pagination (Pinned to right) */}
                <div style={{ display: "flex", alignItems: "center", gap: "12px", color: "#5f6368", fontSize: "13px", marginLeft: "auto", marginRight: "4px" }}>
                  
                  {/*  RELOAD BUTTON */}
                  <button 
                    onClick={() => {
                      setGmailEmails([]); 
                      setGmailRefreshTrigger(p => p + 1); 
                    }}
                    title="Refresh"
                    style={{ 
                      background: "transparent", 
                      border: "none", 
                      cursor: "pointer", 
                      color: "#5f6368", 
                      padding: "6px", 
                      borderRadius: "50%", 
                      display: "grid", 
                      placeItems: "center",
                      transition: "background 0.2s" 
                    }}
                    onMouseEnter={e => e.currentTarget.style.background = "#f1f3f4"}
                    onMouseLeave={e => e.currentTarget.style.background = "transparent"}
                  >
                    <svg width="18" height="18" viewBox="0 0 24 24">
                      <path fill="currentColor" d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                    </svg>
                  </button>

                {(() => {
    const isSearching = !!searchQuery.trim();
    const hasNextPage = !!gmailPageTokens[gmailPage + 1];
    
    //  STABLE MATH: Use the page number to lock the range so it never jumps to 0
    const startIndex = (gmailPage - 1) * 50 + 1;
    const visibleCount = filteredEmails.length;
    
    // If we are loading, we assume the page will be full (50), otherwise use actual count
    const endIndex = (gmailLoading || visibleCount === 0) 
        ? (gmailPage * 50) 
        : (startIndex + visibleCount - 1);
    
    let displayTotal = "";

    //  THE FLICKER SHIELD
    if (isSearching) {
        //  If loading starts, we IMMEDIATELY force "many"
        // This stops the split-second window where the old 'gmailTotal' (500) could render.
        if (gmailLoading) {
            displayTotal = "many";
        } else if (hasNextPage) {
            displayTotal = "many";
        } else {
            displayTotal = gmailTotal > 0 ? gmailTotal.toLocaleString() : endIndex.toLocaleString();
        }
    } else {
        // Folder View (Inbox/Sent/etc)
        // If loading, keep the old number. If not loading, show the current gmailTotal.
        displayTotal = (gmailTotal > 0) ? gmailTotal.toLocaleString() : "...";
    }

    const paginationText = `${startIndex}${endIndex} of ${displayTotal}`;
    const isNextDisabled = !hasNextPage;

    return (
      <>
        <span style={{ userSelect: 'none', fontSize: "13px", color: "#5f6368" }}>{paginationText}</span>
        <div style={{ display: "flex", alignItems: "center" }}>
          <button 
            onClick={() => { 
              //  FORCE LOADING STATE IMMEDIATELY
              setGmailLoading(true); 
              setGmailEmails([]); 
              setGmailPage(p => Math.max(1, p - 1)); 
            }} 
            disabled={gmailPage === 1 || gmailLoading} 
            title="Newer"
            style={{ background: "transparent", border: "none", cursor: (gmailPage === 1 || gmailLoading) ? "default" : "pointer", color: (gmailPage === 1 || gmailLoading) ? "#c1c7d0" : "#5f6368", padding: "4px", borderRadius: "50%" }}
          >
            <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
          </button>
          <button 
            onClick={() => { 
              //  FORCE LOADING STATE IMMEDIATELY
              setGmailLoading(true);
              setGmailEmails([]); 
              setGmailPage(p => p + 1); 
            }} 
            disabled={isNextDisabled || gmailLoading} 
            title="Older"
            style={{ background: "transparent", border: "none", cursor: (isNextDisabled || gmailLoading) ? "default" : "pointer", color: (isNextDisabled || gmailLoading) ? "#c1c7d0" : "#5f6368", padding: "4px", borderRadius: "50%" }}
          >
            <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
          </button>
        </div>
      </>
    );
})()}
                </div>
              </div>

     {/* Body */}
    <div style={{ flex: 1, overflowY: "auto", padding: "0" }}>
     {gmailLoading && <div style={{ padding: "16px", color: "#5f6368" }}>Loading inbox...</div>}
     {gmailError && <div style={{ padding: "16px", color: "#ea4335" }}>Error: {gmailError}</div>}
    
     {!gmailLoading && !gmailError && filteredEmails.length === 0 && (
      <div style={{ padding: "16px", color: "#5f6368", textAlign: "center", marginTop: "20px" }}>No matching emails found.</div>
     )}

{!gmailLoading && !gmailError && filteredEmails.map((msg, i) => (
            <div 
              key={msg.id || i}
              style={{ 
                display: "flex", 
                padding: "10px 16px", 
                borderBottom: "1px solid #f1f3f4",
                cursor: "pointer",
                background: selectedEmailIds.has(msg.id) ? "#e8f0fe" : (msg.isUnread ? "#ffffff" : "#f2f6fc"),
                fontWeight: msg.isUnread ? 700 : 400,
                alignItems: "center",
                gap: "12px",
                fontSize: "14px"
              }}
              onMouseEnter={(e) => e.currentTarget.style.boxShadow = "inset 1px 0 0 #dadce0, inset -1px 0 0 #dadce0, 0 1px 2px 0 rgba(60,64,67,.3)"}
              onMouseLeave={(e) => e.currentTarget.style.boxShadow = "none"}
              onClick={() => {
                setGmailEmails(prev => prev.map(e => e.id === msg.id ? { ...e, isUnread: false } : e));
                if (msg.isUnread) {
                  fetch("/.netlify/functions/gmail-mark-read", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ messageId: msg.id })
                  }).catch(err => console.error("Mark read failed", err));
                }
                const fromParts = msg.from ? msg.from.split("<") : ["Unknown", ""];
                const fromName = fromParts[0].replace(/"/g, '').trim();
                const fromEmail = fromParts[1] ? "<" + fromParts[1] : "";
                
                // Smarter HTML detection to prevent stripping plain text spacing
                const isHtml = /<(html|body|div|p|br|b|strong|i|em|a|span|table|style)[^>]*>/i.test(msg.body || "");
                
                // Reconstruct newlines if the backend compressed the plain text into a blob
                let rawBody = msg.body || msg.snippet || "";
                if (!isHtml && rawBody.split('\n').length < 4) {
                  rawBody = rawBody
                    .replace(/(---------- Forwarded message ---------)/gi, '\n\n$1\n')
                    .replace(/(From:|Date:|Subject:|To:|Cc:)/g, '\n$1')
                    .replace(/(Dear\s+[A-Za-z]+|Hi\s+[A-Za-z]+|Good\s+day)/gi, '\n\n$1\n\n')
                    .replace(/(Kind\s+Regards|Regards|Sincerely|Thank\s+you)/gi, '\n\n$1\n')
                    .replace(/(On\s+(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)[^:]+wrote:)/gi, '\n\n$1\n')
                    .replace(/(>\s*>)/g, '>>')
                    .replace(/(>\s+)/g, '\n$1')
                    .replace(/(\s\d+\.)/g, '\n$1')
                    .replace(/\n{3,}/g, '\n\n')
                    .trim();
                }

              setEmail({
                  id: msg.id, subject: msg.subject, fromName, fromEmail,
                  to: msg.to,
                  date: msg.date,
                  isStarred: msg.isStarred,
                  labelIds: msg.labelIds || [],
                  time: new Date(msg.date).toLocaleString("en-GB", { day: "numeric", month: "short", hour: "2-digit", minute: "2-digit" }),
                  body: isHtml ? "" : rawBody,
                  bodyHtml: isHtml ? msg.body : "",
                  attachments: msg.attachments ? msg.attachments.map(a => ({
                    ...a,
                    type: a.mimeType.includes("pdf") ? "pdf" : a.mimeType.includes("image") ? "img" : a.mimeType.includes("spreadsheet") || a.mimeType.includes("excel") ? "xls" : "file",
                    url: `/.netlify/functions/gmail-download?messageId=${msg.id}&attachmentId=${a.id}&filename=${encodeURIComponent(a.name)}&mimeType=${encodeURIComponent(a.mimeType)}`
                  })) : [],
                  actions: [{ key: "submit_trello", label: "Submit to Trello" }, { key: "update_tracker", label: "Update AC Tracker" }]
                });
                setEmailPreview(null);
                setShowEmailDetails(false); //  Closes the dropdown for the next email
                setCurrentView({ app: "email", contact: null });
              }}
            >
              {/* Checkbox Container */}
              <div 
                style={{ padding: "0 4px", display: "flex", alignItems: "center" }}
                onClick={(e) => {
                  e.stopPropagation(); 
                  setSelectedEmailIds(prev => {
                    const next = new Set(prev);
                    if (next.has(msg.id)) next.delete(msg.id);
                    else next.add(msg.id);
                    return next;
                  });
                }}
              >
                <input 
                  type="checkbox" 
                  checked={selectedEmailIds.has(msg.id)} 
                  readOnly 
                  style={{ cursor: "pointer", width: "16px", height: "16px" }} 
                />
              </div>

              {/*  STAR ICON CONTAINER */}
<div 
  style={{ 
    cursor: "pointer", 
    fontSize: "20px", 
    display: "grid", 
    placeItems: "center",
    color: msg.isStarred ? "#f2d600" : "#c1c7d0",
    transition: "transform 0.1s ease"
  }}
  onMouseEnter={e => e.currentTarget.style.transform = "scale(1.2)"}
  onMouseLeave={e => e.currentTarget.style.transform = "scale(1)"}
  onClick={(e) => {
    e.preventDefault();
    e.stopPropagation();
    //  FIX: Use 'msg' from the .map iterator, not the global 'email' state
    handleToggleStar(e, msg.id, msg.isStarred);
  }}
>
  {msg.isStarred ? "" : ""}
</div>
       {/* Sender Name */}
              <div style={{ width: "200px", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis", color: "#202124" }}>
                {(() => {
                  if (gmailFolder === "SENT" || gmailFolder === "DRAFTS" || (msg.labelIds || []).includes("DRAFT")) {
                    if (!msg.to) return "To: (Unknown)";
                    
                    let rawName = msg.to.split("<")[0].replace(/"/g, '').trim();
                    
                    // If there is no formal name attached, it will just be the email address
                    if (!rawName || rawName.includes("@")) {
                      const emailMatch = msg.to.match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/);
                      const emailAddr = emailMatch ? emailMatch[1].toLowerCase() : msg.to.toLowerCase();
                      
                      // 1. Look up the email in the company directory map
                      const knownName = Object.keys(AC_EMAIL_MAP).find(key => AC_EMAIL_MAP[key].toLowerCase() === emailAddr);
                      
                      if (knownName) {
                        rawName = knownName;
                      } else {
                        // 2. If it's an outside email, make it look nice and flip Last.First formats
                        const prefix = emailAddr.split("@")[0];
                        let parts = prefix.split(/[._]/);
                        
                        if (parts.length === 2) {
                          parts = parts.reverse(); // Flips britz.chloe to chloe britz
                        }
                        
                        rawName = parts.map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
                      }
                    }
                    return `To: ${rawName}`;
                  } else {
                    return msg.from ? msg.from.split("<")[0].replace(/"/g, '').trim() : "(Unknown)";
                  }
                })()}
              </div>
              

             {/* Subject, Snippet, and Attachments */}
 <div style={{ flex: 1, minWidth: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
   <div style={{ whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis", display: "flex", alignItems: "center" }}>
     
     {/*  GMAIL-STYLE LABELS */}
     {gmailFolder === "INBOX" && (msg.labelIds || []).includes("DRAFT") && (
       <span style={{ background: "#fce8e6", color: "#d93025", fontSize: "11px", fontWeight: "bold", padding: "1px 6px", borderRadius: "4px", marginRight: "8px", textTransform: "uppercase" }}>Draft</span>
     )}
     

     <div style={{ whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis", display: "flex", alignItems: "center" }}>
  
 

  <span style={{ color: "#202124", marginRight: "6px" }}>{msg.subject}</span>
  <span style={{ color: "#5f6368", fontWeight: 400 }}>- {msg.snippet}</span>
</div>
   </div>
                
              {msg.attachments && msg.attachments.length > 0 && (
                  <div style={{ display: 'flex', gap: '8px', marginTop: '6px', overflow: 'hidden', alignItems: 'center' }}>
                    {msg.attachments.slice(0, 3).map(att => {
                      const isPdf = att.mimeType.includes('pdf');
                      const isImg = att.mimeType.includes('image');
                      const isXls = att.mimeType.includes('excel') || att.mimeType.includes('spreadsheet');
                      const isWord = att.mimeType.includes('word') || att.mimeType.includes('document');
                      
                      const iconColor = isPdf ? '#ea4335' : isImg ? '#a142f4' : isXls ? '#188038' : isWord ? '#1a73e8' : '#5f6368';
                      const iconBg = isPdf ? '#fce8e6' : isImg ? '#f3e8fd' : isXls ? '#e6f4ea' : isWord ? '#e8f0fe' : '#f1f3f4';
                      const iconText = isPdf ? 'PDF' : isImg ? 'IMG' : isXls ? 'XLS' : isWord ? 'W' : 'FILE';
                      
                      return (
                        <div key={att.id} style={{ display: 'flex', alignItems: 'center', gap: '6px', padding: '4px 10px', border: '1px solid #dadce0', borderRadius: '100px', fontSize: '12px', background: '#fff', maxWidth: '180px' }}>
                          <div style={{ background: iconBg, color: iconColor, borderRadius: '4px', padding: '2px 4px', fontSize: '9px', fontWeight: 'bold', display: 'grid', placeItems: 'center', minWidth: '22px' }}>
                            {iconText}
                          </div>
                          <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', color: '#3c4043', fontWeight: 500 }}>{att.name}</span>
                        </div>
                      )
                    })}
                    {msg.attachments.length > 3 && (
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '4px 10px', border: '1px solid #dadce0', borderRadius: '100px', fontSize: '12px', background: '#fff', color: '#5f6368', fontWeight: 500 }}>
                        +{msg.attachments.length - 3}
                      </div>
                    )}
                  </div>
                )}
              </div>

              
{/* Date */}
              <div style={{ width: "80px", textAlign: "right", fontSize: "12px", color: msg.isUnread ? "#1a73e8" : "#5f6368" }}>
                {msg.date ? (() => {
                  const d = new Date(msg.date);
                  const now = new Date();
                  const isToday = d.getDate() === now.getDate() && 
                                  d.getMonth() === now.getMonth() && 
                                  d.getFullYear() === now.getFullYear();
                  return isToday 
                    ? d.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" })
                    : d.toLocaleDateString("en-GB", { day: "numeric", month: "short" });
                })() : ""}
              </div>
            </div>
          ))}
        </div>

{/*  COMPOSE EDITOR (Floating over Inbox)  */}
        {selectedDraftTemplate && !email && (
          <div 
            ref={draftWindowRef}
            style={{
            position: "absolute", 
            bottom: "0", 
            right: "24px",
            zIndex: 1000, 
            border: "1px solid #dadce0", 
            boxShadow: "0 8px 24px rgba(0,0,0,0.2)",
            background: "#fff", 
            borderTopLeftRadius: "12px", 
            borderTopRightRadius: "12px", 
            display: "flex", 
            flexDirection: "column", 
            overflow: "hidden",
            width: isDraftEnlarged ? "calc(100% - 48px)" : "500px",
            height: isDraftEnlarged ? "calc(100% - 48px)" : "560px", /* Fixed height stops it from floating too high */
            transform: isDraftEnlarged ? "none" : `translate(${draftPos.x}px, ${draftPos.y}px)`,
            transition: "width 0.15s ease-out, height 0.15s ease-out" /* Smooth size animations, no transform transitions to prevent drag lag */
          }}>
            {/* Draggable Header */}
            <div 
              style={{ padding: "10px 16px", background: "#f2f6fc", display: "flex", justifyContent: "space-between", alignItems: "center", cursor: isDraftEnlarged ? "default" : "move", userSelect: "none" }}
              onMouseDown={handleDraftMouseDown}
            >
              <span style={{ fontWeight: 600, color: "#1f1f1f", fontSize: "14px" }}>New Message</span>
              <div style={{ display: "flex", gap: "12px", alignItems: "center" }}>
                <button 
                  onMouseDown={(e) => e.stopPropagation()}
                  onClick={(e) => { 
                    e.stopPropagation(); 
                    setIsDraftEnlarged(prev => !prev); 
                    setDraftPos({x:0, y:0}); 
                    if (draftWindowRef.current) draftWindowRef.current.style.transform = "none";
                  }} 
                  style={{ border: "none", background: "transparent", cursor: "pointer", color: "#5f6368", display: "flex", alignItems: "center" }} 
                  title={isDraftEnlarged ? "Minimize" : "Maximize"}
                >
                  {isDraftEnlarged ? (
                    <svg width="14" height="14" viewBox="0 0 24 24"><path fill="currentColor" d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>
                  ) : (
                    <svg width="14" height="14" viewBox="0 0 24 24"><path fill="currentColor" d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                  )}
                </button>
            <button 
                onMouseDown={(e) => e.stopPropagation()}
                onClick={(e) => { 
                  e.stopPropagation(); 
                  
                  //  AUTO-SAVE DRAFT LOGIC
                  const currentSubject = document.getElementById("compose-subject")?.value || "";
                  const bodyText = selectedDraftTemplate?.body || "";
                  const draftIdToDelete = selectedDraftTemplate?.draftId;

                  // Only save to backend if the user actually typed something
                  if (draftTo.trim() || currentSubject.trim() || bodyText.trim()) {
                     triggerSnackbar("Draft saved");
                     
                     // Fire and forget background save (0ms UI latency)
                     fetch("/.netlify/functions/gmail-save-draft", {
                       method: "POST",
                       headers: { "Content-Type": "application/json" },
                       body: JSON.stringify({ 
                         to: draftTo, 
                         subject: currentSubject || "New Message", 
                         body: bodyText.replace(/\*([^*]+)\*/g, "<b>$1</b>")
                       })
                     }).then(res => res.json()).then(json => {
                       if (res.ok && json.ok) {
                         // Clean up the old draft version if we were editing an existing one
                         if (draftIdToDelete) {
                            fetch("/.netlify/functions/gmail-delete", {
                               method: "POST",
                               headers: { "Content-Type": "application/json" },
                               body: JSON.stringify({ messageId: draftIdToDelete })
                            });
                         }
                         if (gmailFolder === "DRAFTS") {
                            setGmailRefreshTrigger(prev => prev + 1);
                         }
                       }
                     }).catch(err => console.error("Auto-save failed", err));
                  }

                  // Close UI instantly
                  setSelectedDraftTemplate(null); 
                  setDraftPos({x:0, y:0}); 
                  setDraftAttachments([]); 
                  setDraftTo("");
                }} 
                style={{ border: "none", background: "transparent", cursor: "pointer", fontSize: "16px", color: "#5f6368", padding: "0 4px" }}
                title="Save & Close"
              >
                
              </button>
              </div>
            </div>
            
         {/* To Field with Suggestions */}
            <div style={{ padding: "8px 16px", borderBottom: "1px solid #f1f3f4", display: "flex", alignItems: "center", position: "relative" }}>
              <span style={{ color: "#5f6368", fontSize: "14px", width: "40px" }}>To</span>
              {selectedDraftTemplate.draftId ? (
                <span style={{ flex: 1, fontSize: "14px", color: "#202124", fontWeight: 500 }}>{draftTo || "(No recipient)"}</span>
              ) : (
                <>
                  <input
                    type="text"
                    autoFocus
                    value={draftTo}
                    onChange={(e) => setDraftTo(e.target.value)}
                    style={{ flex: 1, border: "none", outline: "none", fontSize: "14px", color: "#202124" }}
                  />
                  
                {/* Suggestion Dropdown */}
                  {(draftTo || "").length > 1 && !(draftTo || "").includes("@") && (
                    <div style={{
                      position: "absolute",
                      top: "100%",
                      left: "56px",
                      right: "16px",
                      background: "white",
                      border: "1px solid #dadce0",
                      boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
                      zIndex: 2000,
                      maxHeight: "200px",
                      overflowY: "auto",
                      borderRadius: "4px"
                    }}>
                      {Object.entries(combinedContacts)
                        .filter(([name]) => name.toLowerCase().includes((draftTo || "").toLowerCase()))
                        .map(([name, email]) => (
                              <div 
                                key={email}
                                onClick={() => setDraftTo(email)}
                                onMouseEnter={(e) => e.currentTarget.style.background = "#f1f3f4"}
                                onMouseLeave={(e) => e.currentTarget.style.background = "transparent"}
                                style={{
                                  padding: "8px 12px",
                                  cursor: "pointer",
                                  display: "flex",
                                  justifyContent: "space-between",
                                  fontSize: "13px",
                                  color: "#202124"
                                }}
                              >
                               <span style={{ fontWeight: 600, whiteSpace: "nowrap" }}>{name}</span>
                                <span style={{ color: "#5f6368", marginLeft: "15px", whiteSpace: "nowrap" }}>{email}</span>
                              </div>
                            ))
                          }
                        </div>
                      )}
                </>
              )}
            </div>

{/* Subject Field */}
            <div style={{ padding: "8px 16px", borderBottom: "1px solid #f1f3f4", display: "flex", alignItems: "center" }}>
              <input
                type="text"
                placeholder="Subject"
                defaultValue={selectedDraftTemplate?.subject || ""}
                id="compose-subject"
                style={{ flex: 1, border: "none", outline: "none", fontSize: "14px", color: "#202124", fontWeight: 500 }}
              />
            </div>

            {/* ATTACHMENT PREVIEW ROW */}
            {draftAttachments.length > 0 && (
              <div style={{ padding: "8px 16px", borderBottom: "1px solid #f1f3f4", display: "flex", gap: "8px", flexWrap: "wrap", background: "#f8f9fa" }}>
                {draftAttachments.map((file, idx) => (
                  <div key={idx} style={{ display: "flex", alignItems: "center", gap: "6px", background: "#fff", border: "1px solid #dadce0", borderRadius: "16px", padding: "4px 10px", fontSize: "12px", color: "#3c4043" }}>
                    <span style={{ maxWidth: "120px", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{file.name}</span>
                    <span style={{ color: "#5f6368" }}>{(file.size / 1024 / 1024).toFixed(1)}MB</span>
                    <button 
                      onClick={() => setDraftAttachments(prev => prev.filter((_, i) => i !== idx))} 
                      style={{ border: "none", background: "transparent", cursor: "pointer", padding: "0 2px", color: "#5f6368", display: "flex", alignItems: "center" }}
                    ></button>
                  </div>
                ))}
              </div>
            )}

        {/* Body Container */}
                <div style={{ flex: 1, display: "flex", flexDirection: "column", background: "#fff", overflowY: "auto" }}>
                    {/* Standard Textarea for Input */}
                    <textarea
                      autoFocus
                      className="email-draft-textarea"
                      value={selectedDraftTemplate.body || ""}
                      onChange={(e) => setSelectedDraftTemplate((prev) => prev ? { ...prev, body: e.target.value } : prev)}
                      style={{ 
                        width: '100%',
                        border: "none", 
                        padding: "16px", 
                        resize: "none", 
                        outline: "none", 
                        minHeight: "200px", 
                        fontSize: "14px", 
                        fontFamily: "Verdana, sans-serif",
                        background: "transparent",
                        color: "#202124", 
                        whiteSpace: "pre-wrap",
                        overflowY: "visible", 
                        boxSizing: "border-box",
                        lineHeight: "1.5",
                        flexShrink: 0
                      }}
                    />
                    {/* Re-inserting the Signature into the preview */}
                    <div style={{ borderTop: "1px solid #f1f3f4", marginTop: "8px", paddingTop: "16px" }}>
                      <EmailSignature />
                    </div>
                </div>
            
        {/* Footer */}
            <div style={{ padding: "12px 16px", display: "flex", justifyContent: "space-between", alignItems: "center", background: "#fff" }}>
              <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
                <button
                  className="btn blue"
                  onClick={async (e) => {
                    const btn = e.currentTarget;
                    if (!draftTo.trim()) {
                      setEmail((prev) => prev ? { ...prev, systemNote: "Please add a recipient address." } : prev);
                      return;
                    }
                    btn.disabled = true;
                    try {
                      const base64Attachments = await Promise.all(draftAttachments.map(file => {
                        return new Promise((resolve) => {
                          const reader = new FileReader();
                          reader.onload = () => resolve({
                            filename: file.name,
                            mimeType: file.type || "application/octet-stream",
                            content: reader.result.split(',')[1]
                          });
                          reader.readAsDataURL(file);
                        });
                      }));

                const res = await fetch("/.netlify/functions/gmail-send-email", {
                          method: "POST",
                          headers: { "Content-Type": "application/json" },
                          body: JSON.stringify({
                            to: draftTo,
                            subject: document.getElementById("compose-subject")?.value || "New Message",
                            body: selectedDraftTemplate.body.replace(/\*([^*]+)\*/g, "<b>$1</b>"),
                            attachments: base64Attachments 
                          }),
                        });
                        const json = await res.json().catch(() => ({}));
                        if (!res.ok || json.ok === false) throw new Error(json.error || `HTTP ${res.status}`);
                        
                        //  IF EDITING A DRAFT, DELETE THE OLD ONE AFTER SENDING
                        if (selectedDraftTemplate.draftId) {
                           fetch("/.netlify/functions/gmail-delete", {
                              method: "POST",
                              headers: { "Content-Type": "application/json" },
                              body: JSON.stringify({ messageId: selectedDraftTemplate.draftId })
                           });
                           setGmailEmails(prev => prev.filter(emailItem => emailItem.id !== selectedDraftTemplate.draftId));
                        }

                        setSelectedDraftTemplate(null);
                        setDraftTo("");
                        setDraftAttachments([]);
                      //  Show snackbar for 4 seconds
                        triggerSnackbar("Message sent");
                      } catch (err) {
                        setEmail((prev) => prev ? { ...prev, systemNote: `Error: ${err.message}` } : prev);
                        btn.disabled = false;
                      }
                  }}
                  style={{ background: "#0b57d0", color: "#fff", padding: "8px 24px", borderRadius: "24px", border: "none", fontWeight: 500, cursor: "pointer" }}
                >
                  Send
                </button>



                <button 
                  onClick={() => draftFileInputRef.current?.click()} 
                  title="Attach files"
                  style={{ background: "transparent", border: "none", cursor: "pointer", color: "#5f6368", display: "grid", placeItems: "center", padding: "8px", borderRadius: "50%" }}
                  onMouseEnter={(ev) => ev.currentTarget.style.background = "#f1f3f4"}
                  onMouseLeave={(ev) => ev.currentTarget.style.background = "transparent"}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-3.31-2.69-6-6-6S3 1.69 3 5v11.5c0 3.86 3.14 7 7 7s7-3.14 7-7V6h-1.5z"/></svg>
                </button>
                <input 
                  type="file" 
                  multiple 
                  ref={draftFileInputRef} 
                  style={{ display: "none" }} 
                  onChange={(e) => {
                    const files = Array.from(e.target.files || []);
                    const validFiles = files.filter(f => f.size <= 4.5 * 1024 * 1024);
                    if (validFiles.length < files.length) alert("Some files were skipped because they exceed the 4.5MB limit.");
                    setDraftAttachments(prev => [...prev, ...validFiles]);
                    e.target.value = "";
                  }} 
                />
              </div>

           <button 
                title="Discard draft"
                onClick={() => { 
                  // If we were editing an existing draft, delete it from the server
                  if (selectedDraftTemplate?.draftId) {
                    fetch("/.netlify/functions/gmail-delete", {
                       method: "POST",
                       headers: { "Content-Type": "application/json" },
                       body: JSON.stringify({ messageId: selectedDraftTemplate.draftId })
                    }).then(() => {
                       if (gmailFolder === "DRAFTS") setGmailRefreshTrigger(prev => prev + 1);
                    });
                  }
                  
                  // Clear UI instantly
                  setSelectedDraftTemplate(null); 
                  setDraftTo(""); 
                  setDraftAttachments([]); 
                  triggerSnackbar("Draft discarded");
                }} 
                style={{ border: "none", background: "transparent", cursor: "pointer", color: "#5f6368", padding: "8px", borderRadius: "50%" }}
                onMouseEnter={e => e.currentTarget.style.background = "#f1f3f4"}
                onMouseLeave={e => e.currentTarget.style.background = "transparent"}
              >
                <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"/></svg>
              </button>
            </div>
          </div>
        )}

   </div>
    );
  }

  if (currentView.app === "email") {
   const att = (email && email.attachments) || [];
   const actions = (email && email.actions) || [];
    

  const handleDeleteEmail = async (id) => {
        if (!window.confirm("Delete this message?")) return;
        try {
          await fetch("/.netlify/functions/gmail-delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ messageId: id })
          });
          setGmailEmails(prev => prev.filter(e => e.id !== id));
          setCurrentView({ app: "gmail", contact: null });
        } catch (err) {
          console.error("Delete failed", err);
        }
      };
      const handleToggleStar = async (e, msgId, currentStarred) => {
    if (e) {
      e.stopPropagation(); 
      e.preventDefault();  
    }
    
    const nextStarredState = !currentStarred;

    // 1. Update the main list immediately
    setGmailEmails(prev => prev.map(msg => 
      msg.id === msgId ? { ...msg, isStarred: nextStarredState } : msg
    ));

    // 2. Update the individual email view immediately
    setEmail(prev => {
      if (prev && prev.id === msgId) {
        return { ...prev, isStarred: nextStarredState };
      }
      return prev;
    });

    try {
      const response = await fetch("/.netlify/functions/gmail-toggle-star", {
        method: "POST",
        credentials: "include", 
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ messageId: msgId, starred: nextStarredState })
      });

      // If the request fails, the catch block will handle the revert
      if (!response.ok) throw new Error("Sync failed");

      if (!nextStarredState && gmailFolder === "STARRED") {
        setGmailEmails(prev => prev.filter(msg => msg.id !== msgId));
      }
    } catch (err) {
      console.error("Starring sync failed:", err);
      // Revert both states on failure
      setGmailEmails(prev => prev.map(msg => 
        msg.id === msgId ? { ...msg, isStarred: currentStarred } : msg
      ));
      setEmail(prev => (prev && prev.id === msgId) ? { ...prev, isStarred: currentStarred } : prev);
    }
  };

   const emailPane = (
    <div className="email-pane" style={{ border: "none", boxShadow: "none", padding: "8px 24px", background: "#fff" }}>
   {/* Top Gmail Action Bar */}
          <div className="gmail-action-bar" style={{ padding: "8px 0", borderBottom: "none" }}>
            <div className="gmail-action-icon" onClick={() => setCurrentView({ app: "gmail", contact: null })} title="Back to inbox">
              <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </div>
            <div className="gmail-action-icon" onClick={() => handleDeleteEmail(email.id)} title="Delete">
              <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
            </div>
          <div className="gmail-action-icon" title="Mark as unread" onClick={async () => {
              // 1. Optimistic UI update
              setGmailEmails(prev => prev.map(e => e.id === email.id ? { ...e, isUnread: true } : e));
              
              // 2. Return to inbox immediately for smooth UX
              setCurrentView({ app: "gmail", contact: null });

              // 3. Sync with backend
              try {
                await fetch("/.netlify/functions/gmail-mark-unread", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ messageId: email.id })
                });
              } catch (err) {
                console.error("Failed to mark unread", err);
              }
            }}>
              <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V8l8 5 8-5v10zm-8-7L4 6h16l-8 5z"/></svg>
            </div>
          </div>

    {/* Subject Line Row */}
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "16px 0 8px 56px" }}>
            <h2 style={{ fontSize: "22px", fontWeight: 400, color: "#1f1f1f", margin: 0, display: "flex", alignItems: "center", gap: "12px", fontFamily: "'Google Sans', Roboto, Arial, sans-serif" }}>
              {email.subject}
              <span style={{ fontSize: "12px", background: "#f1f3f4", padding: "2px 6px", borderRadius: "4px", color: "#5f6368", display: "inline-flex", alignItems: "center", gap: "4px" }}>
                Inbox
                <span style={{ fontSize: "10px", cursor: "pointer" }}></span>
              </span>
            </h2>
          </div>

     {/* Sender Info Row */}
     <div style={{ display: "flex", alignItems: "flex-start", marginTop: "16px" }}>
      <div style={{ width: "40px", height: "40px", borderRadius: "50%", background: "#5c6bc0", color: "white", display: "grid", placeItems: "center", fontSize: "18px", marginRight: "16px", flexShrink: 0 }}>
       {email.fromName ? email.fromName.charAt(0).toUpperCase() : "U"}
      </div>
      <div style={{ flex: 1, minWidth: 0 }}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "baseline" }}>
                    <div style={{ display: "flex", alignItems: "baseline", gap: "6px", overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis" }}>
                      <span style={{ fontWeight: 600, color: "#202124", fontSize: "14px" }}>{email.fromName}</span>
                      <span style={{ color: "#5f6368", fontSize: "12px" }}>{email.fromEmail}</span>
                    </div>
               <div style={{ display: "flex", alignItems: "center", gap: "12px", color: "#5f6368", fontSize: "12px", flexShrink: 0 }}>
                      <span>{email.time} ({timeAgo(email.date)})</span>
                      
                      {/*  STAR BUTTON - Fixed to update local view state */}
<div 
  style={{ 
    cursor: "pointer", 
    fontSize: "20px", 
    display: "grid", 
    placeItems: "center",
    color: email.isStarred ? "#f2d600" : "#c1c7d0",
    transition: "transform 0.1s ease"
  }}
  onMouseEnter={e => e.currentTarget.style.transform = "scale(1.2)"}
  onMouseLeave={e => e.currentTarget.style.transform = "scale(1)"}
  onClick={(e) => {
    e.preventDefault();
    e.stopPropagation();
    //  FIX: Ensure we use the 'email' object currently loaded in the detailed view
    handleToggleStar(e, email.id, email.isStarred);
  }}
>
  {email.isStarred ? "" : ""}
</div>
                      <div 
                        style={{ cursor: "pointer", display: "grid", placeItems: "center" }}
                        onClick={() => {
                          const replyTpl = DRAFT_TEMPLATES.find(t => t.id === "new_blank");
                          setSelectedDraftTemplate({...replyTpl, body: "\n\n", isForward: false});
                          let targetEmail = email.fromEmail ? email.fromEmail.replace("<", "").replace(">", "").trim() : "";
                          setDraftTo(targetEmail);
                        }}
                      >
                        <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg>
                      </div>
                    </div>
                  </div>
                  
                {/*  INTERACTIVE "TO ME" POPOVER (Fast Component) */}
                <EmailMetadata email={email} />
                </div>
          </div>

{/* Email Body */}
          <div className="email-body" style={{ marginLeft: "56px", marginTop: "24px", paddingRight: "48px", paddingBottom: "60px" }}>
            {email.bodyHtml ? (
              <div
                className="email-body-html"
                style={{ fontFamily: "'Google Sans', Roboto, Arial, sans-serif", fontSize: "14px", color: "#202124", lineHeight: "1.6" }}
                dangerouslySetInnerHTML={{ __html: email.bodyHtml }}
              />
            ) : (
              <div className="email-body-text" style={{ fontFamily: "Roboto, Arial, sans-serif", fontSize: "14px", color: "#202124", wordBreak: "break-word" }}>
                {(() => {
                  const body = email.body || "";
                  
                  const renderFormattedBody = (text, depth = 0) => {
                    const forwardRegex = /[-]{3,}\s*Forwarded message\s*[-]{3,}/i;
                    const replyRegex = /(^On\s.+\sat\s.+\s.+\swrote:)/im;

                    if (forwardRegex.test(text)) {
                      const parts = text.split(forwardRegex);
                      return (
                        <>
                          {parts[0] && (
                            <div className="gmail-paragraph-wrapper">
                              {parts[0].trim().split('\n').map((line, i) => (
                                <div key={i} style={{ marginBottom: line.trim() ? "14px" : "8px", minHeight: line.trim() ? "auto" : "12px" }}>{line}</div>
                              ))}
                            </div>
                          )}
                          {parts.slice(1).map((segment, idx) => (
                            <div key={idx} className="gmail-forward-wrap" style={{ marginTop: "28px", paddingLeft: depth > 0 ? "12px" : "0", borderLeft: depth > 0 ? "1px solid #dadce0" : "none" }}>
                              <div style={{ color: "#5f6368", fontSize: "13px", marginBottom: "16px", fontStyle: "normal" }}>
                                ---------- Forwarded message ---------
                              </div>
                              {renderFormattedBody(segment.trim(), depth + 1)}
                            </div>
                          ))}
                        </>
                      );
                    }

                    if (replyRegex.test(text)) {
                      const parts = text.split(replyRegex);
                      return (
                        <>
                          {parts[0] && <div>{parts[0].trim()}</div>}
                          <div className="gmail-reply-quote" style={{ borderLeft: "2px solid #72a8ff", paddingLeft: "16px", color: "#505050", marginTop: "16px" }}>
                            <div style={{ fontWeight: "500", marginBottom: "12px", color: "#5f6368" }}>{parts[1]}</div>
                            {parts.slice(2).join("").split('\n').map((line, i) => (
                              <div key={i} style={{ marginBottom: "12px" }}>{line}</div>
                            ))}
                          </div>
                        </>
                      );
                    }

                    // Fallback for standard text: Use pre-wrap to respect original formatting
                  return (
                    <div style={{ whiteSpace: "pre-wrap", lineHeight: "1.6", fontFamily: "system-ui, -apple-system, sans-serif" }}>
                      {text}
                    </div>
                  );
                  };

                  return renderFormattedBody(body);
                })()}
              </div>
            )}
          </div>

    {/* Attachments Section */}
          {att.length > 0 && (
            <div style={{ marginLeft: "56px", marginTop: "24px" }}>
              <div style={{ borderTop: "1px solid #f1f3f4", margin: "16px 0", width: "100%" }}></div>
              
              <div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginBottom: '16px' }}>
                <span style={{ fontWeight: 600, fontSize: '14px', color: '#202124' }}>{att.length} attachment{att.length > 1 ? 's' : ''}</span>
                <span style={{ color: '#5f6368', fontSize: '13px' }}> Scanned by Gmail </span>
                
                <div style={{ display: 'flex', alignItems: 'center', gap: '4px', marginLeft: '8px' }}>
                  <button 
                    onClick={() => {
                      att.forEach((a, index) => {
                        setTimeout(() => {
                          const link = document.createElement('a');
                          link.href = a.url;
                          link.setAttribute('download', a.name);
                          document.body.appendChild(link);
                          link.click();
                          document.body.removeChild(link);
                        }, index * 600);
                      });
                    }}
                    title="Download all"
                    style={{ background: 'transparent', border: 'none', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#5f6368', padding: '8px', borderRadius: '50%' }}
                    onMouseEnter={e => e.currentTarget.style.background = '#f1f3f4'}
                    onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                  >
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                  </button>
                </div>
              </div>

    <div className="email-attach-grid">
                {att.map((f, i) => {
                  const isPdf = f.type === 'pdf' || f.name.toLowerCase().includes('.pdf');
                  const isImg = f.type === 'img' || f.name.toLowerCase().match(/\.(jpg|jpeg|png|gif)$/i);
                  const isXls = f.type === 'xls' || f.name.toLowerCase().match(/\.(xls|xlsx|csv)$/i);
                  const isWord = f.type === 'doc' || f.name.toLowerCase().match(/\.(doc|docx)$/i);
                  
                  const iconColor = isPdf ? '#ea4335' : isImg ? '#a142f4' : isXls ? '#188038' : isWord ? '#1a73e8' : '#5f6368';
                  const displayType = isPdf ? 'PDF' : isImg ? 'IMG' : isXls ? 'XLS' : isWord ? 'DOC' : 'FILE';

                  return (
                    <button
  key={i}
  className="email-attach"
  onClick={(e) => {
    e.stopPropagation();
    const isViewable = f.type === 'pdf' || f.type === 'img';
    
    if (isViewable) {
      //  PDFs and Images: Open the split-view preview pane
      setEmailPreview(f);
    } else {
      //  Word/Excel/Other: Bypass preview and trigger instant download
      const link = document.createElement("a");
      link.href = f.url;
      link.setAttribute("download", f.name);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }}
  title={f.name}
  style={{ background: "#fff", border: "1px solid #dadce0", borderRadius: "8px", width: "180px", height: "auto", padding: "0", overflow: "hidden", display: "flex", flexDirection: "column" }}
>
                      <div className="email-attach-preview" style={{ height: "100px", background: "#f8f9fa", display: "flex", alignItems: "center", justifyContent: "center" }}>
                        {/* Iframe removed to prevent auto-downloads. Replaced with dynamic type icon. */}
                        <div style={{ fontSize: "28px", fontWeight: "bold", color: iconColor, opacity: 0.3 }}>
                          {displayType}
                        </div>
                      </div>
                      <div className="email-attach-footer" style={{ padding: "8px 12px", display: "flex", alignItems: "center", gap: "8px", background: "#fff", borderTop: "1px solid #dadce0", width: "100%" }}>
                        <span style={{ background: iconColor, color: "white", padding: "2px 4px", borderRadius: "4px", fontSize: "10px", fontWeight: "bold" }}>
                          {displayType}
                        </span>
                        <span className="email-attach-name" style={{ fontSize: "12px", color: "#3c4043", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>{f.name}</span>
                      </div>
                    </button>
                  );
                })}
              </div>
      </div>
     )}
{/* Authentic Gmail Inline Reply Trigger & Actions */}
          {!selectedDraftTemplate && (
            <div style={{ marginLeft: "56px", marginTop: "32px", paddingBottom: "24px" }}>
              
       {/* Reply, Forward, or Edit Draft */}
<div style={{ display: "flex", gap: "8px", marginBottom: "24px" }}>
  {/*  BROADENED LOGIC: Check for DRAFT label to show Edit Draft button in Inbox/Search results */}
  {((email.labelIds || []).includes("DRAFT") || gmailFolder === "DRAFTS") ? (
    <button 
      className="gmail-btn-outline" 
      onClick={() => {
        const rawText = email.bodyHtml || email.body || "";
        let plainBody = email.bodyHtml ? rawText.replace(/<br\s*[\/]?>/gi, "\n").replace(/<\/p>/gi, "\n").replace(/<[^>]+>/g, "") : rawText;
        
        const sigIndex = plainBody.indexOf("Kind regards");
        if (sigIndex !== -1) {
          plainBody = plainBody.substring(0, sigIndex).trim();
        }

        let toEmail = "";
        if (email.to && email.to.length > 0) {
           const toStr = Array.isArray(email.to) ? email.to[0] : email.to;
           const emailMatch = (typeof toStr === "string" ? toStr : "").match(/<([^>]+)>/);
           toEmail = emailMatch ? emailMatch[1].trim() : (typeof toStr === "string" ? toStr.replace(/"/g, '').trim() : "");
        }

        setSelectedDraftTemplate({
          id: "existing_draft",
          draftId: email.id,
          label: "Edit Draft",
          subject: email.subject || "",
          body: plainBody + "\n\n",
          isForward: false 
        });
        setDraftTo(toEmail);

        if (email.attachments && email.attachments.length > 0) {
          Promise.all(email.attachments.map(async (a) => {
            const res = await fetch(a.url);
            const blob = await res.blob();
            return new File([blob], a.name, { type: a.mimeType });
          })).then(files => setDraftAttachments(files));
        }

        setEmail(null);
        setEmailPreview(null);
        setCurrentView({ app: "gmail", contact: null });
      }}
      style={{ borderRadius: "100px", padding: "8px 24px", color: "#3c4043", border: "1px solid #dadce0", display: "flex", alignItems: "center", gap: "8px", background: "#fff", cursor: "pointer", fontSize: "14px", fontWeight: 500 }}
    >
      <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
      Edit Draft
    </button>
  ) : (
    <>
      <button 
        className="gmail-btn-outline" 
        onClick={() => {
          const replyTpl = DRAFT_TEMPLATES.find(t => t.id === "new_blank");
          setSelectedDraftTemplate({...replyTpl, body: "\n\n", isForward: false});
          let targetEmail = email.fromEmail ? email.fromEmail.replace("<", "").replace(">", "").trim() : "";
          setDraftTo(targetEmail);
        }}
        style={{ borderRadius: "100px", padding: "8px 24px", color: "#3c4043", border: "1px solid #dadce0", display: "flex", alignItems: "center", gap: "8px", background: "#fff", cursor: "pointer", fontSize: "14px", fontWeight: 500 }}
      >
        <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg>
        Reply
      </button>
      <button 
        className="gmail-btn-outline" 
        onClick={async () => {
          const replyTpl = DRAFT_TEMPLATES.find(t => t.id === "new_blank");
          const cleanFromEmail = email.fromEmail ? email.fromEmail.replace(/[<>]/g, '') : "";
          const fromLine = email.fromName && !email.fromName.includes("@") ? `${email.fromName} <${cleanFromEmail}>` : `<${cleanFromEmail || email.fromName}>`;
          const fwdHeader = `\n\n---------- Forwarded message ---------\nFrom: ${fromLine}\nDate: ${email.time}\nSubject: ${email.subject}\nTo: Siyabonga Nono <siyabonga@actuaryconsulting.co.za>\n\n`;
          const fwdBody = email.body || email.snippet || "";
          
          if (email.attachments && email.attachments.length > 0) {
            try {
              const existingFiles = await Promise.all(email.attachments.map(async (a) => {
                const res = await fetch(a.url);
                const blob = await res.blob();
                return new File([blob], a.name, { type: a.mimeType });
              }));
              setDraftAttachments(existingFiles);
            } catch (e) { console.error(e); }
          }
          setSelectedDraftTemplate({...replyTpl, body: fwdHeader + fwdBody, isForward: true});
          setDraftTo(""); 
        }}
        style={{ borderRadius: "100px", padding: "8px 24px", color: "#3c4043", border: "1px solid #dadce0", display: "flex", alignItems: "center", gap: "8px", background: "#fff", cursor: "pointer", fontSize: "14px", fontWeight: 500 }}
      >
        <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M14 9V5l7 7-7 7v-4.1c-5 0-8.5 1.6-11 5.1 1-5 4-10 11-11z"/></svg>
        Forward
      </button>
    </>
  )}
</div>

              {/* Trello / Tracker Actions (Hidden for Drafts) */}
              {gmailFolder !== "DRAFTS" && (
                <div className="email-actions" style={{ borderTop: "1px solid #f1f3f4", paddingTop: "24px", display: "flex", gap: "12px", justifyContent: "flex-start" }}>
                  {actions.map((a) => (
                    <button
                      key={a.key}
                      className="email-action-btn"
                      onClick={() => handleEmailAction(a.key)}
                    >
                      {a.label}
                    </button>
                  ))}
                  <button
                    className="email-action-btn"
                    onClick={() => setShowDraftPicker(prev => !prev)}
                  >
                    Create Draft
                  </button>
                </div>
              )}

              {email.systemNote && (
                <div className="email-note" style={{ marginTop: "12px" }}>{email.systemNote}</div>
              )}
            </div>
          )}

          {/*  TEMPLATE PICKER (Extracted outside the condition so it can render anytime) */}
          {showDraftPicker && (
            <div style={{ marginLeft: "56px", marginTop: "12px", marginBottom: "24px" }}>
              <div style={{ fontSize: "13px", color: "#5f6368", marginBottom: "8px" }}>Choose a draft template below.</div>
              <div className="draft-picker" style={{ background: "#f8f9fa", border: "1px solid #dadce0", padding: "16px", borderRadius: "8px" }}>
                <div className="draft-picker-title" style={{ color: "#202124", marginBottom: "12px", fontWeight: 600, fontSize: "15px" }}>Choose a draft email template:</div>
                <div className="draft-picker-list" style={{ display: "flex", flexWrap: "wrap", gap: "8px" }}>
                  {DRAFT_TEMPLATES.map((tpl) => (
                    <button
                      key={tpl.id}
                      className="draft-picker-item"
                      style={{ border: "1px solid #dadce0", padding: "8px 16px", color: "#3c4043", borderRadius: "100px", background: "#fff", cursor: "pointer", fontSize: "13px" }}
                      onClick={() => {
                        // Keeps existing recipient if replying, otherwise grabs sender email
                        if (!draftTo) {
                          let targetEmail = "";
                          if (email.fromEmail) {
                            targetEmail = email.fromEmail.replace("<", "").replace(">", "").trim();
                          }
                          setDraftTo(targetEmail);
                        }
                        setSelectedDraftTemplate(tpl);
                        setShowDraftPicker(false);
                      }}
                    >
                      {tpl.label}
                    </button>
                  ))}
                </div>
              </div>
            </div>
          )}

         {/*  INLINE GMAIL REPLY BOX (Pixel Perfect) */}
          {selectedDraftTemplate && (
            <div className="gmail-inline-reply-box" style={{ marginLeft: "56px", marginTop: "12px", border: "1px solid #dadce0", borderRadius: "12px", background: "#fff", padding: "0", boxShadow: "0 1px 3px rgba(0,0,0,0.1)", position: "relative", overflow: "hidden" }}>
              
            {/* Top Row: Reply Arrow & Recipient */}
              <div style={{ display: "flex", alignItems: "center", padding: "12px 16px", background: "#fff", borderBottom: "1px solid transparent", position: "relative" }}>
                <div style={{ display: "flex", alignItems: "center", cursor: "pointer", color: "#5f6368", padding: "4px 8px", borderRadius: "4px", margin: "-4px 8px -4px -8px" }} className="gmail-action-icon">
                  {selectedDraftTemplate.isForward ? (
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M14 9V5l7 7-7 7v-4.1c-5 0-8.5 1.6-11 5.1 1-5 4-10 11-11z"/></svg>
                  ) : (
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg>
                  )}
                  <svg width="16" height="16" viewBox="0 0 24 24" style={{ marginLeft: "2px" }}><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
                </div>
                
                <div style={{ flex: 1, position: "relative", display: "flex", alignItems: "center" }}>
                  {selectedDraftTemplate.draftId ? (
                    <span style={{ color: "#202124", fontSize: "14px", fontWeight: 500 }}>{draftTo || "(No recipient)"}</span>
                  ) : (
                    <>
                      <input
                        type="text"
                        value={draftTo}
                        onChange={(e) => setDraftTo(e.target.value)}
                        style={{ border: "none", outline: "none", background: "transparent", width: "100%", color: "#202124", fontSize: "14px", fontWeight: 400 }}
                        placeholder={selectedDraftTemplate.isForward ? "To" : "Recipient"}
                      />
                      
                    
                 {/* Suggestion Dropdown */}
                  {(draftTo || "").length > 1 && !(draftTo || "").includes("@") && (
                    <div style={{
                      position: "absolute",
                      top: "100%",
                      left: "56px",
                      right: "16px",
                      background: "white",
                      border: "1px solid #dadce0",
                      boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
                      zIndex: 2000,
                      maxHeight: "200px",
                      overflowY: "auto",
                      borderRadius: "4px"
                    }}>
                      {Object.entries(combinedContacts)
                        .filter(([name]) => name.toLowerCase().includes((draftTo || "").toLowerCase()))
                        .map(([name, email]) => (
                              <div 
                                key={email}
                                onClick={() => setDraftTo(email)}
                                onMouseEnter={(e) => e.currentTarget.style.background = "#f1f3f4"}
                                onMouseLeave={(e) => e.currentTarget.style.background = "transparent"}
                                style={{
                                  padding: "8px 12px",
                                  cursor: "pointer",
                                  display: "flex",
                                  justifyContent: "space-between",
                                  fontSize: "13px",
                                  color: "#202124"
                                }}
                              >
                                <span style={{ fontWeight: 600, whiteSpace: "nowrap" }}>{name}</span>
                                <span style={{ color: "#5f6368", marginLeft: "15px", whiteSpace: "nowrap" }}>{email}</span>
                              </div>
                            ))
                          }
                        </div>
                      )}
                    </>
                  )}
                </div>

                <button className="gmail-action-icon" style={{ margin: "-4px -8px -4px 8px" }} title="Pop out reply">
                  <svg width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>
                </button>
              </div>

            {/* Text Area */}
                  <div style={{ padding: "0 16px", display: "flex", flexDirection: "column" }}>
                      <textarea
                        autoFocus
                        className="email-draft-textarea"
                        value={selectedDraftTemplate.body || ""}
                        onChange={(e) => setSelectedDraftTemplate((prev) => prev ? { ...prev, body: e.target.value } : prev)}
                        style={{
                          width: "100%", border: "none", outline: "none", minHeight: "150px", maxHeight: "350px", fontSize: "14px", resize: "none",
                          background: "transparent", color: "#202124", whiteSpace: "pre-wrap", overflowY: "auto", boxSizing: "border-box", lineHeight: "1.5", marginTop: "8px"
                        }}
                      />
                  </div>

              {/* ATTACHMENT PREVIEW ROW */}
              {draftAttachments.length > 0 && (
                <div style={{ padding: "8px 16px", borderTop: "1px solid #e0e4f0", display: "flex", gap: "8px", flexWrap: "wrap", background: "#f8f9fa" }}>
                  {draftAttachments.map((file, idx) => (
                    <div key={idx} style={{ display: "flex", alignItems: "center", gap: "6px", background: "#fff", border: "1px solid #dadce0", borderRadius: "16px", padding: "4px 10px", fontSize: "12px", color: "#3c4043" }}>
                      <span style={{ maxWidth: "150px", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }}>{file.name}</span>
                      <span style={{ color: "#5f6368" }}>{(file.size / 1024 / 1024).toFixed(1)}MB</span>
                      <button 
                        onClick={() => setDraftAttachments(prev => prev.filter((_, i) => i !== idx))} 
                        style={{ border: "none", background: "transparent", cursor: "pointer", padding: "0 2px", color: "#5f6368", display: "flex", alignItems: "center" }}
                      ></button>
                    </div>
                  ))}
                </div>
              )}

              {/* Bottom Toolbar */}
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "12px 16px", background: "#fff" }}>
                <div style={{ display: "flex", gap: "12px", alignItems: "center" }}>
                  <button
                    className="btn blue"
                    style={{ borderRadius: "24px", padding: "8px 16px 8px 24px", fontSize: "14px", fontWeight: 500, display: "flex", alignItems: "center", gap: "8px" }}
                   onClick={async () => {
                    if (!draftTo.trim()) {
                      setEmail((prev) => prev ? { ...prev, systemNote: "Please add a recipient address." } : prev);
                      return;
                    }

                    //  0ms LATENCY: Close draft and show snackbar immediately
                    triggerSnackbar("Message sent");
                    setSelectedDraftTemplate(null);
                    const finalRecipient = draftTo; // Store for the note
                    setDraftTo("");
                    setDraftAttachments([]);

                    try {
                      const base64Attachments = await Promise.all(draftAttachments.map(file => {
                        return new Promise((resolve) => {
                          const reader = new FileReader();
                          reader.onload = () => resolve({
                            filename: file.name,
                            mimeType: file.type || "application/octet-stream",
                            content: reader.result.split(',')[1]
                          });
                          reader.readAsDataURL(file);
                        });
                      }));

                      const prefix = selectedDraftTemplate.isForward ? "Fwd:" : "Re:";
                      const replySubject = email?.subject?.startsWith(prefix) ? email.subject : `${prefix} ${email?.subject || "New Message"}`;

                      const res = await fetch("/.netlify/functions/gmail-send-email", {
                        method: "POST",
                        headers: { "content-type": "application/json" },
                        body: JSON.stringify({
                          to: finalRecipient,
                          subject: replySubject,
                          body: selectedDraftTemplate.body.replace(/\*([^*]+)\*/g, "<b>$1</b>"),
                          attachments: base64Attachments 
                        }),
                      });
                      
                      const json = await res.json().catch(() => ({}));
                      if (!res.ok || json.ok === false) throw new Error(json.error || `HTTP ${res.status}`);
                      
                     setEmail((prev) => prev ? { ...prev, systemNote: `Email sent successfully to: ${finalRecipient}` } : prev);
                    } catch (err) {
                      console.error("Delayed send error:", err);
                      setSnackbar({ show: false, text: "" }); 
                      alert(`Failed to send: ${err.message}`);
                    }
                  }}
                  >
                    Send
                    <svg width="16" height="16" viewBox="0 0 24 24" style={{ borderLeft: "1px solid rgba(255,255,255,0.3)", paddingLeft: "6px", marginLeft: "2px", boxSizing: "content-box" }}><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg>
                  </button>
                  
                  {/* Formatting / Paperclip Icons */}
                  <div style={{ display: "flex", alignItems: "center", color: "#5f6368" }}>
                    <input 
                      type="file" 
                      multiple 
                      ref={draftFileInputRef} 
                      style={{ display: "none" }} 
                      onChange={(e) => {
                        const files = Array.from(e.target.files || []);
                        const validFiles = files.filter(f => f.size <= 4.5 * 1024 * 1024);
                        if (validFiles.length < files.length) alert("Some files were skipped because they exceed the 4.5MB limit.");
                        setDraftAttachments(prev => [...prev, ...validFiles]);
                        e.target.value = "";
                      }} 
                    />
                    <button 
                      className="gmail-action-icon" 
                      onClick={() => draftFileInputRef.current?.click()}
                      title="Attach files"
                      style={{ padding: "6px" }}
                    >
                      <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5a2.5 2.5 0 0 0 5 0V5c0-3.31-2.69-6-6-6S3 1.69 3 5v11.5c0 3.86 3.14 7 7 7s7-3.14 7-7V6h-1.5z"/></svg>
                    </button>
                    {/* NEW: Three Dots toggle for templates while replying */}
                    <button 
                      className="gmail-action-icon" 
                      title="More options (Templates)" 
                      onClick={() => setShowDraftPicker(prev => !prev)}
                      style={{ padding: "6px" }}
                    >
                      <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                    </button>
                  </div>
                </div>

                {/* Delete / Discard Icon */}
                <button 
                  className="gmail-action-icon" 
                  title="Discard draft"
                  onClick={() => {
                    setSelectedDraftTemplate(null);
                    setDraftTo("");
                    setDraftAttachments([]);
                    setEmail((prev) => prev ? { ...prev, systemNote: undefined } : prev);
                  }}
                  style={{ padding: "8px", margin: "-8px" }}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"/></svg>
                </button>
              </div>
            </div>
          )}
        </div>
      );

      const previewPane = emailPreview ? (
        <div className="email-preview">
          <div className="email-preview-bar">
            <div className="email-preview-name">{emailPreview.name}</div>
            <button
              className="email-preview-close"
              onClick={() => setEmailPreview(null)}
            >
              Close
            </button>
          </div>
          <iframe
            className="email-preview-frame"
            title={emailPreview.name}
            src={emailPreview.url}
          />
        </div>
      ) : null;

      // Full width until an attachment is clicked, then split view
      return emailPreview ? (
        <div className="email-split">
          {emailPane}
          {previewPane}
        </div>
      ) : (
        <div className="email-full">{emailPane}</div>
      );
    }

    /* Trello modal (Real App Style) */
  if (currentView.app === "trello" && trelloCard) {
    const c = trelloCard;
    const fields = (c.customFields && Object.keys(c.customFields).length)
      ? c.customFields
      : parseCustomFieldsFromBadges(c.badges || []);

   return (
      <div className="trello-modal" style={{ maxWidth: "none", width: "calc(100% - 24px)", margin: "0 auto" }}>
        {/* 1. TOP BAR (Icon + Title + Close) */}
        {/* 1. TOP BAR (Icon + Title + Actions) */}
        {/* 1. TOP BAR (Icon + Title + Actions) */}
        {/* 1. TOP BAR (Icon + Title + Actions) */}
        <div className="trello-modal-topbar">
          <div className="trello-header-main">
            <div className="trello-icon-header">
               <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                  <rect x="3" y="5" width="18" height="14" rx="2" stroke="currentColor" strokeWidth="2"/>
                  <line x1="7" y1="9" x2="17" y2="9" stroke="currentColor" strokeWidth="2"/>
               </svg>
            </div>
            <div style={{ flex: 1 }}>
              <input 
                className="trello-title-input" 
                value={c.title} 
                onChange={(e) => setTrelloCard(prev => ({...prev, title: e.target.value}))}
              />
              <div className="trello-list-subtitle">
                in list <a href="#">{c.boardList || "Yolandie to Send"}</a>
              </div>
            </div>
          </div>
          
          {/* ACTIONS: Kebab Menu & Close */}
          <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
            
            <div className="kebab-wrap" style={{ position: 'relative' }}>
              <button 
                className="trello-close" 
                style={{ fontSize: '18px', paddingBottom: '8px' }} 
                onClick={(e) => { 
                  e.stopPropagation(); 
                  setTrelloMenuOpen(!trelloMenuOpen); 
                  setShowMoveSubmenu(false); 
                }}
              >
                
              </button>

              {/* DROPDOWN MENU */}
              {trelloMenuOpen && (
                <div style={{ position: 'absolute', right: 0, top: '40px', background: '#ffffff', boxShadow: '0 8px 16px -4px rgba(9,30,66,0.25), 0 0 0 1px rgba(9,30,66,0.08)', borderRadius: '3px', width: '300px', zIndex: 999, padding: showMoveSubmenu ? '0' : '8px 0', fontSize: '14px', color: '#172b4d' }}>
                  
                  {!showMoveSubmenu ? (
                    <>
                      <div style={{ padding: '0 12px 8px', borderBottom: '1px solid rgba(9,30,66,0.13)', marginBottom: '8px', fontWeight: 600, textAlign: 'center', fontSize: '14px', color: '#5e6c84' }}>
                        Actions
                      </div>
                      {/* MOVE OPTION */}
                      <div 
                        style={{ padding: '8px 16px', cursor: 'pointer', display: 'flex', justifyContent: 'space-between', color: '#172b4d' }}
                        onMouseEnter={e => e.currentTarget.style.background = '#091e420f'}
                        onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                        onClick={(e) => { 
                          e.stopPropagation(); 
                          setMoveTargetList(c.listId); 
                          
                          //  Set exact current position and clear old searches
                          const currentBucket = trelloBuckets.find(b => b.id === c.listId);
                          const currentPos = currentBucket ? currentBucket.cards.findIndex(x => x.id === c.id) + 1 : 1;
                          setMoveTargetPos(currentPos > 0 ? currentPos : 1);
                          
                          setMoveTab("outbox");
                          setMoveListSearch(""); 
                          setShowMoveSubmenu(true); 
                        }}
                      >
                        <span>Move</span>
                        <span></span>
                      </div>

                      {/* ARCHIVE / RESTORE OPTION */}
                      {c.isArchived ? (
                        <div 
                          style={{ padding: '8px 16px', cursor: 'pointer', color: '#172b4d' }}
                          onMouseEnter={e => e.currentTarget.style.background = '#091e420f'}
                          onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                          onClick={async (e) => {
                            e.stopPropagation();
                            const cid = c.id;
                            
                            // Optimistic Update
                            window.dispatchEvent(new Event("pauseTrelloPolling"));
                            setTrelloCard(prev => ({ ...prev, isArchived: false, boardList: "Restored" }));
                            setTrelloMenuOpen(false);

                            try {
                              await fetch("/.netlify/functions/trello-restore", {
                                method: "POST", headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ cardId: cid })
                              });
                            } catch (err) { console.error("Restore failed", err); }
                          }}
                        >
                          Restore
                        </div>
                      ) : (
                        <div 
                          style={{ padding: '8px 16px', cursor: 'pointer', color: '#172b4d' }}
                          onMouseEnter={e => e.currentTarget.style.background = '#091e420f'}
                          onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                          onClick={async (e) => {
                            e.stopPropagation();
                            const cid = c.id;
                            
                            // Optimistic Update
                            window.dispatchEvent(new Event("pauseTrelloPolling"));
                            setTrelloBuckets(prev => prev.map(b => ({ ...b, cards: b.cards.filter(card => card.id !== cid) })));
                            setTrelloMenuOpen(false);
                            setTrelloCard(null);

                            try {
                              await fetch("/.netlify/functions/trello-archive", {
                                method: "POST", headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ cardId: cid })
                              });
                            } catch (err) { console.error("Archive failed", err); }
                          }}
                        >
                          Archive
                        </div>
                      )}
                    </>
                  ) : (
                    /* SUB-MENU: MOVE CARD UI */
                    <div style={{ padding: '12px' }}>
                      {/* Header */}
                      <div style={{ display: 'flex', alignItems: 'center', marginBottom: '16px', position: 'relative', color: '#5e6c84' }}>
                        <button onClick={(e) => {e.stopPropagation(); setShowMoveSubmenu(false);}} style={{ position: 'absolute', left: 0, border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'18px' }}></button>
                        <div style={{ flex: 1, textAlign: 'center', fontWeight: 600, fontSize: '14px' }}>Move card</div>
                        <button onClick={(e) => {e.stopPropagation(); setTrelloMenuOpen(false); setShowMoveSubmenu(false);}} style={{ position: 'absolute', right: 0, border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'16px' }}></button>
                      </div>
                      
                      {/* Tabs */}
                      <div style={{ display: 'flex', gap: '16px', marginBottom: '16px', borderBottom: '2px solid #ebecf0' }}>
                        <div onClick={(e) => {e.stopPropagation(); setMoveTab('inbox'); setMoveTargetList(c.listId);}} style={{ paddingBottom: '8px', cursor: 'pointer', marginBottom: '-2px', color: moveTab === 'inbox' ? '#0052cc' : '#5e6c84', borderBottom: moveTab === 'inbox' ? '2px solid #0052cc' : '2px solid transparent', fontWeight: moveTab === 'inbox' ? 600 : 400 }}>Inbox</div>
                        <div onClick={(e) => {e.stopPropagation(); setMoveTab('outbox');}} style={{ paddingBottom: '8px', cursor: 'pointer', marginBottom: '-2px', color: moveTab === 'outbox' ? '#0052cc' : '#5e6c84', borderBottom: moveTab === 'outbox' ? '2px solid #0052cc' : '2px solid transparent', fontWeight: moveTab === 'outbox' ? 600 : 400 }}>Board</div>
                      </div>

                      {/* Body */}
                      {moveTab === 'inbox' && (
                        <div style={{ marginBottom: '16px' }}>
                          <label style={{ display:'block', fontSize:'12px', fontWeight:700, color:'#5e6c84', marginBottom:'4px' }}>Select position</label>
                          <select 
                             value={moveTargetPos} 
                             onChange={(e) => setMoveTargetPos(Number(e.target.value))} 
                             style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', background: '#fafbfc', color: '#172b4d', cursor: 'pointer', outline: 'none' }} 
                             onClick={e => e.stopPropagation()}
                          >
                             {Array.from({ length: Math.max(1, trelloBuckets.find(b => b.id === c.listId)?.cards.length || 1) }, (_, i) => (
                                <option key={i+1} value={i+1}>{i+1}</option>
                             ))}
                          </select>
                        </div>
                      )}

                      {moveTab === 'outbox' && (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', marginBottom: '16px' }}>
                          {/*  SEARCH BAR */}
                          <div>
                            <input 
                              type="text" 
                              placeholder="Search board lists..." 
                              value={moveListSearch}
                              onChange={(e) => {
                                  const val = e.target.value;
                                  setMoveListSearch(val);
                                  
                                  //  AUTO-SELECT FIX
                                  const uniqueMap = new Map();
                                  allTrelloLists.forEach(l => {
                                      if (!uniqueMap.has(l.title)) uniqueMap.set(l.title, l);
                                  });
                                  let unique = Array.from(uniqueMap.values());
                                  
                                  //  Remove junk lists after "Submitted August 2025"
                                  const cutoffIndex = unique.findIndex(l => l.title.toLowerCase().trim() === "submitted august 2025");
                                  if (cutoffIndex !== -1) unique = unique.slice(0, cutoffIndex + 1);

                                  const filtered = unique.filter(l => l.title.toLowerCase().includes(val.toLowerCase()));
                                  
                                  if (filtered.length > 0) {
                                      const firstMatch = filtered[0];
                                      setMoveTargetList(firstMatch.id);
                                      
                                      if (firstMatch.id === c.listId) {
                                          const cb = trelloBuckets.find(b => b.id === c.listId);
                                          const cp = cb ? cb.cards.findIndex(x => x.id === c.id) + 1 : 1;
                                          setMoveTargetPos(cp > 0 ? cp : 1);
                                      } else {
                                          setMoveTargetPos(1);
                                      }
                                  }
                              }}
                              onClick={e => e.stopPropagation()}
                              style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', background: '#fafbfc', color: '#172b4d', outline: 'none', fontSize: '13px' }}
                            />
                          </div>

                          <div style={{ display: 'flex', gap: '8px' }}>
                            <div style={{ flex: 2 }}>
                              <label style={{ display:'block', fontSize:'12px', fontWeight:700, color:'#5e6c84', marginBottom:'4px' }}>List</label>
                              <select 
                                 value={moveTargetList} 
                                 onChange={(e) => { setMoveTargetList(e.target.value); setMoveTargetPos(1); }} 
                                 style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', background: '#fafbfc', color: '#172b4d', cursor: 'pointer', outline: 'none' }} 
                                 onClick={e => e.stopPropagation()}
                              >
                                 {(() => {
                                    //  1. Deduplicate by name to remove Trello ghosts
                                    const uniqueMap = new Map();
                                    allTrelloLists.forEach(l => {
                                        if (!uniqueMap.has(l.title)) uniqueMap.set(l.title, l);
                                    });
                                    let unique = Array.from(uniqueMap.values());
                                    
                                    //  1.5 Cut off junk lists after "Submitted August 2025"
                                    const cutoffIndex = unique.findIndex(l => l.title.toLowerCase().trim() === "submitted august 2025");
                                    if (cutoffIndex !== -1) unique = unique.slice(0, cutoffIndex + 1);

                                    //  2. Filter the visual options by your search text
                                    const search = (moveListSearch || "").toLowerCase();
                                    const filtered = unique.filter(l => l.title.toLowerCase().includes(search));

                                    if (filtered.length === 0) return <option value="">No match found</option>;
                                    return filtered.map(b => <option key={b.id} value={b.id}>{b.title}</option>);
                                 })()}
                              </select>
                            </div>
                            <div style={{ flex: 1 }}>
                              <label style={{ display:'block', fontSize:'12px', fontWeight:700, color:'#5e6c84', marginBottom:'4px' }}>Position</label>
                              <select 
                                 value={moveTargetPos} 
                                 onChange={(e) => setMoveTargetPos(Number(e.target.value))} 
                                 style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', background: '#fafbfc', color: '#172b4d', cursor: 'pointer', outline: 'none' }} 
                                 onClick={e => e.stopPropagation()}
                              >
                                 {(() => {
                                    //  0ms LAG FIX: Check local trelloBuckets first for instant count
                                    const localBucket = trelloBuckets.find(b => b.id === moveTargetList);
                                    const globalBucket = allTrelloLists.find(b => b.id === moveTargetList);
                                    
                                    // Priority: Local State > Global Polled State > 0
                                    const currentCount = localBucket ? localBucket.cards.length : (globalBucket?.cardsLength || 0);
                                    
                                    const isSameList = moveTargetList === c.listId;
                                    const maxPos = isSameList ? Math.max(1, currentCount) : currentCount + 1;
                                    
                                    return Array.from({ length: maxPos }, (_, i) => (
                                       <option key={i+1} value={i+1}>{i+1}</option>
                                    ));
                                 })()}
                              </select>
                            </div>
                          </div>
                        </div>
                      )}

                      <button 
                        style={{ width: '100%', padding: '8px', borderRadius: '3px', fontWeight: 600, justifyContent: 'center', background: '#0052cc', color: '#fff', border: 'none', cursor: 'pointer' }}
                        onMouseEnter={e => e.currentTarget.style.background = '#0065ff'}
                        onMouseLeave={e => e.currentTarget.style.background = '#0052cc'}
                        onClick={async (e) => {
                          e.stopPropagation();
                          
                          const cid = c.id;
                          const targetId = moveTargetList;
                          const newIndex = moveTargetPos - 1; // 0-based for arrays
                          const targetName = trelloBuckets.find(b => b.id === targetId)?.title || c.boardList;

                          // 1. Optimistic Update: Move instantly on UI
                          window.dispatchEvent(new Event("pauseTrelloPolling"));
                          
                          // 2. ONLY notify if the card actually changed lists
                          // FIX: Directly use the card's known boardList instead of the missing Ref!
                          if (c.boardList && c.boardList !== targetName) {
                              window.dispatchEvent(new CustomEvent("notify", {
                                  detail: {
                                      text: `Card moved to ${targetName}: ${c.title}`,
                                      alt: "Trello",
                                      icon: trelloIcon,
                                      cardData: c,
                                      timestamp: new Date().toISOString()
                                  }
                              }));
                          }

                          // 3. Update memory to stop background poller from doing it again
                          window.dispatchEvent(new CustomEvent("updateTrelloMemory", { detail: { cardId: cid, listName: targetName } })); 
                          
                          setTrelloBuckets(prev => {
                            let cardToMove = null;
                            const stripped = prev.map(b => {
                                if (b.id === c.listId) {
                                    const idx = b.cards.findIndex(x => x.id === cid);
                                    if (idx > -1) {
                                        cardToMove = b.cards[idx];
                                        const newCards = [...b.cards];
                                        newCards.splice(idx, 1);
                                        return { ...b, cards: newCards };
                                    }
                                }
                                return b;
                            });
                            if (!cardToMove) return prev;
                            return stripped.map(b => {
                                if (b.id === targetId) {
                                    const newCards = [...b.cards];
                                    newCards.splice(newIndex, 0, cardToMove);
                                    return { ...b, cards: newCards };
                                }
                                return b;
                            });
                          });

                          setTrelloCard(prev => ({ ...prev, listId: targetId, boardList: targetName }));
                          setTrelloMenuOpen(false);
                          setShowMoveSubmenu(false);

                          // 2. Background Sync
                          try {
                            await fetch("/.netlify/functions/trello-move", {
                              method: "POST", headers: { "Content-Type": "application/json" },
                              body: JSON.stringify({ cardId: cid, targetListId: targetId, newIndex: newIndex })
                            });
                          } catch (err) { console.error("Move failed", err); }
                        }}
                      >
                        Move
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>

            <button 
              className="trello-close"
              onClick={() => { setTrelloMenuOpen(false); setTrelloCard(null); }}
            ></button>
          </div>
        </div>

        {/* 2. BODY (Columns) */}
        <div className="trello-modal-body" style={{ display: 'flex', gap: '24px' }}>
          
          {/* LEFT COLUMN (55%) */}
          <div className="trello-main-col" style={{ flex: "5.5", minWidth: 0 }}>
            
            {/* Action Row (Buttons under title) */}
            <div className="trello-action-row">
               
               {/*  NEW: Add Menu Wrapper & Popover UI */}
               <div className="add-menu-wrap" style={{ position: 'relative' }}>
                 <button 
                   className="t-btn-gray"
                   onClick={(e) => { e.stopPropagation(); setShowAddMenu(!showAddMenu); setAddMenuStep("main"); }}
                 >
                    <span>+</span> Add
                 </button>

                 {showAddMenu && (
                   <div style={{ position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: '#fff', border: '1px solid #dfe1e6', borderRadius: '3px', boxShadow: '0 8px 16px -4px rgba(9,30,66,0.25), 0 0 0 1px rgba(9,30,66,0.08)', width: '300px', zIndex: 1000, color: '#172b4d', fontSize: '14px' }}>
                     
                     {/* 1. MAIN MENU */}
                     {addMenuStep === "main" && (
                       <>
                         <div style={{ display: 'flex', alignItems: 'center', padding: '12px 12px 8px', borderBottom: '1px solid #091e4221', marginBottom: '8px', position: 'relative' }}>
                           <div style={{ flex: 1, textAlign: 'center', fontWeight: 600, color: '#5e6c84', fontSize: '14px' }}>Add to card</div>
                           <button onClick={(e) => { e.stopPropagation(); setShowAddMenu(false); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'16px', position: 'absolute', right: '12px' }}></button>
                         </div>
                         <div style={{ padding: '0 8px 12px', display: 'flex', flexDirection: 'column', gap: '2px' }}>
                           <div onClick={(e) => { e.stopPropagation(); setAddMenuStep("members"); }} style={{ padding: '8px', borderRadius: '3px', cursor: 'pointer', display: 'flex', gap: '12px', alignItems: 'center' }} onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'}>
                             <span style={{ fontSize: '16px' }}></span><div><div style={{ fontWeight: 500 }}>Members</div><div style={{ fontSize: '12px', color: '#5e6c84' }}>Assign members</div></div>
                           </div>
                           <div onClick={(e) => { e.stopPropagation(); setAddMenuStep("checklist"); }} style={{ padding: '8px', borderRadius: '3px', cursor: 'pointer', display: 'flex', gap: '12px', alignItems: 'center' }} onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'}>
                             <span style={{ fontSize: '16px' }}></span><div><div style={{ fontWeight: 500 }}>Checklist</div><div style={{ fontSize: '12px', color: '#5e6c84' }}>Add subtasks</div></div>
                           </div>
                           <div 
                             onClick={(e) => { 
                               e.stopPropagation(); 
                               setAddMenuStep("attachment");
                             }} 
                             style={{ padding: '8px', borderRadius: '3px', cursor: 'pointer', display: 'flex', gap: '12px', alignItems: 'center' }} 
                             onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} 
                             onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                           >
                             <span style={{ fontSize: '16px' }}></span><div><div style={{ fontWeight: 500 }}>Attachment</div><div style={{ fontSize: '12px', color: '#5e6c84' }}>Add links, pages, work items, and more</div></div>
                           </div>
                         </div>
                       </>
                     )}

                     {/* 2. CHECKLIST CREATION POPOVER */}
                     {addMenuStep === "checklist" && (
                        <>
                          <div style={{ display: 'flex', alignItems: 'center', padding: '12px 12px 8px', borderBottom: '1px solid #091e4221', marginBottom: '8px', position: 'relative' }}>
                            <button onClick={(e) => { e.stopPropagation(); setAddMenuStep("main"); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'18px', position: 'absolute', left: '12px' }}></button>
                            <div style={{ flex: 1, textAlign: 'center', fontWeight: 600, color: '#5e6c84', fontSize: '14px' }}>Add checklist</div>
                            <button onClick={(e) => { e.stopPropagation(); setShowAddMenu(false); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'16px', position: 'absolute', right: '12px' }}></button>
                          </div>
                          <div style={{ padding: '0 12px 12px' }}>
                            <label style={{ display: 'block', fontSize: '12px', fontWeight: 700, color: '#5e6c84', marginBottom: '4px' }}>Title</label>
                            <input autoFocus value={newChecklistTitle} onChange={e => setNewChecklistTitle(e.target.value)} onClick={e => e.stopPropagation()} style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #0079bf', outline: 'none', marginBottom: '16px', color: '#172b4d', fontSize: '14px', boxSizing: 'border-box' }} />

                            <label style={{ display: 'block', fontSize: '12px', fontWeight: 700, color: '#5e6c84', marginBottom: '4px' }}>Copy items from...</label>
                            <select value={copyFromChecklist} onChange={e => setCopyFromChecklist(e.target.value)} onClick={e => e.stopPropagation()} style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', outline: 'none', marginBottom: '16px', background: '#fafbfc', color: '#172b4d', fontSize: '14px', boxSizing: 'border-box' }}>
                              <option value="">(none)</option>
                              {checklists.map(cl => <option key={cl.id} value={cl.id}>{cl.name}</option>)}
                            </select>

                            <button 
                               className="btn-blue" 
                               onClick={async (e) => {
                                  e.stopPropagation();
                                  const title = newChecklistTitle || "Checklist";
                                  const tempId = "temp-" + Date.now();
                                  
                                  // Optimistic Update
                                  setChecklists(prev => [...prev, { id: tempId, name: title, checkItems: [] }]);
                                  setShowAddMenu(false);
                                  setNewChecklistTitle("Checklist"); 
                                  setCopyFromChecklist("");

                                  try {
                                      const res = await fetch("/.netlify/functions/trello-checklists", {
                                          method: "POST",
                                          body: JSON.stringify({ action: 'create_checklist', cardId: c.id, name: title, idChecklistSource: copyFromChecklist || null })
                                      });
                                      const realCl = await res.json();
                                      setChecklists(prev => prev.map(cl => cl.id === tempId ? realCl : cl));
                                  } catch(err) { console.error(err); }
                               }} 
                               style={{ padding: '6px 12px', borderRadius: '3px', border: 'none', background: '#0052cc', color: 'white', fontWeight: 500, cursor: 'pointer' }}
                            >
                               Add
                            </button>
                          </div>
                        </>
                     )}
{/* 2.5 ATTACHMENT POPOVER */}
                     {addMenuStep === "attachment" && (
                        <>
                          <div style={{ display: 'flex', alignItems: 'center', padding: '12px 12px 8px', borderBottom: '1px solid #091e4221', marginBottom: '8px', position: 'relative' }}>
                            <button onClick={(e) => { e.stopPropagation(); setAddMenuStep("main"); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'18px', position: 'absolute', left: '12px' }}></button>
                            <div style={{ flex: 1, textAlign: 'center', fontWeight: 600, color: '#5e6c84', fontSize: '14px' }}>Attach</div>
                            <button onClick={(e) => { e.stopPropagation(); setShowAddMenu(false); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'16px', position: 'absolute', right: '12px' }}></button>
                          </div>
                          
                          <div style={{ padding: '0 12px 12px' }}>
                            <div style={{ fontWeight: 600, fontSize: '14px', color: '#172b4d', marginBottom: '4px' }}>Attach a file from your computer</div>
                            <div style={{ fontSize: '14px', color: '#5e6c84', marginBottom: '12px', lineHeight: 1.4 }}>You can also drag and drop files to upload them.</div>
                            
                            <button
                              className="t-btn-gray"
                              style={{ width: '100%', justifyContent: 'center', padding: '8px', marginBottom: '16px', fontSize: '14px', fontWeight: 600 }}
                              onClick={(e) => {
                                 e.stopPropagation();
                                 trelloAttachmentRef.current?.click(); // Opens computer files
                                 setShowAddMenu(false);
                              }}
                            >
                              Choose a file
                            </button>

                            <hr style={{ border: 'none', borderTop: '1px solid #091e4221', margin: '0 -12px 16px -12px' }} />

                            <label style={{ display: 'block', fontSize: '12px', fontWeight: 700, color: '#5e6c84', marginBottom: '4px' }}>Search or paste a link <span style={{color: '#eb5a46'}}>*</span></label>
                            <input
                              type="text"
                              autoFocus
                              value={attachLink}
                              onChange={e => setAttachLink(e.target.value)}
                              onClick={e => e.stopPropagation()}
                              placeholder="Find recent links or paste a new link"
                              style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #0079bf', outline: 'none', marginBottom: '16px', color: '#172b4d', fontSize: '14px', boxSizing: 'border-box' }}
                            />

                            <label style={{ display: 'block', fontSize: '12px', fontWeight: 700, color: '#5e6c84', marginBottom: '4px' }}>Display text (optional)</label>
                            <input
                              type="text"
                              value={attachName}
                              onChange={e => setAttachName(e.target.value)}
                              onClick={e => e.stopPropagation()}
                              placeholder="Text to display"
                              style={{ width: '100%', padding: '8px 12px', borderRadius: '3px', border: '2px solid #dfe1e6', outline: 'none', marginBottom: '4px', color: '#172b4d', fontSize: '14px', boxSizing: 'border-box' }}
                            />
                            <div style={{ fontSize: '12px', color: '#5e6c84', marginBottom: '16px' }}>Give this link a title or description</div>

                            <button
                              className="btn-blue"
                              style={{ padding: '6px 16px', borderRadius: '3px', border: 'none', background: attachLink.trim() ? '#0052cc' : '#091e420f', color: attachLink.trim() ? 'white' : '#a5adba', fontWeight: 500, cursor: attachLink.trim() ? 'pointer' : 'not-allowed' }}
                              disabled={!attachLink.trim()}
                              onClick={async (e) => {
                                 e.stopPropagation();
                                 if (!attachLink.trim()) return;

                                 triggerSnackbar("Attaching link...");
                                 setShowAddMenu(false);
                                 setAttachLink("");
                                 setAttachName("");

                                 try {
                                     const res = await fetch("/.netlify/functions/trello-attach-link", {
                                         method: "POST",
                                         body: JSON.stringify({ cardId: c.id, url: attachLink, name: attachName })
                                     });
                                     if (res.ok) {
                                         const result = await res.json();
                                         triggerSnackbar("Link attached successfully!");
                                         //  Push instantly to UI
                                         setCardAttachments(prev => [...prev, result.attachment]);
                                     } else {
                                         triggerSnackbar("Failed to attach link");
                                     }
                                 } catch(err) { console.error(err); }
                              }}
                            >
                              Insert
                            </button>
                          </div>
                        </>
                     )}
                     {/* 3. MEMBERS ASSIGNMENT POPOVER */}
                     {addMenuStep === "members" && (
                        <>
                          <div style={{ display: 'flex', alignItems: 'center', padding: '12px 12px 8px', borderBottom: '1px solid #091e4221', marginBottom: '8px', position: 'relative' }}>
                            <button onClick={(e) => { e.stopPropagation(); setAddMenuStep("main"); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'18px', position: 'absolute', left: '12px' }}></button>
                            <div style={{ flex: 1, textAlign: 'center', fontWeight: 600, color: '#5e6c84', fontSize: '14px' }}>Members</div>
                            <button onClick={(e) => { e.stopPropagation(); setShowAddMenu(false); }} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'16px', position: 'absolute', right: '12px' }}></button>
                          </div>
                          <div style={{ padding: '0 12px 12px', maxHeight: '300px', overflowY: 'auto' }}>
                            <div style={{ fontWeight: 600, fontSize: '12px', color: '#5e6c84', marginBottom: '8px' }}>Board members</div>
                            {trelloMembers.length === 0 && <div style={{ fontSize: '12px', color: '#5e6c84' }}>Loading members...</div>}
                            
                            {/* DYNAMIC SORT */}
                            {(() => {
                               const sortedMembers = [...trelloMembers].sort((a, b) => {
                                  const aAssigned = (c.members || []).some(m => m === a.fullName || m === a.id);
                                  const bAssigned = (c.members || []).some(m => m === b.fullName || m === b.id);
                                  if (aAssigned === bAssigned) return a.fullName.localeCompare(b.fullName);
                                  return aAssigned ? -1 : 1;
                               });

                               return sortedMembers.map(member => {
                                  const isAssigned = (c.members || []).some(m => m === member.fullName || m === member.id);
                                  return (
                                    <div 
                                      key={member.id} 
                                      onMouseEnter={e => e.currentTarget.style.background = isAssigned ? '#e6fcff' : '#091e420f'} 
                                      onMouseLeave={e => e.currentTarget.style.background = isAssigned ? '#e6fcff' : 'transparent'}
                                      onClick={async (e) => {
                                         e.stopPropagation();
                                         const newMembers = isAssigned 
                                           ? c.members.filter(m => m !== member.fullName && m !== member.id)
                                           : [...(c.members || []), member.fullName];
                                           
                                         window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Members", ttlMs: 10000 } }));
                                         setTrelloCard(prev => ({ ...prev, members: newMembers }));
                                         
                                         try {
                                           fetch("/.netlify/functions/trello-toggle-member", {
                                             method: "POST", headers: { "Content-Type": "application/json" },
                                             body: JSON.stringify({ cardId: c.id, memberId: member.id, shouldAdd: !isAssigned })
                                           });
                                           window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                             detail: { cardId: c.id, updater: old => ({ ...old, people: newMembers }) }
                                           }));
                                         } catch (err) { console.error("Member toggle failed", err); }
                                      }} 
                                      style={{ display: 'flex', alignItems: 'center', padding: '6px', cursor: 'pointer', borderRadius: '3px', background: isAssigned ? '#e6fcff' : 'transparent', marginBottom: '2px' }}
                                    >
                                      {member.avatarUrl 
                                        ? <img src={member.avatarUrl} alt="" style={{ width: 32, height: 32, borderRadius: '50%', marginRight: 12 }} /> 
                                        : <div style={{ width: 32, height: 32, borderRadius: '50%', background: '#dfe1e6', color: '#172b4d', marginRight: 12, display: 'grid', placeItems: 'center', fontWeight: 600 }}>{member.fullName[0]}</div>
                                      }
                                      <span style={{ flex: 1, fontWeight: 500, fontSize: '14px' }}>{member.fullName}</span>
                                      {isAssigned && <span style={{ color: '#0079bf', fontWeight: 'bold' }}></span>}
                                    </div>
                                  );
                               });
                            })()}
                          </div>
                        </>
                     )}

                   </div>
                 )}
               </div>
            </div>

            {/* Members & Labels Section (Fixed Layout & Sizing) */}
            <div style={{ display: 'flex', gap: 24, marginBottom: 24, paddingLeft: 40, flexWrap: 'wrap' }}>
               
               {/* 1. Members Group */}
               <div>
                  <h3 className="trello-group-label">Members</h3>
                  <div style={{ display: 'flex', gap: 4, alignItems: 'center' }}>
          {(c.members || []).map((m, i) => {
            const img = avatarFor(m);
           
            //  FIX: Safe string calculation prevents crashes on empty or weird member IDs
            const initials = String(m || "U").split(' ').map(n => n?.[0] || "").join('').substring(0, 2).toUpperCase();
                        
                        return (
                           <div 
                              key={i} 
                              title={m}
                              style={{ 
                                width: '32px', height: '32px', borderRadius: '50%', 
                                background: img ? 'transparent' : '#dfe1e6', 
                                color: '#172b4d', display: 'grid', placeItems: 'center', 
                                fontWeight: 600, fontSize: '13px', overflow: 'hidden'
                              }}
                           >
                              {img ? <img src={img} alt={m} style={{ width: '100%', height: '100%', objectFit: 'cover' }} /> : initials}
                           </div>
                        );
                     })}
                     {/* SHORTCUT MENU WRAPPER */}
                     <div className="member-shortcut-wrap" style={{ position: 'relative' }}>
                         <button 
                            className="round-btn-gray" 
                            title="Add member"
                            style={{ display: 'grid', placeItems: 'center', padding: 0 }}
                            onClick={(e) => { e.stopPropagation(); setShowMemberShortcut(!showMemberShortcut); }}
                         >
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M13 11V5C13 4.44772 12.5523 4 12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13Z"/></svg>
                         </button>

                         {showMemberShortcut && (
                            <div style={{ position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: '#fff', border: '1px solid #dfe1e6', borderRadius: '3px', boxShadow: '0 8px 16px -4px rgba(9,30,66,0.25), 0 0 0 1px rgba(9,30,66,0.08)', width: '300px', zIndex: 1000, color: '#172b4d', fontSize: '14px' }}>
                               <div style={{ display: 'flex', alignItems: 'center', padding: '12px 12px 8px', borderBottom: '1px solid #091e4221', marginBottom: '8px', position: 'relative' }}>
                                 <div style={{ flex: 1, textAlign: 'center', fontWeight: 600, color: '#5e6c84', fontSize: '14px' }}>Members</div>
                                 <button onClick={() => setShowMemberShortcut(false)} style={{ border:'none', background:'none', cursor:'pointer', color:'#42526e', fontSize:'16px', position: 'absolute', right: '12px' }}></button>
                               </div>
                               <div style={{ padding: '0 12px 12px', maxHeight: '300px', overflowY: 'auto' }}>
                                 <div style={{ fontWeight: 600, fontSize: '12px', color: '#5e6c84', marginBottom: '8px' }}>Board members</div>
                                 {trelloMembers.length === 0 && <div style={{ fontSize: '12px', color: '#5e6c84' }}>Loading members...</div>}
                                 
                                 {(() => {
                                    const sortedMembers = [...trelloMembers].sort((a, b) => {
                                       const aAssigned = (c.members || []).some(m => m === a.fullName || m === a.id);
                                       const bAssigned = (c.members || []).some(m => m === b.fullName || m === b.id);
                                       if (aAssigned === bAssigned) return a.fullName.localeCompare(b.fullName);
                                       return aAssigned ? -1 : 1;
                                    });

                                    return sortedMembers.map(member => {
                                       const isAssigned = (c.members || []).some(m => m === member.fullName || m === member.id);
                                       return (
                                         <div 
                                           key={member.id} 
                                           onMouseEnter={e => e.currentTarget.style.background = isAssigned ? '#e6fcff' : '#091e420f'} 
                                           onMouseLeave={e => e.currentTarget.style.background = isAssigned ? '#e6fcff' : 'transparent'}
                                           onClick={async (e) => {
                                              e.stopPropagation();
                                              const newMembers = isAssigned 
                                                ? c.members.filter(m => m !== member.fullName && m !== member.id)
                                                : [...(c.members || []), member.fullName];
                                                
                                              window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Members", ttlMs: 10000 } }));
                                              setTrelloCard(prev => ({ ...prev, members: newMembers }));
                                              
                                              try {
                                                fetch("/.netlify/functions/trello-toggle-member", {
                                                  method: "POST", headers: { "Content-Type": "application/json" },
                                                  body: JSON.stringify({ cardId: c.id, memberId: member.id, shouldAdd: !isAssigned })
                                                });
                                                window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                                  detail: { cardId: c.id, updater: old => ({ ...old, people: newMembers }) }
                                                }));
                                              } catch (err) { console.error("Member toggle failed", err); }
                                           }} 
                                           style={{ display: 'flex', alignItems: 'center', padding: '6px', cursor: 'pointer', borderRadius: '3px', background: isAssigned ? '#e6fcff' : 'transparent', marginBottom: '2px' }}
                                         >
                                           {member.avatarUrl 
                                       ? <img src={member.avatarUrl.endsWith('.png') ? member.avatarUrl : member.avatarUrl + '/50.png'} alt="" style={{ width: 32, height: 32, borderRadius: '50%', marginRight: 12, objectFit: 'cover' }} /> 
                                       : <div style={{ width: 32, height: 32, borderRadius: '50%', background: '#dfe1e6', color: '#172b4d', marginRight: 12, display: 'grid', placeItems: 'center', fontWeight: 600 }}>
                                           {member.fullName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase()}
                                         </div>
                                     }
                                           <span style={{ flex: 1, fontWeight: 500, fontSize: '14px' }}>{member.fullName}</span>
                                           {isAssigned && <span style={{ color: '#0079bf', fontWeight: 'bold' }}></span>}
                                         </div>
                                       );
                                    });
                                 })()}
                               </div>
                            </div>
                         )}
                     </div>
                  </div>
               </div>

               {/* 2. Labels Group */}
               <div style={{ position: 'relative' }}>
                  <h3 className="trello-group-label">Labels</h3>
                  <div style={{ display: 'flex', gap: 4, flexWrap: 'wrap', alignItems: 'center' }}>
                     {/* Render actual active labels - NOW CLICKABLE */}
                     {(c.labels || []).map((l, i) => {
                        const style = getLabelStyle(l);
                        return (
                           <div 
                             key={i} 
                             className="label-pill-large" 
                             style={style}
                             onClick={(e) => { e.stopPropagation(); setShowLabelPicker(true); }}
                           >
                              {l}
                           </div>
                        );
                     })}
                     
                     {/* Plus Button */}
                     <button 
                        className="rect-btn-gray" 
                        title="Add label"
                        style={{ display: 'grid', placeItems: 'center', padding: 0 }}
                        onClick={(e) => { e.stopPropagation(); setShowLabelPicker(!showLabelPicker); }}
                     >
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M13 11V5C13 4.44772 12.5523 4 12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13Z"/></svg>
                     </button>

                     {/*  POPUP LABEL PICKER (Checkboxes)  */}
                     {showLabelPicker && (
                       <div className="label-picker-popover" onClick={(e) => e.stopPropagation()}>
                         <div className="label-picker-header">
                           <span>Labels</span>
                           <button 
                             className="label-picker-close" 
                             onClick={(e) => { e.stopPropagation(); setShowLabelPicker(false); }}
                           ></button>
                         </div>
                         <div className="label-picker-list">
                           {ALL_LABEL_OPTIONS.map((opt) => {
                             const isActive = (c.labels || []).includes(opt.name);
                             return (
                               <div key={opt.name} className="label-picker-row">
                                 <div 
                                   className="label-picker-pill" 
                                   style={{ backgroundColor: opt.bg, color: opt.color, display: 'flex', alignItems: 'center', gap: '8px' }}
                                   onClick={async (e) => {
                                      e.stopPropagation(); // Prevent closing
                                      
                                      // 1. Optimistic Update
                                      const newLabels = isActive 
                                        ? c.labels.filter(l => l !== opt.name)
                                        : [...(c.labels || []), opt.name];
                                      
                                      setTrelloCard(prev => ({ ...prev, labels: newLabels }));

                                      try {
                                        // 2. Call Backend
                                        await fetch("/.netlify/functions/trello-toggle-label", {
                                          method: "POST",
                                          body: JSON.stringify({ 
                                            cardId: c.id, 
                                            labelName: opt.name, 
                                            shouldAdd: !isActive 
                                          })
                                        });
                                        
                                        // 3. Patch bucket
                                        window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                          detail: { cardId: c.id, updater: old => ({ ...old, labels: newLabels }) }
                                        }));
                                      } catch(err) {
                                        console.error("Label toggle failed", err);
                                      }
                                   }}
                                 >
                                   {/* CHECKBOX ON LEFT */}
                                   <input 
                                     type="checkbox" 
                                     checked={isActive} 
                                     readOnly 
                                     style={{ cursor: 'pointer', width: 16, height: 16 }} 
                                   />
                                   <span style={{flex: 1}}>{opt.name}</span>
                                 </div>
                                 <button className="label-edit-icon"></button>
                               </div>
                             );
                           })}
                         </div>
                       </div>
                     )}
                  </div>
               </div>
            </div>

            {/* Description */}
            <div className="trello-section">
              <div className="trello-section-icon"></div>
              <div className="trello-section-header">
                 <h3 className="trello-h3">Description</h3>
                 {!descEditing && (
                   <button 
                     className="t-btn-gray"
                     onClick={() => { setDescDraft(c.description || ""); setDescEditing(true); }}
                   >Edit</button>
                 )}
              </div>
              {!descEditing ? (
                 <div 
                   className="desc-box-fake"
                   onClick={() => { setDescDraft(c.description || ""); setDescEditing(true); }}
                   style={{ minHeight: '60px', whiteSpace: 'pre-wrap' }}
                 >
                   {c.description || <span style={{color:'#5e6c84'}}>Add a more detailed description...</span>}
                 </div>
              ) : (
                 <div style={{ display:'flex', flexDirection:'column', gap: 8 }}>
                   <textarea 
                     className="trello-title-input"
                     style={{ minHeight: 108, border: '2px solid #0079bf', background:'#fff', fontSize:14, fontWeight:400, padding: '8px 12px', resize:'vertical' }}
                     value={descDraft}
                     onChange={e => setDescDraft(e.target.value)}
                     autoFocus
                     placeholder="Add a more detailed description..."
                   />
                   <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
                      <button 
                        className="btn-blue"
                        onClick={async () => {
                          const newDesc = descDraft;
                          const prevDesc = c.description;
                          
                          // 1. Optimistic Update (Instant on screen)
                          setTrelloCard(prev => ({ ...prev, description: newDesc }));
                          setDescEditing(false);

                          try {
                            // 2. Send to Trello (Backend)
                            await setCardDescription(c.id, newDesc);
                            
                            // 3. Update the hidden list view so it sticks if you close/reopen
                            window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                              detail: { cardId: c.id, updater: old => ({ ...old, description: newDesc }) }
                            }));
                          } catch (err) {
                            console.error(err);
                            // Revert on failure
                            setTrelloCard(prev => ({ ...prev, description: prevDesc }));
                            alert("Failed to save description");
                          }
                        }}
                      >
                        Save
                      </button>
                      <button 
                        className="t-btn-gray" 
                        onClick={() => setDescEditing(false)}
                      >
                        Cancel
                      </button>
                   </div>
                 </div>
              )}
            </div>

            {/* Custom Fields (GRID LAYOUT) */}
            <div className="trello-section">
               <div className="trello-section-icon">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                     <rect x="3" y="3" width="18" height="18" rx="2" />
                     <line x1="3" y1="9" x2="21" y2="9" />
                  </svg>
               </div>
               <div className="trello-section-header">
                  <h3 className="trello-h3">Custom Fields</h3>
               </div>
               
               <div className="cf-grid">
                  {/* 1. Priority */}
                  <div className="cf-item">
                     <span className="cf-label">Priority</span>
                     <select 
                        className={`cf-select-box ${getCFColorClass("Priority", fields.priority)}`}
                        value={fields.priority || ""}
                        onChange={async (e) => {
                           const val = e.target.value;
                           
                           // 1. Optimistic UI Update
                           setTrelloCard(prev => {
                              const cleanBadges = (prev.badges || []).filter(b => !b.text.startsWith("Priority:"));
                              if (val) cleanBadges.push({ text: `Priority: ${val}`, isBottom: true });
                              return { 
                                 ...prev, 
                                 badges: ensureBadgeTypes(cleanBadges),
                                 customFields: { ...prev.customFields, priority: val }
                              };
                           });

                           // 2. Notify other components
                           window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Priority" } }));

                           // 3. Save to Backend (Using YOUR existing function)
                           try {
                              await fetch("/.netlify/functions/trello-set-custom-field", {
                                 method: "POST",
                                 body: JSON.stringify({ 
                                    cardId: c.id, 
                                    fieldName: "Priority", 
                                    valueText: val //  Match your function's expected key
                                 })
                              });
                              // Force update buckets to keep everything in sync
                              window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                 detail: { cardId: c.id, updater: old => ({ ...old, customFields: { ...old.customFields, Priority: val } }) }
                              }));
                           } catch (err) { console.error("Priority save failed", err); }
                        }} 
                     >
                        <option value="">(None)</option>
                        {PRIORITY_OPTIONS.map(o => <option key={o} value={o}>{o}</option>)}
                     </select>
                  </div>

                  {/* 2. Status */}
                  <div className="cf-item">
                     <span className="cf-label">Status</span>
                     <select 
                        className={`cf-select-box ${getCFColorClass("Status", fields.status)}`}
                        value={fields.status || ""}
                        onChange={async (e) => {
                           const val = e.target.value;
                           
                           setTrelloCard(prev => {
                              const cleanBadges = (prev.badges || []).filter(b => !b.text.startsWith("Status:"));
                              if (val) cleanBadges.push({ text: `Status: ${val}`, isBottom: true });
                              return { 
                                 ...prev, 
                                 badges: ensureBadgeTypes(cleanBadges),
                                 customFields: { ...prev.customFields, status: val }
                              };
                           });
                           
                           window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Status" } }));

                           try {
                              await fetch("/.netlify/functions/trello-set-custom-field", {
                                 method: "POST",
                                 body: JSON.stringify({ 
                                    cardId: c.id, 
                                    fieldName: "Status", 
                                    valueText: val 
                                 })
                              });
                              window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                 detail: { cardId: c.id, updater: old => ({ ...old, customFields: { ...old.customFields, Status: val } }) }
                              }));
                           } catch (err) { console.error("Status save failed", err); }
                        }}
                     >
                        <option value="">(None)</option>
                        {STATUS_OPTIONS.map(o => <option key={o} value={o}>{o}</option>)}
                     </select>
                  </div>

                  {/* 3. Active */}
                  <div className="cf-item">
                     <span className="cf-label">Active</span>
                     <select 
                        className={`cf-select-box ${getCFColorClass("Active", fields.active)}`}
                        value={fields.active || ""}
                        onChange={async (e) => {
                           const val = e.target.value;

                           setTrelloCard(prev => {
                              const cleanBadges = (prev.badges || []).filter(b => !b.text.startsWith("Active:"));
                              if (val) cleanBadges.push({ text: `Active: ${val}`, isBottom: true });
                              return { 
                                 ...prev, 
                                 badges: ensureBadgeTypes(cleanBadges),
                                 customFields: { ...prev.customFields, active: val }
                              };
                           });

                           window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Active" } }));

                           try {
                              await fetch("/.netlify/functions/trello-set-custom-field", {
                                 method: "POST",
                                 body: JSON.stringify({ 
                                    cardId: c.id, 
                                    fieldName: "Active", 
                                    valueText: val 
                                 })
                              });
                              window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                 detail: { cardId: c.id, updater: old => ({ ...old, customFields: { ...old.customFields, Active: val } }) }
                              }));
                           } catch (err) { console.error("Active save failed", err); }
                        }}
                     >
                        <option value="">(None)</option>
                        {ACTIVE_OPTIONS.map(o => <option key={o} value={o}>{o}</option>)}
                     </select>
                  </div>
               </div>
            </div>

             {/* WORKFLOW TIMER (NEW) */}
            <div className="trello-section">
               <div className="trello-section-icon">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                     <circle cx="12" cy="12" r="10" />
                     <path d="M12 6v6l4 2" />
                  </svg>
               </div>
               <div className="trello-section-header">
                  <h3 className="trello-h3">WorkFlow</h3>
               </div>
               
               <div className="timer-row" style={{ position: 'relative', display: 'flex', alignItems: 'center', gap: '12px' }}>
                  
                  {c.isArchived ? (
                     <div style={{ color: '#5e6c84', fontSize: '13px', fontWeight: 600, padding: '6px 12px', background: '#091e420f', borderRadius: '4px' }}>
                        Read-Only (Restore card to track time)
                     </div>
                  ) : parseFloat(c.customFields?.WorkTimerStart) > 1000000000000 ? (
                      <button 
                        className="btn-red" 
                        style={{ backgroundColor: '#eb5a46', color: '#fff', border: 'none', borderRadius: 3, padding: '6px 12px', fontWeight: 600, cursor: 'pointer', width: '105px', textAlign: 'center' }}
                        onClick={async () => {
                           const stopTime = Date.now();
                           const startTime = parseFloat(c.customFields.WorkTimerStart);
                           const sessionMins = (stopTime - startTime) / 1000 / 60;
                           const oldDur = parseFloat(c.customFields.WorkDuration || "0");
                           const newTotal = (oldDur + sessionMins).toFixed(2);
                           
                           //  Lock UI state so it doesn't flicker during refresh
                           window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "WorkDuration", ttlMs: 30000 } }));
                           window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "WorkTimerStart", ttlMs: 30000 } }));

                           setTrelloCard(prev => ({
                              ...prev, customFields: { ...prev.customFields, WorkTimerStart: null, WorkDuration: newTotal }
                           }));

                           window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                              detail: { cardId: c.id, updater: old => ({ 
                                 ...old, customFields: { ...old.customFields, WorkTimerStart: null, WorkDuration: newTotal } 
                              }) }
                           }));

                           try {
                              //  FIX: Sending both valueText AND valueNumber prevents Trello from rejecting the data format!
                              await fetch("/.netlify/functions/trello-set-custom-field", {
                                 method: "POST", body: JSON.stringify({ cardId: c.id, fieldName: "[SYSTEM]WorkDuration", valueText: String(newTotal), valueNumber: parseFloat(newTotal) })
                              });
                              await fetch("/.netlify/functions/trello-set-custom-field", {
                                 method: "POST", body: JSON.stringify({ cardId: c.id, fieldName: "[SYSTEM]WorkTimerStart", valueText: "", valueNumber: null })
                              });
                           } catch(err) { console.error("WorkFlow Timer Stop Failed", err); }
                        }}
                      >
                        Stop
                      </button>
                  ) : (
                      <button 
                        className="btn-yellow"
                        style={{ backgroundColor: '#f2d600', color: '#172b4d', border: 'none', borderRadius: 3, padding: '6px 12px', fontWeight: 600, cursor: 'pointer', width: '105px', textAlign: 'center' }}
                        onClick={async () => {
                           const now = Date.now();
                           
                           //  Lock UI state
                           window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "WorkTimerStart", ttlMs: 30000 } }));
                           
                           setTrelloCard(prev => ({
                              ...prev, customFields: { ...prev.customFields, WorkTimerStart: now }
                           }));
                           
                           window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                              detail: { cardId: c.id, updater: old => ({ 
                                 ...old, customFields: { ...old.customFields, WorkTimerStart: now } 
                              }) }
                           }));
                           
                           try {
                              //  FIX: Sending both valueText AND valueNumber
                              await fetch("/.netlify/functions/trello-set-custom-field", {
                                 method: "POST", body: JSON.stringify({ cardId: c.id, fieldName: "[SYSTEM]WorkTimerStart", valueText: String(now), valueNumber: now })
                              });
                           } catch(err) { console.error("WorkFlow Timer Start Failed", err); }
                        }}
                      >
                        Start timer
                      </button>
                  )}

                  <div className="timer-display">
                     {/* Pass null for start time if archived, so the clock stops ticking visually! */}
                     <LiveTimer 
                        startTime={!c.isArchived ? c.customFields?.WorkTimerStart : null} 
                        duration={c.customFields?.WorkDuration} 
                     />
                  </div>  
               </div>
            </div>

            {/* Activity Timer */}
            <div className="trello-section">
               <div className="trello-section-icon">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                     <circle cx="12" cy="12" r="10" />
                     <polyline points="12 6 12 12 16 14" />
                  </svg>
               </div>
               <div className="trello-section-header">
                  <h3 className="trello-h3">Activity Timer</h3>
               </div>
               
               <div className="timer-row" style={{ position: 'relative' }}>
                      
                      {c.isArchived ? (
                         <div style={{ color: '#5e6c84', fontSize: '13px', fontWeight: 600, padding: '6px 12px', background: '#091e420f', borderRadius: '4px', display: 'inline-block', marginBottom: '8px' }}>
                            Read-Only (Restore card to track time)
                         </div>
                      ) : c.customFields?.TimerStart ? (
                          <button 
                            className="btn-red" 
                            style={{ backgroundColor: '#eb5a46', color: '#fff', border: 'none', borderRadius: 3, padding: '6px 12px', fontWeight: 600, cursor: 'pointer' }}
                            onClick={async () => {
                               const stopTime = Date.now();
                               const startTime = parseFloat(c.customFields.TimerStart);
                               const sessionMins = (stopTime - startTime) / 1000 / 60;
                               const oldDur = parseFloat(c.customFields.Duration || "0");
                               const newTotal = (oldDur + sessionMins).toFixed(2);
                               
                               window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Duration", ttlMs: 10000 } }));
                               window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "TimerStart", ttlMs: 10000 } }));

                               setTrelloCard(prev => ({
                                  ...prev, customFields: { ...prev.customFields, TimerStart: null, Duration: newTotal }
                               }));

                               await fetch("/.netlify/functions/trello-timer", {
                                  method: "POST", body: JSON.stringify({ cardId: c.id, action: "stop" })
                               });
                               
                               window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                  detail: { cardId: c.id, updater: old => ({ 
                                     ...old, customFields: { ...old.customFields, TimerStart: null, Duration: newTotal } 
                                  }) }
                               }));
                            }}
                          >
                            Stop
                          </button>
                      ) : (
                          <button 
                            className="btn-blue"
                            onClick={async () => {
                               const now = Date.now();
                               
                               window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "TimerStart", ttlMs: 10000 } }));

                               setTrelloCard(prev => ({
                                  ...prev, customFields: { ...prev.customFields, TimerStart: now }
                               }));

                               await fetch("/.netlify/functions/trello-timer", {
                                  method: "POST", body: JSON.stringify({ cardId: c.id, action: "start" })
                               });

                               window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                  detail: { cardId: c.id, updater: old => ({ 
                                     ...old, customFields: { ...old.customFields, TimerStart: now } 
                                  }) }
                               }));
                            }}
                          >
                            Start timer
                          </button>
                      )}

                      {!c.isArchived && (
                         <button 
                            className="t-btn-gray" 
                            title="Add manual time"
                            onClick={() => setShowAddTime(!showAddTime)}
                         >
                            <span>+</span> Add time
                         </button>
                      )}

                      {/* POPUP FOR MANUAL TIME */}
                      {showAddTime && !c.isArchived && (
                        <div className="label-picker-popover" style={{ width: 260, top: 45, left: 80, padding: 16, cursor: 'default' }}>
                           <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
                              <span style={{ fontWeight: 600, color: '#172b4d' }}>Add time tracking</span>
                              <button onClick={() => setShowAddTime(false)} style={{ border: 'none', background: 'transparent', cursor: 'pointer', fontSize: 16 }}></button>
                           </div>
                           
                           <div style={{ display: 'flex', gap: 12, marginBottom: 16 }}>
                              <div style={{ flex: 1 }}>
                                 <label style={{ display: 'block', fontSize: 12, fontWeight: 600, color: '#5e6c84', marginBottom: 4 }}>Hours</label>
                                 <input 
                                    type="number" min="0" 
                                    value={manualHours} 
                                    onChange={e => setManualHours(e.target.value)}
                                    style={{ width: '100%', padding: '6px 8px', borderRadius: 3, border: '2px solid #dfe1e6' }}
                                 />
                              </div>
                              <div style={{ flex: 1 }}>
                                 <label style={{ display: 'block', fontSize: 12, fontWeight: 600, color: '#5e6c84', marginBottom: 4 }}>Minutes</label>
                                 <input 
                                    type="number" min="0" 
                                    value={manualMins} 
                                    onChange={e => setManualMins(e.target.value)}
                                    style={{ width: '100%', padding: '6px 8px', borderRadius: 3, border: '2px solid #dfe1e6' }}
                                 />
                              </div>
                           </div>

                           <button 
                              className="btn-blue" 
                              style={{ width: '100%', justifyContent: 'center' }}
                              onClick={async () => {
                                 const h = parseFloat(manualHours) || 0;
                                 const m = parseFloat(manualMins) || 0;
                                 const addedMinutes = (h * 60) + m;

                                 if (addedMinutes > 0) {
                                    const oldDur = parseFloat(c.customFields.Duration || "0");
                                    const newTotal = (oldDur + addedMinutes).toFixed(2);

                                    window.dispatchEvent(new CustomEvent("pendingCF", { detail: { cardId: c.id, field: "Duration", ttlMs: 10000 } }));

                                    setTrelloCard(prev => ({
                                       ...prev,
                                       customFields: { ...prev.customFields, Duration: newTotal }
                                    }));
                                    setShowAddTime(false);
                                    setManualHours("0");
                                    setManualMins("0");

                                    await fetch("/.netlify/functions/trello-set-custom-field", {
                                       method: "POST",
                                       body: JSON.stringify({ 
                                          cardId: c.id, 
                                          fieldName: "Duration", 
                                          valueText: newTotal 
                                       })
                                    });

                                    window.dispatchEvent(new CustomEvent("patchCardInBuckets", {
                                       detail: { cardId: c.id, updater: old => ({ 
                                          ...old, customFields: { ...old.customFields, Duration: newTotal } 
                                       }) }
                                    }));
                                 }
                              }}
                           >
                              Add time
                           </button>
                        </div>
                      )}
                      
                      {/* LIVE COUNTER */}
                      <div className="timer-display">
                         <LiveTimer 
                            startTime={!c.isArchived ? c.customFields?.TimerStart : null} 
                            duration={c.customFields?.Duration} 
                         />
                      </div>

                      <div className="timer-estimate" style={{marginLeft:8, fontSize:12, color:'#5e6c84'}}>
                         Estimate: 0m
                      </div>
                   </div>
               
               {/*  BANNER REMOVED */}
            </div>
{/*  ATTACHMENTS RENDERER */}
            {cardAttachments.length > 0 && (
              <div className="trello-section" style={{ position: 'relative', marginTop: '24px', paddingLeft: '40px' }}>
                
                {/*  FIX: Absolute position on the icon prevents "ttachments" text clipping */}
                <div style={{ position: 'absolute', left: '0px', top: '2px', color: '#42526e' }}>
                   <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                </div>
                
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                   <h3 style={{ fontSize: '16px', fontWeight: 600, color: '#172b4d', margin: 0 }}>Attachments</h3>
                   <button className="t-btn-gray" style={{ padding: '6px 12px', fontSize: '14px' }} onClick={(e) => { e.stopPropagation(); setShowAddMenu(true); setAddMenuStep("attachment"); }}>Add</button>
                </div>
                
                <div style={{ display: 'flex', flexDirection: 'column', gap: '24px' }}>
                   
                   {/*  1. LINKS SECTION */}
                   {cardAttachments.filter(a => a.isUpload === false).length > 0 && (
                     <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                       <div style={{ fontSize: '14px', fontWeight: 600, color: '#5e6c84', marginBottom: '4px' }}>Links</div>
                       {cardAttachments.filter(a => a.isUpload === false).map(att => (
                         <div key={att.id} style={{ display: 'flex', alignItems: 'center', gap: '12px', padding: '10px 12px', background: '#fafbfc', border: '1px solid #dfe1e6', borderRadius: '4px' }}>
                           {/* Sleek Blue Link Icon */}
                           <div style={{ color: '#0052cc', display: 'grid', placeItems: 'center', flexShrink: 0, width: '24px', height: '24px', background: '#e6fcff', borderRadius: '4px' }}>
                              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h10v2H4z"/></svg>
                           </div>
                           <div style={{ flex: 1, minWidth: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                               <a href={att.url} target="_blank" rel="noopener noreferrer" style={{ color: '#0052cc', fontWeight: 500, fontSize: '14px', textDecoration: 'none', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', display: 'block' }} onMouseEnter={e => e.currentTarget.style.textDecoration = 'underline'} onMouseLeave={e => e.currentTarget.style.textDecoration = 'none'}>
                                 {att.name || att.url}
                               </a>
                               <button onClick={async (e) => {
                                  e.stopPropagation();
                                  if(!window.confirm("Delete link?")) return;
                                  setCardAttachments(prev => prev.filter(a => a.id !== att.id));
                                  await fetch("/.netlify/functions/trello-attachments", { method: "POST", body: JSON.stringify({ action: 'delete', cardId: c.id, idAttachment: att.id }) });
                               }} style={{ background: 'transparent', border: 'none', cursor: 'pointer', color: '#42526e', padding: '4px 8px', borderRadius: '3px', fontWeight: 'bold' }} onMouseEnter={e => e.currentTarget.style.background = '#091e4214'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'}>
                                  
                               </button>
                           </div>
                         </div>
                       ))}
                     </div>
                   )}

                   {/*  2. FILES SECTION */}
                   {cardAttachments.filter(a => a.isUpload !== false).length > 0 && (
                     <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                       <div style={{ fontSize: '14px', fontWeight: 600, color: '#5e6c84', marginBottom: '4px' }}>Files</div>
                       {cardAttachments.filter(a => a.isUpload !== false).map(att => {
                          const ext = att.name ? att.name.split('.').pop().toLowerCase() : 'file';
                          
                          let iconType = 'file';
                          if (['pdf'].includes(ext)) iconType = 'pdf';
                          else if (['doc', 'docx', 'rtf', 'txt'].includes(ext)) iconType = 'doc';
                          else if (['xls', 'xlsx', 'csv'].includes(ext)) iconType = 'xls';
                          else if (['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(ext)) iconType = 'img';

                          return (
                            <div key={att.id} style={{ display: 'flex', gap: '16px', alignItems: 'center', padding: '6px 0', borderBottom: '1px solid #091e420f' }}>
                               
                               {/* Sleek Trello File Thumbnail */}
                               {iconType === 'img' && att.previews?.length > 0 ? (
                                   <div style={{ width: '48px', height: '48px', borderRadius: '6px', border: '1px solid #dfe1e6', display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden', flexShrink: 0, cursor: 'pointer', background: '#091e420a' }} onClick={(e) => { e.stopPropagation(); setTrelloPreview(att); }}>
                                     <img src={att.previews[att.previews.length - 1].url} alt={att.name} style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
                                   </div>
                               ) : (
                                   <div style={{ width: '48px', height: '48px', borderRadius: '6px', border: '1px solid #dfe1e6', background: '#f4f5f7', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0, cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); setTrelloPreview(att); }}>
                                     <svg viewBox="0 0 24 24" width="30" height="30" style={{ overflow: 'visible' }}>
                                       {iconType === 'pdf' && (
                                         <>
                                           <path fill="#E53935" d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6z" />
                                           <path fill="rgba(255,255,255,0.3)" d="M14 2v6h6" />
                                           <text x="11.5" y="16.5" fill="white" fontSize="6.5" fontWeight="bold" textAnchor="middle" fontFamily="sans-serif">PDF</text>
                                           <rect x="7" y="18" width="9" height="1" fill="white" opacity="0.8" />
                                         </>
                                       )}
                                       {iconType === 'xls' && (
                                         <>
                                           <path fill="#0F9D58" d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6z" />
                                           <path fill="rgba(255,255,255,0.3)" d="M14 2v6h6" />
                                           <rect x="7" y="11" width="3.5" height="2" fill="white"/>
                                           <rect x="11.5" y="11" width="4.5" height="2" fill="white"/>
                                           <rect x="7" y="14" width="3.5" height="2" fill="white"/>
                                           <rect x="11.5" y="14" width="4.5" height="2" fill="white"/>
                                           <rect x="7" y="17" width="3.5" height="2" fill="white"/>
                                           <rect x="11.5" y="17" width="4.5" height="2" fill="white"/>
                                         </>
                                       )}
                                       {iconType === 'doc' && (
                                         <>
                                           <path fill="#1A73E8" d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6z" />
                                           <path fill="rgba(255,255,255,0.3)" d="M14 2v6h6" />
                                           <rect x="7" y="11" width="10" height="1.5" fill="white"/>
                                           <rect x="7" y="14" width="10" height="1.5" fill="white"/>
                                           <rect x="7" y="17" width="6" height="1.5" fill="white"/>
                                         </>
                                       )}
                                       {iconType === 'file' && (
                                         <>
                                           <path fill="#5e6c84" d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6z" />
                                           <path fill="rgba(255,255,255,0.3)" d="M14 2v6h6" />
                                           <rect x="7" y="12" width="10" height="1.5" fill="white"/>
                                           <rect x="7" y="16" width="6" height="1.5" fill="white"/>
                                         </>
                                       )}
                                     </svg>
                                   </div>
                               )}
                               
                               {/* Details & Action Buttons */}
                               <div style={{ flex: 1, minWidth: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                  <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', minWidth: 0 }}>
                                     <div style={{ fontWeight: 600, color: '#172b4d', fontSize: '14px', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); setTrelloPreview(att); }} onMouseEnter={e => e.currentTarget.style.textDecoration = 'underline'} onMouseLeave={e => e.currentTarget.style.textDecoration = 'none'}>
                                        {att.name}
                                     </div>
                                     <div style={{ color: '#5e6c84', fontSize: '12px' }}>
                                        Added {timeAgo(att.date)}
                                     </div>
                                  </div>
                                  
                                  <div style={{ display: 'flex', gap: '4px', flexShrink: 0, paddingLeft: '8px' }}>
                                     <button onClick={(e) => { e.stopPropagation(); setTrelloPreview(att); }} style={{ background: 'transparent', border: 'none', cursor: 'pointer', color: '#42526e', padding: '6px', borderRadius: '3px' }} onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'}>
                                       <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg>
                                     </button>
                                     <button onClick={async (e) => {
                                        e.stopPropagation();
                                        if(!window.confirm(`Delete ${att.name}?`)) return;
                                        setCardAttachments(prev => prev.filter(a => a.id !== att.id));
                                        await fetch("/.netlify/functions/trello-attachments", { method: "POST", body: JSON.stringify({ action: 'delete', cardId: c.id, idAttachment: att.id }) });
                                     }} style={{ background: 'transparent', border: 'none', cursor: 'pointer', color: '#42526e', padding: '6px 10px', borderRadius: '3px', fontWeight: 'bold' }} onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'}>
                                        
                                     </button>
                                  </div>
                               </div>
                            </div>
                          );
                       })}
                     </div>
                   )}
                </div>
              </div>
            )}
            {/*  CHECKLISTS RENDERER */}
            {checklists.map(cl => {
              const total = cl.checkItems?.length || 0;
              const checked = cl.checkItems?.filter(i => i.state === 'complete').length || 0;
              const percent = total === 0 ? 0 : Math.round((checked / total) * 100);

              return (
                <div key={cl.id} className="trello-section">
                  <div className="trello-section-icon">
                     <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>
                  </div>
                  <div className="trello-section-header" style={{ justifyContent: 'space-between', alignItems: 'center' }}>
                     <h3 className="trello-h3" style={{ fontSize: '16px', color: '#172b4d' }}>{cl.name}</h3>
                     <button className="t-btn-gray" style={{ padding: '6px 12px', fontSize: '14px' }} onClick={async () => {
                         if(!window.confirm("Delete this checklist?")) return;
                         // Optimistic Update
                         setChecklists(prev => prev.filter(x => x.id !== cl.id));
                         await fetch("/.netlify/functions/trello-checklists", {
                             method: "POST", body: JSON.stringify({ action: 'delete_checklist', checklistId: cl.id })
                         });
                     }}>Delete</button>
                  </div>

                  {/*  PROGRESS BAR */}
                  <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '16px' }}>
                     <span style={{ fontSize: '12px', color: '#5e6c84', width: '32px', textAlign: 'right' }}>{percent}%</span>
                     <div style={{ flex: 1, background: '#091e4214', borderRadius: '4px', height: '8px', overflow: 'hidden' }}>
                        <div style={{ width: `${percent}%`, background: percent === 100 ? '#5aac44' : '#5ba4cf', height: '100%', transition: 'width 0.3s ease, background 0.3s ease' }} />
                     </div>
                  </div>

                  {/*  CHECKLIST ITEMS */}
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', marginBottom: '12px', paddingLeft: '44px' }}>
                     {(cl.checkItems || []).map(item => (
                        <div key={item.id} style={{ display: 'flex', gap: '12px', alignItems: 'flex-start', cursor: 'pointer' }} onClick={async () => {
                            const newState = item.state === 'complete' ? 'incomplete' : 'complete';
                            
                            // Optimistic Toggle Update
                            setChecklists(prev => prev.map(x => x.id === cl.id ? { ...x, checkItems: x.checkItems.map(i => i.id === item.id ? { ...i, state: newState } : i) } : x));
                            
                            await fetch("/.netlify/functions/trello-checklists", {
                                method: "POST", body: JSON.stringify({ action: 'toggle_item', cardId: c.id, idCheckItem: item.id, state: newState })
                            });
                        }}>
                           <input type="checkbox" checked={item.state === 'complete'} readOnly style={{ width: '16px', height: '16px', marginTop: '3px', cursor: 'pointer', accentColor: '#0079bf' }} />
                           <span style={{ flex: 1, fontSize: '14px', color: item.state === 'complete' ? '#5e6c84' : '#172b4d', textDecoration: item.state === 'complete' ? 'line-through' : 'none', transition: 'color 0.2s, text-decoration 0.2s' }}>{item.name}</span>
                        </div>
                     ))}
                  </div>

                  {/*  ADD ITEM INPUT COMPONENT */}
                  <div style={{ paddingLeft: '44px' }}>
                     <ChecklistItemInput onAdd={async (name) => {
                         const tempId = "item-" + Date.now();
                         // Optimistic Add Update
                         setChecklists(prev => prev.map(x => x.id === cl.id ? { ...x, checkItems: [...(x.checkItems||[]), { id: tempId, name, state: 'incomplete' }] } : x));
                         
                         const res = await fetch("/.netlify/functions/trello-checklists", {
                             method: "POST", body: JSON.stringify({ action: 'add_item', checklistId: cl.id, name })
                         });
                         const realItem = await res.json();
                         // Swap temp ID for real Trello ID
                         setChecklists(prev => prev.map(x => x.id === cl.id ? { ...x, checkItems: x.checkItems.map(i => i.id === tempId ? realItem : i) } : x));
                     }} />
                  </div>
                </div>
              );
            })}

          </div>

         {/* RIGHT COLUMN (45%) */}
         <div className="trello-sidebar-col" style={{ flex: "4.5", minWidth: 0 }}>
  <ActivityPane
      cardId={c.id} 
      currentUserAvatarUrl={avatarFor(import.meta.env.VITE_PERSONA || "SIYA") || "https://trello-avatars.s3.amazonaws.com/cee5b736fb38fc4e0555e8491649392c/50.png"} 
      trelloMembers={trelloMembers}
  />
</div>

    </div>

        {/*  HIDDEN TRELLO ATTACHMENT UPLOADER */}
        <input 
          type="file" 
          ref={trelloAttachmentRef} 
          style={{ display: 'none' }} 
          onChange={async (e) => {
             const f = e.target.files?.[0];
             if (!f) return;
             if (f.size > 4.5 * 1024 * 1024) {
               alert("Netlify limit: File must be under 4.5MB.");
               return;
             }
             
             triggerSnackbar(`Uploading ${f.name} to Trello...`);
             
             const reader = new FileReader();
             reader.readAsDataURL(f);
             reader.onload = async () => {
                const base64Data = reader.result.split(",")[1];
                try {
                  const res = await fetch("/.netlify/functions/trello-upload", {
                    method: "POST",
                    body: JSON.stringify({ cardId: c.id, filename: f.name, mimeType: f.type, fileBase64: base64Data })
                  });
                  if (res.ok) {
                     const result = await res.json();
                     triggerSnackbar("Attachment saved to Trello!");
                     //  Push instantly to UI
                     setCardAttachments(prev => [...prev, result.attachment]);
                  } else {
                     triggerSnackbar("Failed to upload attachment");
                  }
                } catch(err) { console.error(err); }
             };
             e.target.value = ""; // Reset input
     }}
    />

        {/*  TRELLO FILE PREVIEW OVERLAY */}
        {trelloPreview && (
          <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0,0,0,0.85)', zIndex: 10000, display: 'flex', flexDirection: 'column' }} onClick={() => setTrelloPreview(null)}>
             
             {/* Top Bar */}
             <div style={{ padding: '16px 24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', color: '#fff' }} onClick={e => e.stopPropagation()}>
                <div style={{ fontSize: '18px', fontWeight: 600 }}>{trelloPreview.name}</div>
                <div style={{ display: 'flex', gap: '24px', alignItems: 'center' }}>
                   <a href={trelloPreview.url} download target="_blank" rel="noopener noreferrer" style={{ color: '#fff', textDecoration: 'none', background: 'rgba(255,255,255,0.2)', padding: '8px 20px', borderRadius: '4px', fontWeight: 500, transition: 'background 0.2s' }} onMouseEnter={e => e.currentTarget.style.background = 'rgba(255,255,255,0.3)'} onMouseLeave={e => e.currentTarget.style.background = 'rgba(255,255,255,0.2)'}>
                     Download
                   </a>
                   <button onClick={() => setTrelloPreview(null)} style={{ background: 'transparent', border: 'none', color: '#fff', fontSize: '32px', cursor: 'pointer', lineHeight: 1, padding: 0 }}></button>
                </div>
             </div>
             
             {/* Preview Area */}
             <div style={{ flex: 1, display: 'flex', justifyContent: 'center', alignItems: 'center', padding: '24px', overflow: 'hidden' }} onClick={e => e.stopPropagation()}>
                {(() => {
                   const ext = trelloPreview.name ? trelloPreview.name.split('.').pop().toLowerCase() : '';
                   const isImg = ['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(ext);
                   const isPdf = ext === 'pdf';
                   const isDocOrXls = ['doc', 'docx', 'xls', 'xlsx', 'csv'].includes(ext);
                   
                   // 1. Image: Use the Trello preview thumbnail if available
                   if (isImg && trelloPreview.previews?.length > 0) {
                       return <img src={trelloPreview.previews[trelloPreview.previews.length - 1].url} alt={trelloPreview.name} style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain', borderRadius: '4px' }} />;
                   }
                   
                   // 2. Build the Proxy URL (Bypasses the forced download)
                   const proxyUrl = `/.netlify/functions/trello-download?url=${encodeURIComponent(trelloPreview.url)}&mimeType=${encodeURIComponent(trelloPreview.mimeType || '')}`;
                   
                   // 3. PDF: Display the proxied file directly inline!
                   if (isPdf) {
                       return <iframe src={proxyUrl} style={{ width: '100%', height: '100%', maxWidth: '1000px', border: 'none', background: '#fff', borderRadius: '8px' }} />;
                   }
                   
                   // 4. DOC/XLS: Hand the public proxy URL to Google Docs Viewer
                   if (isDocOrXls) {
                       const absoluteProxyUrl = `${window.location.origin}${proxyUrl}`;
                       return <iframe src={`https://docs.google.com/gview?url=${encodeURIComponent(absoluteProxyUrl)}&embedded=true`} style={{ width: '100%', height: '100%', maxWidth: '1000px', border: 'none', background: '#fff', borderRadius: '8px' }} />;
                   }
                   
                   return <div style={{ color: '#fff', fontSize: '18px', background: 'rgba(255,255,255,0.1)', padding: '24px', borderRadius: '8px' }}>Preview not available for this file type. Please download to view.</div>;
                })()}
             </div>
         </div>
    )}

   </div>
  );
 }

 //  NEW: CALENDAR VIEW RENDERER with True Month/Grid View
  if (currentView.app === "calendar") {
    const currentMonthName = new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

    //  1. GENERATE THE CALENDAR MATRIX (42 cells / 6 rows to perfectly fit any month)
    const today = new Date();
    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    const startingDayOfWeek = firstDayOfMonth.getDay(); // 0 (Sun) to 6 (Sat)
    const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
    
    const calendarGrid = [];
    
    // A. Padding days from the previous month
    for (let i = 0; i < startingDayOfWeek; i++) {
      calendarGrid.push({ date: new Date(today.getFullYear(), today.getMonth(), 1 - (startingDayOfWeek - i)), isCurrentMonth: false });
    }
    // B. Actual days of the current month
    for (let i = 1; i <= daysInMonth; i++) {
      calendarGrid.push({ date: new Date(today.getFullYear(), today.getMonth(), i), isCurrentMonth: true });
    }
    // C. Padding days for the next month to complete the 42-cell grid
    const remainingDays = 42 - calendarGrid.length; 
    for (let i = 1; i <= remainingDays; i++) {
      calendarGrid.push({ date: new Date(today.getFullYear(), today.getMonth() + 1, i), isCurrentMonth: false });
    }

    // Helper to match events to specific dates
    const isSameDay = (d1, d2) => d1.getDate() === d2.getDate() && d1.getMonth() === d2.getMonth() && d1.getFullYear() === d2.getFullYear();

    return (
      <div style={{ padding: "24px", background: "#fff", height: "100%", overflowY: "auto", display: "flex", flexDirection: "column", borderLeft: "1px solid #e6e6e6", borderRight: "1px solid #e6e6e6" }}>
        
        {/* Header */}
        <div style={{ marginBottom: "24px", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <h2 style={{ margin: 0, fontSize: "22px", color: "#202124", fontWeight: 400, fontFamily: "'Google Sans', Roboto, sans-serif", display: "flex", alignItems: "center", gap: "12px" }}>
            <CalendarIcon />
            {isMonthView ? currentMonthName : "Upcoming Agenda"}
          </h2>
          
          <div style={{ display: 'flex', gap: '16px', alignItems: 'center' }}>
            {/* Toggle Buttons */}
            <div style={{ display: 'flex', gap: '4px', background: '#f1f3f4', borderRadius: '8px', padding: '4px' }}>
              <button 
                onClick={() => setIsMonthView(false)} 
                style={{ padding: '6px 16px', background: !isMonthView ? '#fff' : 'transparent', color: !isMonthView ? '#1a73e8' : '#5f6368', border: 'none', cursor: 'pointer', borderRadius: '4px', fontWeight: 500, fontSize: '13px', display: 'flex', alignItems: 'center', gap: '6px', boxShadow: !isMonthView ? '0 1px 2px rgba(0,0,0,0.1)' : 'none' }}
              >
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
                List
              </button>
              <button 
                onClick={() => setIsMonthView(true)} 
                style={{ padding: '6px 16px', background: isMonthView ? '#fff' : 'transparent', color: isMonthView ? '#1a73e8' : '#5f6368', border: 'none', cursor: 'pointer', borderRadius: '4px', fontWeight: 500, fontSize: '13px', display: 'flex', alignItems: 'center', gap: '6px', boxShadow: isMonthView ? '0 1px 2px rgba(0,0,0,0.1)' : 'none' }}
              >
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                Month
              </button>
            </div>

            <button 
              onClick={() => setCurrentView({ app: "calendar", contact: null })}
              style={{ background: "transparent", border: "none", color: "#1a73e8", cursor: "pointer", fontWeight: 500, fontSize: "14px", display: "flex", alignItems: "center", gap: "6px" }}
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
              Refresh
            </button>
          </div>
        </div>

        {/* Status Indicators */}
        {calendarLoading && <div style={{ color: "#5f6368", padding: "16px 0", fontSize: "14px", textAlign: "center" }}>Loading your schedule...</div>}
        {calendarError && <div style={{ color: "#d93025", padding: "16px 0", fontSize: "14px", textAlign: "center" }}>Error: {calendarError}</div>}

        {/* Event List / Grid */}
        {!calendarLoading && !calendarError && (
          isMonthView ? (
            //  AUTHENTIC GOOGLE CALENDAR GRID VIEW
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', border: '1px solid #dadce0', borderRadius: '8px', overflow: 'hidden', background: '#dadce0', gap: '1px' }}>
              
              {/* Day Headers */}
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', background: '#fff', gap: '1px' }}>
                {['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'].map(day => (
                  <div key={day} style={{ padding: '8px 0', textAlign: 'center', fontSize: '11px', fontWeight: 500, color: '#70757a' }}>{day}</div>
                ))}
              </div>

              {/* Grid Cells */}
              <div style={{ flex: 1, display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gridTemplateRows: 'repeat(6, 1fr)', background: '#dadce0', gap: '1px' }}>
                {calendarGrid.map((dayObj, idx) => {
                  const isToday = isSameDay(dayObj.date, today);
                  const isFirstDayOfMonth = dayObj.date.getDate() === 1;
                  
                  // Extract events for this specific square
                  const dayEvents = calendarEvents.filter(ev => {
                    const start = ev.start.dateTime ? new Date(ev.start.dateTime) : new Date(ev.start.date);
                    return isSameDay(start, dayObj.date);
                  });

                  return (
                    <div key={idx} style={{ background: '#fff', minHeight: '100px', display: 'flex', flexDirection: 'column', padding: '4px' }}>
                      
                      {/* Date Number */}
                      <div style={{ textAlign: 'center', marginBottom: '4px' }}>
                        <span style={{ 
                          display: 'inline-flex', justifyContent: 'center', alignItems: 'center', width: '24px', height: '24px', 
                          borderRadius: '50%', background: isToday ? '#1a73e8' : 'transparent', 
                          color: isToday ? '#fff' : (dayObj.isCurrentMonth ? '#3c4043' : '#70757a'),
                          fontSize: '12px', fontWeight: isToday ? 600 : 400
                        }}>
                          {isFirstDayOfMonth && !isToday ? `${dayObj.date.toLocaleString('en-US', {month: 'short'})} 1` : dayObj.date.getDate()}
                        </span>
                      </div>

                      {/* Events inside the square */}
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', overflowY: 'auto' }}>
                        {dayEvents.map(ev => {
                          const isAllDay = !ev.start.dateTime;
                          const timeStr = isAllDay ? "" : new Date(ev.start.dateTime).toLocaleTimeString("en-US", { hour: 'numeric', minute: '2-digit' }).toLowerCase().replace(' ', '');
                          
                          // Style 1: Solid block for All-Day Events
                          if (isAllDay) {
                            return (
                              <div key={ev.id} title={ev.summary} style={{ background: '#1a73e8', color: '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '11px', fontWeight: 500, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', cursor: 'pointer' }}>
                                {ev.summary}
                              </div>
                            );
                          } 
                          // Style 2: Dot + Time for specific meetings
                          else {
                            return (
                              <div key={ev.id} title={`${timeStr} ${ev.summary}`} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '11px', color: '#3c4043', padding: '2px 4px', borderRadius: '4px', cursor: 'pointer' }} onMouseEnter={e => e.currentTarget.style.background = '#f1f3f4'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'}>
                                <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: '#039be5', flexShrink: 0 }}></div>
                                <span style={{ fontWeight: 500 }}>{timeStr}</span>
                                <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{ev.summary}</span>
                              </div>
                            );
                          }
                        })}
                      </div>

                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            //  ORIGINAL LIST VIEW (Unchanged)
            <div style={{ display: "flex", flexDirection: "column" }}>
              {calendarEvents.length === 0 && !calendarLoading && !calendarError && (
                <div style={{ color: "#5f6368", padding: "32px 0", fontStyle: "italic", textAlign: "center", background: "#ffffff", borderRadius: "8px", border: "1px solid #dadce0" }}>
                  No upcoming events for the next 7 days.
                </div>
              )}
              {calendarEvents.map(ev => {
                const start = ev.start.dateTime ? new Date(ev.start.dateTime) : new Date(ev.start.date);
                const end = ev.end.dateTime ? new Date(ev.end.dateTime) : new Date(ev.end.date);
                const isAllDay = !ev.start.dateTime;

                const dayStr = start.toLocaleDateString("en-GB", { weekday: 'long', month: 'short', day: 'numeric' });
                const timeStr = isAllDay ? "All Day" : `${start.toLocaleTimeString("en-US", { hour: 'numeric', minute: '2-digit' })} - ${end.toLocaleTimeString("en-US", { hour: 'numeric', minute: '2-digit' })}`;

                return (
                  <div 
                    key={ev.id} 
                    style={{ display: "flex", gap: "16px", marginBottom: "12px", padding: "16px", borderRadius: "8px", border: "1px solid #dadce0", background: "#ffffff", transition: "box-shadow 0.2s, border-color 0.2s" }} 
                    onMouseEnter={e => { e.currentTarget.style.boxShadow = "0 1px 3px rgba(60,64,67,0.15)"; e.currentTarget.style.borderColor = "#c2e7ff"; }} 
                    onMouseLeave={e => { e.currentTarget.style.boxShadow = "none"; e.currentTarget.style.borderColor = "#dadce0"; }}
                  >
                    <div style={{ width: "130px", flexShrink: 0 }}>
                      <div style={{ fontWeight: 600, color: "#1a73e8", fontSize: "14px" }}>{dayStr}</div>
                      <div style={{ color: "#5f6368", fontSize: "13px", marginTop: "6px" }}>{timeStr}</div>
                    </div>
                    
                    <div style={{ width: "4px", background: "#4285F4", borderRadius: "4px" }}></div>
                    
                    <div style={{ flex: 1, minWidth: 0 }}>
                      <div style={{ fontWeight: 500, color: "#202124", fontSize: "15px", marginBottom: "6px", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>
                        {ev.summary || "(No title)"}
                      </div>
                      
                      {ev.location && (
                        <div style={{ fontSize: "13px", color: "#5f6368", display: "flex", alignItems: "center", gap: "6px", marginBottom: "8px" }}>
                          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                          {ev.location}
                        </div>
                      )}
                      
                      {ev.hangoutLink && (
                        <a href={ev.hangoutLink} target="_blank" rel="noreferrer" style={{ display: "inline-flex", alignItems: "center", gap: "6px", marginTop: "4px", padding: "6px 16px", background: "#1a73e8", color: "#fff", textDecoration: "none", borderRadius: "100px", fontSize: "13px", fontWeight: 500, transition: "background 0.2s" }} onMouseEnter={e => e.currentTarget.style.background = "#1557b0"} onMouseLeave={e => e.currentTarget.style.background = "#1a73e8"}>
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4zM14 13h-3v3H9v-3H6v-2h3V8h2v3h3v2z"/></svg>
                          Join Meet
                        </a>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          )
        )}
      </div>
    );
  }

  return <div className="chat-output" />;
}, [
  currentView,
  //  NEW: Calendar state dependencies
  calendarEvents,
  calendarLoading,
  calendarError,
  isMonthView,

       // Email
       email,
       emailPreview,
        showDraftPicker,
        selectedDraftTemplate,
        draftTo,
        isDraftEnlarged,
        draftPos,
        draftAttachments,

       // Gmail Inbox
       gmailEmails,
       gmailLoading,
       gmailError,
       gmailFolder, 
       gmailPage,
       gmailTotal,
       email,
       gmailRefreshTrigger, 
       otherContacts,
       historyContacts, //  ADD THIS so suggestions update, but REMOVE the duplicate gmailEmails

       // Trello
        trelloCard,
        trelloMenuOpen,
        trelloPreview,
        descEditing,
        descDraft,
        checklists,
        cardAttachments, 
        newChecklistTitle,
        copyFromChecklist,
        showLabelPicker, 
        showMemberShortcut, 
        showAddMenu,        //  UNFREEZES THE ADD BUTTON
        addMenuStep,        //  UNFREEZES THE MENU NAVIGATION
        attachLink,         //  UNFREEZES TYPING THE URL
        attachName,         //  UNFREEZES TYPING THE LINK NAME
        showMoveSubmenu,
        moveTab,
        moveTargetList,
        moveTargetPos,
        trelloBuckets,
        selectedEmailIds,
        searchQuery,
        allTrelloLists, 
        moveListSearch, 
        showNewChatModal,
        newChatTarget,
      ]);

  return (
  <PasswordGate>
    <div className="app">
      {/* LEFT */}
      <div className="left-panel">
        <div className="panel-title">Notifications</div>
       <div className="notifications">
          {notifications.map((n) => (
            <div
              className={`notification ${n.alt.toLowerCase().replace(/\s/g, '-')}`}
              key={n.id}
              onClick={() => onNotificationClick(n)}
              style={{ position: "relative" }}
            >
              <img src={n.icon} alt={n.alt} className="icon" />
              <span style={{ flex: 1, paddingRight: "8px", lineHeight: "1.4" }}>
                [{n.time}] {n.text}
              </span>
              {/* FIX: Removed the redundant app name chips from the right side */}
              <button
                className="notif-close"
                title="Dismiss"
                onClick={(e) => {
                  e.stopPropagation();
                  dismissNotification(n);
                }}
              >
                
              </button>
            </div>
          ))}
        </div> 
      </div>

     {/* MIDDLE */}
   <div
    className={`middle-panel ${
     currentView.app === "email" && emailPreview ? "has-email-preview" : ""
    }`}
   >
<div className="panel-title" style={{ display: "flex", alignItems: "center", justifyContent: "space-between", paddingRight: "24px", paddingLeft: "12px" }}>
    
     {/* LEFT SIDE: Google Chat, Gmail & Calendar Buttons */}
          <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
            <button
              className="connect-google-btn"
              onClick={() => {
                setGchatSelectedSpace(null); 
                setInputValue("");            
                setCurrentView({ app: "gchat", contact: null });
              }}
              type="button"
            >
              <img src={gchatIcon} alt="GChat" />
              Google Chat
            </button>

            <button
              className="connect-google-btn"
              onClick={() => {
                setInputValue("");
                setCurrentView({ app: "gmail", contact: null });
              }}
              type="button"
            >
              <img src={gmailIcon} alt="Gmail" />
              Gmail
            </button>

            {/*  NEW: Calendar Button */}
            <button
              className="connect-google-btn"
              onClick={() => {
                setInputValue("");
                setCurrentView({ app: "calendar", contact: null }); // Prepares the state for our next step
              }}
              type="button"
            >
              <CalendarIcon />
              Calendar
            </button>
          </div>

     {/* RIGHT SIDE: Connect + Close App Button */}
     <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
      <a
       href="/.netlify/functions/google-auth-start"
       className="connect-google-btn"
      >
       Connect / Reconnect Google
      </a>

   {/*  NEW: Close App Button (Only shows when in an app) */}
            {currentView.app !== "none" && (
              <button
                onClick={() => setCurrentView({ app: "none", contact: null })}
                style={{
                  width: "32px", height: "32px", borderRadius: "50%",
                  border: "1px solid #dadce0", background: "white",
                  display: "grid", placeItems: "center", cursor: "pointer",
                  color: "#5f6368", fontSize: "18px", fontWeight: "300"
                }}
                title="Close App"
              >
                
              </button>
            )}
          </div>
        </div>

        {/*  Removes the left gap specifically when GChat is open */}
        <div className="middle-content" style={{ paddingLeft: currentView.app === "gchat" ? "0" : undefined }}>
          {middleContent}
        </div>

        <input
          ref={fileInputRef}
     type="file"
     /*  1. Allow Images, PDF, Excel, Word, AUDIO, VIDEO */
     accept="application/pdf, image/png, image/jpeg, .xlsx, .xls, .docx, .doc, audio/*, video/*"
     style={{ display: "none" }}
     onChange={(e) => {
      const f = e.target.files?.[0];
      if (!f) return;

      //  2. Strict Netlify Limit (4.5MB safe limit for Base64 encoding)
      if (f.size > 4.5 * 1024 * 1024) {
       alert("Netlify Limit: File must be under 4.5MB.");
       return;
      }

      setPendingUpload({ file: f, kind: "file" });
      setShowPlusMenu(false);
      e.target.value = "";
     }}
    />

        {/*  CONDITIONALLY RENDER AND ALIGN CHAT BAR */}
        {((currentView.app === "gchat" && gchatSelectedSpace) || (currentView.app === "whatsapp" && currentView.contact)) && (
          <div style={{ display: "flex", width: "100%", background: "#fff", flexShrink: 0, borderTop: "1px solid #ddd" }}>
            
            {currentView.app === "gchat" && (
              <div style={{ width: "25%", borderRight: "1px solid #ddd", flexShrink: 0 }}></div>
            )}

            <div 
              className={`chat-bar ${pendingUpload ? "has-file" : ""}`}
              style={{ flex: 1, width: currentView.app === "gchat" ? "75%" : "100%", borderTop: "none" }}
            >
         {pendingUpload && (
          <div className="chat-upload-preview">
           <div className="chat-upload-card" title={pendingUpload.file.name}>
            <div className="chat-upload-icon">PDF</div>
            <div className="chat-upload-meta">
             <div className="chat-upload-name">{pendingUpload.file.name}</div>
             <div className="chat-upload-size">
              {(pendingUpload.file.size / 1024 / 1024).toFixed(2)} MB
             </div>
            </div>
            <button
             className="chat-upload-remove"
             type="button"
             onClick={() => setPendingUpload(null)}
             aria-label="Remove upload"
            >
             
            </button>
           </div>
          </div>
         )}

         <div className="chat-input-row" style={{ alignItems: "flex-end" }}>
       
          {/* 1. TEXT AREA */}
          <textarea
           ref={chatTextareaRef}
           className="chat-textarea"
           placeholder={
            isRecording
             ? "Recording audio..."
             : currentView.app === "whatsapp" && currentView.contact
             ? `Message ${currentView.contact}`
             : "Message..."
           }
           rows={1}
           value={inputValue}
           disabled={isRecording}
           onChange={(e) => setInputValue(e.target.value)}
           onInput={(e) => handleAutoGrow(e.currentTarget)}
           onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
             e.preventDefault();
             handleSend();
            }
           }}
           style={{
            flex: 1,
            minHeight: "40px",
            paddingTop: "10px",
            marginBottom: "2px"
           }}
          />

          {/* 2. RIGHT ACTIONS CONTAINER */}
          <div style={{ display: "flex", gap: "8px", marginBottom: "4px", paddingLeft: "4px" }}>
        
           {/* A) MIC or SEND BUTTON */}
           {inputValue.trim() || pendingUpload ? (
            <button
             className="send-btn"
             onClick={handleSend}
             aria-label="Send"
             style={{
              width:"28px", height:"28px", borderRadius:"50%",
              display:"grid", placeItems:"center",
              border:"none", background:"#000",
              cursor:"pointer", color: "white"
             }}
            >
             <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="14" height="14"
              fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"
             >
              <line x1="12" y1="19" x2="12" y2="5" />
              <polyline points="5 12 12 5 19 12" />
             </svg>
            </button>
           ) : (
            ((currentView.app === "gchat" && gchatSelectedSpace) || (currentView.app === "whatsapp" && currentView.contact)) && (
             <button
              className={`mic-btn ${isRecording ? "recording" : ""}`}
              onClick={isRecording ? stopRecording : startRecording}
              title={isRecording ? "Stop Recording" : "Record Voice Note"}
              style={{
               border: "none",
               background: isRecording ? "#fce8e6" : "transparent",
               color: isRecording ? "#ea4335" : "#5f6368",
               borderRadius: "50%",
               width: "34px",
               height: "34px",
               cursor: "pointer",
               display: "grid",
               placeItems: "center",
               transition: "all 0.2s ease"
              }}
           >
             {isRecording ? (
              <div style={{width:"12px", height:"12px", background:"#ea4335", borderRadius:"2px"}} />
             ) : (
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.8">
               <path d="M12 6a2 2 0 0 0-2 2v5a2 2 0 0 0 4 0V8a2 2 0 0 0-2-2Z" />
               <path d="M18 13v-2a6 6 0 0 1-12 0v2" strokeOpacity="0.8" />
               <line x1="12" y1="19" x2="12" y2="21" />
               <circle cx="12" cy="12" r="9" strokeOpacity="0.3" />
              </svg>
             )}
           </button>
          )
         )}

         {/* B) PLUS BUTTON */}
         {currentView.app === "gchat" && gchatSelectedSpace && (
          <div className="chat-plus-wrap" style={{ position: "relative" }}>
           <button
            type="button"
            className="chat-plus-btn"
            onClick={(e) => {
             e.stopPropagation();
             setShowPlusMenu((v) => !v);
            }}
            aria-label="More"
            style={{
             width:"34px", height:"34px", borderRadius:"50%",
             border:"1px solid #ddd", background:"transparent",
             fontSize:"22px", color:"#5f6368", fontWeight: "300",
             display:"grid", placeItems:"center", cursor:"pointer"
            }}
           >
            +
           </button>

           {showPlusMenu && (
            <div className="chat-plus-menu" style={{ right: 0, left: "auto", bottom: "45px" }}>
             <button
              type="button"
              className="chat-plus-item"
              onClick={(e) => {
               e.stopPropagation();
               setShowPlusMenu(false);
               fileInputRef.current?.click();
              }}
             >
              Upload file
             </button>
            </div>
           )}
          </div>
         )}
        </div>
       </div>
      </div>
        </div>
      )}
   </div>
   {/* RIGHT */}
   <RightPanel />
    </div>

    {/*  GMAIL STYLE SNACKBAR POP-UP */}
    {snackbar.show && (
      <div style={{
        position: "fixed", 
        bottom: "24px", 
        left: "24px", 
        background: "#202124", 
        color: "#fff", 
        padding: "12px 24px",
        borderRadius: "4px", 
        display: "flex", 
        alignItems: "center", 
        gap: "24px",
        boxShadow: "0 3px 5px -1px rgba(0,0,0,.2), 0 6px 10px 0 rgba(0,0,0,.14), 0 1px 18px 0 rgba(0,0,0,.12)",
        zIndex: 10000, 
        fontSize: "14px", 
        minWidth: "288px"
      }}>
        <span style={{ flex: 1 }}>{snackbar.text}</span>
        <div style={{ display: "flex", gap: "16px", alignItems: "center" }}>
          {/*  Conditionally show Undo if lastAction exists */}
          {lastAction && (
            <button 
              onClick={handleUndo}
              style={{ background: "transparent", border: "none", color: "#8ab4f8", fontWeight: 500, cursor: "pointer", fontSize: "14px" }}
            >
              Undo
            </button>
          )}
          <button onClick={() => { setSnackbar({ show: false, text: "" }); setLastAction(null); }} style={{ background: "transparent", border: "none", color: "#fff", fontSize: "18px", cursor: "pointer", padding: "0 4px" }}></button>
        </div>
      </div>
  )}

 </PasswordGate>
  );
}

// --- Place this at the bottom of App.jsx ---
function LiveTimer({ startTime, duration }) {
  const [now, setNow] = useState(Date.now());

  useEffect(() => {
    const interval = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(interval);
  }, []);

  let baseMinutes = parseFloat(duration || "0");
  if (baseMinutes > 1000000) baseMinutes = 0;
  let currentSessionMinutes = 0;

  if (startTime) {
    const start = parseFloat(startTime);
    if (start > 1000000000000) {
      const diff = Math.max(0, now - start);
      currentSessionMinutes = diff / 1000 / 60;
    }
  }

  const totalMins = Math.floor(baseMinutes + currentSessionMinutes);
  let displayTime = `${totalMins}m`;
  if (totalMins >= 60) {
    const h = Math.floor(totalMins / 60);
    const m = totalMins % 60;
    displayTime = m > 0 ? `${h}h ${m}m` : `${h}h`;
  }

  return <span> {displayTime}</span>;
}

// Helper to turn raw Trello action data into human readable text
const formatTrelloAction = (action) => {
  const actor = action.memberCreator?.fullName || "Someone";
  const data = action.data;
  const type = action.type;

  switch (type) {
    case "commentCard":
      return { text: `${actor} commented`, comment: data.text, type: "comment" };
    case "updateCard":
      if (data.listBefore && data.listAfter) {
        return { text: `${actor} moved this card from ${data.listBefore.name} to ${data.listAfter.name}`, type: "system" };
      }
      if (data.old && data.old.closed === false && data.card?.closed === true) {
        return { text: `${actor} archived this card`, type: "system" };
      }
      if (data.old && data.old.closed === true && data.card?.closed === false) {
        return { text: `${actor} sent this card to the board`, type: "system" };
      }
      return null; 
    case "createCard":
    case "copyCard":
       if(data.list) {
          return { text: `${actor} added this card to ${data.list.name}`, type: "creation" };
       }
       return { text: `${actor} created this card`, type: "creation" };
    default:
      return null;
  }
};

// Helper for relative time (e.g., "17 minutes ago")
const timeAgo = (dateParam) => {
  if (!dateParam) return null;
  const date = typeof dateParam === 'object' ? dateParam : new Date(dateParam);
  const today = new Date();
  const seconds = Math.round((today - date) / 1000);
  const minutes = Math.round(seconds / 60);
  const hours = Math.round(minutes / 60);
  const days = Math.round(hours / 24);

  if (seconds < 60) return 'just now';
  if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
  if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  return `${days} day${days > 1 ? 's' : ''} ago`;
};

//  UPGRADED: Parses Links [Text](url), @mentions, and newlines
function formatTrelloComment(text) {
  if (!text) return "";
  
  const regex = /(\[[^\]]+\]\(https?:\/\/[^)]+\)|@[\w.-]+)/g;
  const parts = text.split(regex);

  return parts.map((part, index) => {
    if (!part) return null;

    if (part.startsWith('[') && part.includes('](')) {
      const linkMatch = part.match(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/);
      if (linkMatch) {
        return (
          <a 
            key={`link-${index}`} 
            href={linkMatch[2]} 
            target="_blank" 
            rel="noopener noreferrer" 
            style={{ color: '#0052cc', textDecoration: 'underline', wordBreak: 'break-word', fontWeight: 500 }}
            onClick={(e) => e.stopPropagation()}
          >
            {linkMatch[1]}
          </a>
        );
      }
    }

    // 2.  Render @Mentions (The Trello Pill Effect)
    if (part.startsWith('@')) {
      return (
        <span 
          key={`mention-${index}`} 
          style={{
            //  COLOR MATCH: Trello's native grey pill style
            backgroundColor: '#091e420f', // Light grey background
            color: '#172b4d',           // Dark grey text
            padding: '2px 6px',
            borderRadius: '4px',
            fontWeight: 600,
            fontSize: '13px',
            display: 'inline-block',
            margin: '0 2px'
          }}
        >
          {part}
        </span>
      );
    }

    return part.split('\n').map((line, i, arr) => (
      <React.Fragment key={`text-${index}-${i}`}>
        {line}
        {i < arr.length - 1 && <br />}
      </React.Fragment>
    ));
  });
}

// ---------------- NEW ACTIVITY COMPONENT ----------------
const ActivityPane = React.memo(function ActivityPane({ cardId, currentUserAvatarUrl, trelloMembers }) {
  const [actions, setActions] = useState([]);
  const [loading, setLoading] = useState(true);
  
  // Main comment input states
  const [commentInput, setCommentInput] = useState("");
  const [isFocused, setIsFocused] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [showDetails, setShowDetails] = useState(true);
  const [mentionQuery, setMentionQuery] = useState(null);

  //  NEW: States for managing inline editing
  // Which comment ID is currently being edited? (null if none)
  const [editingActionId, setEditingActionId] = useState(null); 
  // The temporary text in the edit textarea
  const [editText, setEditText] = useState(""); 
  const [isSavingEdit, setIsSavingEdit] = useState(false);
  
  //  NEW: State to control how many activities are shown (starts at 20)
  const [visibleCount, setVisibleCount] = useState(20);

  // Define the current user name to identify "my comments"
  const CURRENT_USER_NAME = "Siyabonga Nono";

  useEffect(() => {
    if (!cardId) return;
    setLoading(true);
    setVisibleCount(20); //  NEW: Reset to 20 whenever a new card is opened
    
    fetch(`/.netlify/functions/trello-actions?cardId=${cardId}`)
      .then(res => res.json())
      .then(data => {
        if (Array.isArray(data)) {
           //  FIX: Removed .slice(0, 20) so the app keeps all history in memory
           const formatted = data.map(a => ({ ...a, formatted: formatTrelloAction(a) })).filter(a => a.formatted);
           setActions(formatted);
        }
      })
      .catch(err => console.error("Failed to load activity", err))
      .finally(() => setLoading(false));
  }, [cardId]);

  const handleCommentChange = (e) => {
    const val = e.target.value;
    setCommentInput(val);
    
    const cursorStart = e.target.selectionStart;
    const textBeforeCursor = val.slice(0, cursorStart);
    const words = textBeforeCursor.split(/\s+/);
    const lastWord = words[words.length - 1];

    if (lastWord.startsWith('@')) {
      setMentionQuery(lastWord.slice(1).toLowerCase());
    } else {
      setMentionQuery(null);
    }
  };

  const insertMention = (fullName) => {
    const ta = document.getElementById("trello-comment-textarea");
    if (!ta) return;
    
    const cursorStart = ta.selectionStart;
    const textBeforeCursor = commentInput.slice(0, cursorStart);
    const textAfterCursor = commentInput.slice(cursorStart);
    
    const lastAtSymbolIndex = textBeforeCursor.lastIndexOf('@');
    
    if (lastAtSymbolIndex !== -1) {
        const newTextBefore = commentInput.slice(0, lastAtSymbolIndex);
        const mentionText = `@${fullName.replace(/\s+/g, '')} `; 
        setCommentInput(newTextBefore + mentionText + textAfterCursor);
        setMentionQuery(null);
        
        setTimeout(() => {
            ta.focus();
            const newPos = newTextBefore.length + mentionText.length;
            ta.setSelectionRange(newPos, newPos);
        }, 0);
    }
  };

  const handleSaveComment = async () => {
    if (!commentInput.trim() || isSaving) return;
    setIsSaving(true);
    const textToSave = commentInput.trim();

    const optimisticAction = {
      id: "opt-" + Date.now(),
      date: new Date().toISOString(),
      // Uses the predefined constant name
      memberCreator: { fullName: CURRENT_USER_NAME, avatarHash: null }, 
      formatted: { text: `${CURRENT_USER_NAME} commented`, comment: textToSave, type: "comment" }
    };
    setActions(prev => [optimisticAction, ...prev]);
    
    setCommentInput("");
    setIsFocused(false);

    try {
      const res = await fetch("/.netlify/functions/trello-add-comment", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ cardId, text: textToSave })
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Failed to save comment");
       // Optionally replace optimistic item with real one here if needed, 
       // but Trello API response varies slightly. For now, rely on refresh.
    } catch(err) {
      console.error("Comment save error:", err);
      alert("Failed to save comment to Trello.");
      setActions(prev => prev.filter(a => a.id !== optimisticAction.id));
      setCommentInput(textToSave);
      setIsFocused(true);
    } finally {
      setIsSaving(false);
    }
  };

  //  NEW: Handle saving an edited comment
  const handleSaveEdit = async (actionId) => {
      if(!editText.trim() || isSavingEdit) return;
      setIsSavingEdit(true);

      // 1. Optimistic Update
      setActions(prevActions => 
        prevActions.map(act => 
            act.id === actionId 
            ? { 
                ...act, 
                //  FIX: Inject dateLastEdited so the "(edited)" badge appears instantly
                data: { ...(act.data || {}), dateLastEdited: new Date().toISOString() },
                formatted: { ...act.formatted, comment: editText.trim() } 
              }
            : act
        )
      );
      setEditingActionId(null); // Exit edit mode immediately against optimistic state

      try {
          // 2. API Call
          const res = await fetch("/.netlify/functions/trello-edit-comment", {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ actionId, text: editText.trim() })
          });
          if(!res.ok) throw new Error("Failed to edit comment");
      } catch(err) {
          console.error(err);
          alert("Failed to edit comment on Trello. Reverting.");
          // Revert needed here in a real app, for prototype we rely on refresh
      } finally {
          setIsSavingEdit(false);
      }
  };

  const styles = {
    container: { marginTop: '0px', color: '#172b4d' },
    header: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' },
    headerTitle: { fontSize: '16px', fontWeight: '600', display: 'flex', alignItems: 'center', gap: '8px' },
    hideBtn: { background: '#091e420f', border: 'none', padding: '6px 12px', borderRadius: '3px', fontWeight: '500', cursor: 'pointer', color: '#172b4d' },
    commentSection: { display: 'flex', gap: '12px', marginBottom: '24px' },
    avatar: { width: '32px', height: '32px', borderRadius: '50%', backgroundColor: '#dfe1e6', backgroundSize: 'cover', flexShrink: 0 },
    inputWrapper: { flexGrow: 1 },
    commentInput: { 
        width: '100%', borderRadius: '3px', border: isFocused ? '2px solid #0079bf' : '1px solid #dfe1e6', 
        padding: '8px 12px', fontSize: '14px', transition: 'all 0.2s', outline: 'none', minHeight: isFocused ? '80px' : 'auto', resize: 'none',
        boxShadow: isFocused ? '0 0 0 2px #ffffff, 0 0 0 4px #0079bf' : 'none', fontFamily: "inherit",
        backgroundColor: '#ffffff'
    },
    controls: { marginTop: '8px', display: 'flex', gap: '8px' },
    saveBtn: { background: '#0079bf', color: 'white', border: 'none', padding: '6px 12px', borderRadius: '3px', fontWeight: '500', cursor: 'pointer' },
    discardBtn: { background: 'transparent', color: '#42526e', border: 'none', padding: '6px 12px', borderRadius: '3px', fontWeight: '500', cursor: 'pointer' },
    activityList: { display: 'flex', flexDirection: 'column', gap: '16px' },
    actItem: { display: 'flex', gap: '12px', fontSize: '14px' },
    actContent: { display: 'flex', flexDirection: 'column', flex: 1 },
    actText: { fontWeight: '400', color: '#172b4d' },
    actMeta: { fontSize: '12px', color: '#5e6c84', marginTop: '2px' },
    commentBubble: { background: 'white', padding: '8px 12px', borderRadius: '3px', border: '1px solid #dfe1e6', marginTop: '6px', boxShadow: '0 1px 1px #091e4240', color: '#172b4d', width: 'fit-content', maxWidth: '100%' },
    actionLinks: { display: 'flex', gap: '12px', fontSize: '12px', color: '#5e6c84', marginTop: '4px', marginLeft: '4px' },
    link: { cursor: 'pointer', textDecoration: 'none' }
  };

  const getAvatar = (hash) => hash ? `https://trello-avatars.s3.amazonaws.com/${hash}/50.png` : null;

  const filteredActions = actions.filter(act => {
    if (showDetails) return true;
    return act.formatted.type === "comment" || act.formatted.type === "creation";
  });

  //  NEW: Slice the array based on the visibleCount limit and check if there are more
  const displayedActions = filteredActions.slice(0, visibleCount);
  const hasMore = filteredActions.length > visibleCount;

  const filteredMembers = trelloMembers ? trelloMembers.filter(m => 
    m.fullName.toLowerCase().includes(mentionQuery || '') || 
    (m.username && m.username.toLowerCase().includes(mentionQuery || ''))
  ) : [];

  return (
    <div style={styles.container}>
      {/* --- Header --- */}
      <div style={styles.header}>
        <div style={styles.headerTitle}>
           <svg width="24" height="24" viewBox="0 0 24 24" fill="#42526e"><path d="M19 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3ZM11 17H7V15H11V17ZM17 13H7V11H17V13ZM17 9H7V7H17V9Z"></path></svg>
           Comments and activity
        </div>
        <button 
           style={styles.hideBtn} 
           onClick={() => setShowDetails(!showDetails)}
           onMouseEnter={e => e.currentTarget.style.background = '#091e4214'}
           onMouseLeave={e => e.currentTarget.style.background = '#091e420f'}
        >
           {showDetails ? "Hide details" : "Show details"}
        </button>
      </div>

      {/* --- Main Comment Input Box --- */}
      <div style={styles.commentSection}>
        <div style={{...styles.avatar, backgroundImage: `url(${currentUserAvatarUrl})`}}></div>
        <div style={styles.inputWrapper}>
             <div style={{ position: 'relative' }}>
                 <textarea 
                    id="trello-comment-textarea"
                    style={{...styles.commentInput, minHeight: isFocused ? '80px' : '40px'}}
                    placeholder="Write a comment..."
                    value={commentInput}
                    onChange={handleCommentChange}
                    onFocus={() => setIsFocused(true)}
                 />
                 {/* @Mention Dropdown */}
                 {mentionQuery !== null && filteredMembers.length > 0 && (
                     <div style={{ position: 'absolute', bottom: '100%', left: 0, background: '#fff', border: '1px solid #dfe1e6', borderRadius: '3px', boxShadow: '0 8px 16px -4px rgba(9,30,66,0.25)', width: '250px', maxHeight: '200px', overflowY: 'auto', zIndex: 1000, marginBottom: '4px' }}>
                         {filteredMembers.map(m => (
                             <div key={m.id} style={{ padding: '8px 12px', cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '8px', color: '#172b4d', fontSize: '13px' }} onMouseEnter={e => e.currentTarget.style.background = '#091e420f'} onMouseLeave={e => e.currentTarget.style.background = 'transparent'} onClick={() => insertMention(m.fullName)}>
                                 {m.avatarUrl ? <img src={m.avatarUrl.endsWith('.png') ? m.avatarUrl : m.avatarUrl + '/50.png'} alt="" style={{width: 24, height: 24, borderRadius: '50%'}} /> : <div style={{width: 24, height: 24, borderRadius: '50%', background: '#dfe1e6', display: 'grid', placeItems: 'center', fontWeight: 600}}>{m.fullName[0]}</div>}
                                 <span style={{ fontWeight: 500 }}>{m.fullName}</span>
                             </div>
                         ))}
                     </div>
                 )}
             </div>
             {isFocused && (
                <div style={styles.controls}>
                    <button style={{...styles.saveBtn, opacity: (!commentInput.trim() || isSaving) ? 0.5 : 1}} disabled={!commentInput.trim() || isSaving} onClick={handleSaveComment}>
                        {isSaving ? "Saving..." : "Save"}
                    </button>
                    <button style={styles.discardBtn} onClick={() => { setIsFocused(false); setCommentInput(""); setMentionQuery(null); }}>Discard</button>
                </div>
             )}
        </div>
      </div>

      {/* --- Activity List --- */}
      <div style={styles.activityList}>
        {loading && <div style={{color: '#5e6c84', fontStyle: 'italic'}}>Loading activity...</div>}
        {/*  FIX: Use the sliced 'displayedActions' array */}
        {!loading && displayedActions.map(act => {
          // Resolve Actor Name
          let rawName = act.memberCreator?.fullName || "Someone";
          if (rawName === "Jonathan") rawName = "Jonathan Espanol";
          else if (trelloMembers && trelloMembers.length > 0) {
              const matched = trelloMembers.find(m => m.id === act.memberCreator?.id);
              if (matched) rawName = matched.fullName;
          }
          const actorName = rawName;

          //  NEW: Check if this comment belongs to the current user (Siyabonga Nono)
          // We check the name, or if it's a temporary "optimistic" comment we just created.
          const isMyComment = actorName === CURRENT_USER_NAME || act.id.startsWith("opt-");
          
          //  NEW: Check if this specific comment is currently being edited
          const isEditingThis = editingActionId === act.id;

          const actionText = act.formatted.text.startsWith(act.memberCreator?.fullName) ? act.formatted.text.slice((act.memberCreator?.fullName).length) : ` ${act.formatted.text}`;
          const resolvedAvatar = avatarFor(actorName) || getAvatar(act.memberCreator?.avatarHash);

          return (
            <div key={act.id} style={styles.actItem}>
              <div style={{ ...styles.avatar, backgroundImage: resolvedAvatar ? `url(${resolvedAvatar})` : 'none', display: 'grid', placeItems: 'center', color: '#172b4d', fontWeight: 600, fontSize: '14px' }}>
                  {!resolvedAvatar && actorName.charAt(0).toUpperCase()}
              </div>
              <div style={styles.actContent}>
                 <div style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '6px', marginBottom: '2px' }}>
                    <span style={{ fontWeight: 600, color: '#172b4d', fontSize: '14px' }}>
                      {actorName}
                    </span>
                    
                    {/*  NEW: Hide the "commented" text, but keep action text for moves/creation */}
                    {act.formatted.type !== "comment" && (
                      <span style={{ color: '#172b4d', fontSize: '14px' }}>
                        {actionText}
                      </span>
                    )}

                    {/*  NEW: Time is moved next to the name. Blue/underlined for comments to match Trello */}
                    <span style={{ 
                        fontSize: '12px', 
                        color: act.formatted.type === 'comment' ? '#0052cc' : '#5e6c84', 
                        textDecoration: act.formatted.type === 'comment' ? 'underline' : 'none' 
                    }}>
                      {timeAgo(act.date)}
                    </span>

                    {/*  NEW: Display (edited) if a dateLastEdited flag exists */}
                    {act.formatted.type === "comment" && (act.data?.dateLastEdited || act.dateLastEdited) && (
                      <span style={{ fontSize: '12px', color: '#5e6c84' }}>
                        (edited)
                      </span>
                    )}
                 </div>
                 
                 {/*  NEW: Conditional Rendering: Show Edit Textarea OR Comment Bubble */}
                 {act.formatted.comment && (
                     <div style={{ display: 'flex', flexDirection: 'column' }}>
                         
                         {isEditingThis ? (
                             /* --- EDIT MODE --- */
                             <div style={{ marginTop: '6px' }}>
                                 <textarea 
                                     autoFocus
                                     style={{...styles.commentInput, minHeight: '80px', boxShadow: '0 0 0 2px #ffffff, 0 0 0 2px #0079bf'}}
                                     value={editText}
                                     onChange={(e) => setEditText(e.target.value)}
                                 />
                                 <div style={styles.controls}>
                                     <button 
                                        style={{...styles.saveBtn, opacity: isSavingEdit ? 0.5 : 1}} 
                                        disabled={isSavingEdit}
                                        onClick={() => handleSaveEdit(act.id)}
                                     >
                                        {isSavingEdit ? "Saving..." : "Save"}
                                     </button>
                                     <button 
                                        style={styles.discardBtn} 
                                        disabled={isSavingEdit}
                                        onClick={() => { setEditingActionId(null); setEditText(""); }}
                                     >
                                        Cancel
                                     </button>
                                 </div>
                             </div>
                         ) : (
                             /* --- NORMAL VIEW MODE --- */
                             <>
                                 <div style={styles.commentBubble}>
                                    {formatTrelloComment(act.formatted.comment)}
                                 </div>
                                 
                                 {/* Action Links (Reply, Edit, Delete) */}
                                 <div style={styles.actionLinks}>
                                     <span style={styles.link} onMouseEnter={e => e.currentTarget.style.textDecoration = 'underline'} onMouseLeave={e => e.currentTarget.style.textDecoration = 'none'} onClick={() => {
                                            const mention = `@${actorName.replace(/\s+/g, '')} `;
                                            setCommentInput(prev => prev ? `${prev} ${mention}` : mention);
                                            setIsFocused(true);
                                            setTimeout(() => { const ta = document.getElementById("trello-comment-textarea"); if (ta) ta.focus(); }, 0);
                                        }}>Reply</span>
                                     
                                     {/*  NEW: Only show Edit/Delete if it's MY comment */}
                                     {isMyComment && (
                                        <>
                                             <span style={styles.link} onMouseEnter={e => e.currentTarget.style.textDecoration = 'underline'} onMouseLeave={e => e.currentTarget.style.textDecoration = 'none'} onClick={() => {
                                                // Start Editing mode
                                                setEditingActionId(act.id);
                                                setEditText(act.formatted.comment);
                                             }}>Edit</span>
                                             
                                             <span style={styles.link} onMouseEnter={e => e.currentTarget.style.textDecoration = 'underline'} onMouseLeave={e => e.currentTarget.style.textDecoration = 'none'} onClick={async () => {
                                                 if(!window.confirm("Delete this comment?")) return;
                                                 setActions(prev => prev.filter(a => a.id !== act.id));
                                                 try { await fetch("/.netlify/functions/trello-delete-comment", { method: "POST", body: JSON.stringify({ actionId: act.id }) }); } catch(err) { console.error("Delete failed", err); }
                                             }}>Delete</span>
                                        </>
                                     )}
                                 </div>
                             </>
                         )}
                     </div>
                 )}
              </div>
            </div>
          );
        })}
        
        {/*  NEW: "View more activity" button */}
        {!loading && hasMore && (
           <button 
             onClick={() => setVisibleCount(prev => prev + 20)}
             style={{
                background: 'transparent', 
                border: 'none', 
                color: '#5e6c84', 
                fontWeight: 500, 
                cursor: 'pointer', 
                padding: '8px 12px', 
                textDecoration: 'underline', 
                alignSelf: 'flex-start',
                marginTop: '8px'
             }}
             onMouseEnter={e => e.currentTarget.style.color = '#172b4d'}
             onMouseLeave={e => e.currentTarget.style.color = '#5e6c84'}
           >
             View more activity...
           </button>
        )}
        
      </div>
    </div>
  );
});

// ---------------- NEW CHECKLIST ITEM COMPONENT ----------------
const ChecklistItemInput = React.memo(({ onAdd }) => {
  const [text, setText] = useState("");
  const [isOpen, setIsOpen] = useState(false);

  if (!isOpen) {
    return (
      <button 
        className="t-btn-gray" 
        style={{ width: 'fit-content', padding: '6px 12px', fontSize: '14px' }} 
        onClick={() => setIsOpen(true)}
      >
        Add an item
      </button>
    );
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
      <textarea 
        autoFocus 
        value={text} 
        onChange={e => setText(e.target.value)} 
        placeholder="Add an item" 
        style={{ 
          width: '100%', 
          padding: '8px 12px', 
          borderRadius: '3px', 
          border: '2px solid #0079bf', 
          outline: 'none', 
          resize: 'vertical', 
          minHeight: '56px', 
          fontSize: '14px', 
          fontFamily: 'inherit', 
          color: '#172b4d' 
        }} 
      />
      <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
        <button 
          className="btn-blue" 
          onClick={() => { 
            if (text.trim()) { 
              onAdd(text); 
              setText(""); 
              setIsOpen(false); 
            } 
          }} 
          style={{ padding: '6px 16px', borderRadius: '3px', border: 'none', background: '#0052cc', color: 'white', fontWeight: 500, cursor: 'pointer' }}
        >
          Add
        </button>
        <button 
          onClick={() => { setIsOpen(false); setText(""); }} 
          style={{ background: 'transparent', border: 'none', cursor: 'pointer', color: '#42526e', fontWeight: 500, padding: '6px 12px' }}
        >
          Cancel
        </button>
      </div>
    </div>
  );
});